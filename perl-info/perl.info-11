Info file: perl.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `bigperl.texi'
using `texinfmt.el' version 2.32 of 19 November 1993.

settitle perl



File: perl.info, Node: perlre, Next: perlrun, Prev: perlop, Up: Top

Perl regular expressions
************************



NAME
====

perlre - Perl regular expressions


DESCRIPTION
===========

This page describes the syntax of regular expressions in Perl.  For a
description of how to use regular expressions in matching
operations, plus various examples of the same, see m// and s/// in
*Note Perlop: perlop,.

The matching operations can have various modifiers.  The modifiers which
relate to the interpretation of the regular expression inside are listed
below.  For the modifiers that alter the behaviour of the operation, see
`"m', *Note Perlop: perlop, and `"s',
*Note Perlop: perlop,.

i
     Do case-insensitive pattern matching.

     If `use locale' is in effect, the case map is taken from the
     current locale.  See *Note Perllocale: perllocale,.

m
     Treat string as multiple lines.  That is, change "^" and "$" from
     matching at only the very start or end of the string to the start
     or end of any line anywhere within the string,

s
     Treat string as single line.  That is, change "." to match any
     character whatsoever, even a newline, which it normally would not
     match.

x
     Extend your pattern's legibility by permitting whitespace and
     comments.

These are usually written as "the `/x' modifier", even though the
delimiter in question might not actually be a slash.  In fact, any of
these modifiers may also be embedded within the regular expression
itself using the new `(?...)' construct.  See below.

The `/x' modifier itself needs a little more explanation.  It tells the
regular expression parser to ignore whitespace that is neither
backslashed nor within a character class.  You can use this to break up
your regular expression into (slightly) more readable parts.  The `#'
character is also treated as a metacharacter introducing a comment, just
as in ordinary Perl code.  This also means that if you want real
whitespace or `#' characters in the pattern that you'll have to either
escape them or encode them using octal or hex escapes.  Taken together,
these features go a long way towards making Perl's regular expressions
more readable.  See the C comment deletion code in *Note Perlop:
perlop,.


Regular Expressions
-------------------

The patterns used in pattern matching are regular expressions such as
those supplied in the Version 8 regexp routines.  (In fact, the routines
are derived (distantly) from Henry Spencer's freely redistributable
reimplementation of the V8 routines.)  See `Version 8 Regular
Expressions' in this node for details.

In particular the following metacharacters have their standard
*egrep*-ish meanings:

     \	Quote the next metacharacter
     ^	Match the beginning of the line
     .	Match any character (except newline)
     $	Match the end of the line (or before newline at the end)
     |	Alternation
     ()	Grouping
     []	Character class

By default, the "^" character is guaranteed to match at only the
beginning of the string, the "$" character at only the end (or before
the newline at the end) and Perl does certain optimizations with the
assumption that the string contains only one line.  Embedded newlines
will not be matched by "^" or "$".  You may, however, wish to treat a
string as a multi-line buffer, such that the "^" will match after any
newline within the string, and "$" will match before any newline.  At
the cost of a little more overhead, you can do this by using the /m
modifier on the pattern match operator.  (Older programs did this by
setting $*, but this practice is now deprecated.)

To facilitate multi-line substitutions, the "." character never matches
a newline unless you use the `/s' modifier, which in effect tells Perl
to pretend the string is a single line--even if it isn't.  The `/s'
modifier also overrides the setting of $*, in case you have some (badly
behaved) older code that sets it in another module.

The following standard quantifiers are recognized:

     *	   Match 0 or more times
     +	   Match 1 or more times
     ?	   Match 1 or 0 times
     {n}    Match exactly n times
     {n,}   Match at least n times
     {n,m}  Match at least n but not more than m times

(If a curly bracket occurs in any other context, it is treated as a
regular character.)  The "*" modifier is equivalent to `{0,}', the "+"
modifier to `{1,}', and the "?" modifier to `{0,1}'.  n and m are
limited to integral values less than 65536.

By default, a quantified subpattern is "greedy", that is, it will match
as many times as possible (given a particular starting location) while
still allowing the rest of the pattern to match.  If you want it to
match the minimum number of times possible, follow the quantifier with a
"?".  Note that the meanings don't change, just the "greediness":

     *?	   Match 0 or more times
     +?	   Match 1 or more times
     ??	   Match 0 or 1 time
     {n}?   Match exactly n times
     {n,}?  Match at least n times
     {n,m}? Match at least n but not more than m times

Because patterns are processed as double quoted strings, the following
also work:

     \t		tab                   (HT, TAB)
     \n		newline               (LF, NL)
     \r		return                (CR)
     \f		form feed             (FF)
     \a		alarm (bell)          (BEL)
     \e		escape (think troff)  (ESC)
     \033	octal char (think of a PDP-11)
     \x1B	hex char
     \c[		control char
     \l		lowercase next char (think vi)
     \u		uppercase next char (think vi)
     \L		lowercase till \E (think vi)
     \U		uppercase till \E (think vi)
     \E		end case modification (think vi)
     \Q		quote regexp metacharacters till \E

If `use locale' is in effect, the case map used by `\l', `\L', `\u' and
<\U> is taken from the current locale.  See *Note Perllocale:
perllocale,.

In addition, Perl defines the following:

     \w	Match a "word" character (alphanumeric plus "_")
     \W	Match a non-word character
     \s	Match a whitespace character
     \S	Match a non-whitespace character
     \d	Match a digit character
     \D	Match a non-digit character

Note that `\w' matches a single alphanumeric character, not a whole
word.  To match a word you'd need to say `\w+'.  If `use locale' is in
effect, the list of alphabetic characters generated by `\w' is taken
from the current locale.  See *Note Perllocale: perllocale,. You may use
`\w', `\W', `\s', `\S', `\d', and `\D' within character classes (though
not as either end of a range).

Perl defines the following zero-width assertions:

     \b	Match a word boundary
     \B	Match a non-(word boundary)
     \A	Match at only beginning of string
     \Z	Match at only end of string (or before newline at the end)
     \G	Match only where previous m//g left off (works only with /g)

A word boundary (`\b') is defined as a spot between two characters that
has a `\w' on one side of it and a `\W' on the other side of it (in
either order), counting the imaginary characters off the beginning and
end of the string as matching a `\W'.  (Within character classes `\b'
represents backspace rather than a word boundary.)  The `\A' and `\Z'
are just like "^" and "$" except that they won't match multiple times
when the `/m' modifier is used, while "^" and "$" will match at every
internal line boundary.  To match the actual end of the string, not
ignoring newline, you can use `\Z(?!\n)'.  The `\G' assertion can be
used to chain global matches (using `m//g'), as described in `"Regexp
Quote-Like Operators"', *Note Perlop: perlop,.

It is also useful when writing `lex'-like scanners, when you have
several regexps which you want to match against consequent substrings of
your string, see the previous reference.  The actual location where `\G'
will match can also be influenced by using `pos()' as an lvalue.  See
`pos', *Note Perlfunc: perlfunc,.

When the bracketing construct `( ... )' is used, \<digit> matches the
digit'th substring.  Outside of the pattern, always use "$" instead of
"\" in front of the digit.  (While the \<digit> notation can on rare
occasion work outside the current pattern, this should not be relied
upon.  See the WARNING below.) The scope of $<digit> (and `$`', $&, and
`$'') extends to the end of the enclosing BLOCK or eval string, or to
the next successful pattern match, whichever comes first.  If you want
to use parentheses to delimit a subpattern (e.g., a set of alternatives)
without saving it as a subpattern, follow the ( with a ?:.

You may have as many parentheses as you wish.  If you have more than 9
substrings, the variables $10, $11, ... refer to the corresponding
substring.  Within the pattern, \10, \11, etc. refer back to substrings
if there have been at least that many left parentheses before the
backreference.  Otherwise (for backward compatibility) \10 is the same
as \010, a backspace, and \11 the same as \011, a tab.  And so on.  (\1
through \9 are always backreferences.)

$+ returns whatever the last bracket match matched.  $& returns the
entire matched string.  ($0 used to return the same thing, but not any
more.)  `$`' returns everything before the matched string.  `$'' returns
everything after the matched string.  Examples:

     s/^([^ ]*) *([^ ]*)/$2 $1/;     # swap first two words

     if (/Time: (..):(..):(..)/) {
     	$hours = $1;
     	$minutes = $2;
     	$seconds = $3;
     }

Once perl sees that you need one of $&, `$`' or `$'' anywhere in the
program, it has to provide them on each and every pattern match.  This
can slow your program down.  The same mechanism that handles these
provides for the use of $1, $2, etc., so you pay the same price for each
regexp that contains capturing parentheses. But if you never use $&,
etc., in your script, then regexps *without* capturing parentheses won't
be penalized. So avoid $&, $', and $` if you can, but if you can't (and
some algorithms really appreciate them), once you've used them once, use
them at will, because you've already paid the price.

You will note that all backslashed metacharacters in Perl are
alphanumeric, such as `\b', `\w', `\n'.  Unlike some other regular
expression languages, there are no backslashed symbols that aren't
alphanumeric.  So anything that looks like \\, \(, \), \<, \>, \{, or \}
is always interpreted as a literal character, not a metacharacter.  This
makes it simple to quote a string that you want to use for a pattern but
that you are afraid might contain metacharacters.  Quote simply all the
non-alphanumeric characters:

     $pattern =~ s/(\W)/\\$1/g;

You can also use the builtin quotemeta() function to do this.  An even
easier way to quote metacharacters right in the match operator is to say

     /$unquoted\Q$quoted\E$unquoted/

Perl defines a consistent extension syntax for regular expressions.  The
syntax is a pair of parentheses with a question mark as the first thing
within the parentheses (this was a syntax error in older versions of
Perl).  The character after the question mark gives the function of the
extension.  Several extensions are already supported:

(?#text)
     A comment.  The text is ignored.  If the `/x' switch is used to
     enable whitespace formatting, a simple `#' will suffice.

(?:regexp)
     This groups things like "()" but doesn't make backreferences like
     "()" does.  So

          split(/\b(?:a|b|c)\b/)

     is like

          split(/\b(a|b|c)\b/)

     but doesn't spit out extra fields.

(?=regexp)
     A zero-width positive lookahead assertion.  For example,
     `/\w+(?=\t)/' matches a word followed by a tab, without including
     the tab in $&.

(?!regexp)
     A zero-width negative lookahead assertion.  For example
     `/foo(?!bar)/' matches any occurrence of "foo" that isn't followed
     by "bar".  Note however that lookahead and lookbehind are NOT the
     same thing.  You cannot use this for lookbehind: `/(?!foo)bar/'
     will not find an occurrence of "bar" that is preceded by something
     which is not "foo".  That's because the `(?!foo)' is just saying
     that the next thing cannot be "foo"--and it's not, it's a "bar", so
     "foobar" will match.  You would have to do something like
     `/(?!foo)...bar/' for that.  We say "like" because there's the case
     of your "bar" not having three characters before it.  You could
     cover that this way: `/(?:(?!foo)...|^..?)bar/'.  Sometimes it's
     still easier just to say:

          if (/foo/ && $` =~ /bar$/)

(?imsx)
     One or more embedded pattern-match modifiers.  This is particularly
     useful for patterns that are specified in a table somewhere, some
     of which want to be case sensitive, and some of which don't.  The
     case insensitive ones need to include merely `(?i)' at the front of
     the pattern.  For example:

          $pattern = "foobar";
          if ( /$pattern/i )

          # more flexible:

          $pattern = "(?i)foobar";
          if ( /$pattern/ )

The specific choice of question mark for this and the new minimal
matching construct was because 1) question mark is pretty rare in older
regular expressions, and 2) whenever you see one, you should stop and
"question" exactly what is going on.  That's psychology...


Backtracking
------------

A fundamental feature of regular expression matching involves the notion
called *backtracking*.  which is used (when needed) by all regular
expression quantifiers, namely *, `*?', `+', `+?', `{n,m}', and
`{n,m}?'.

For a regular expression to match, the *entire* regular expression must
match, not just part of it.  So if the beginning of a pattern containing
a quantifier succeeds in a way that causes later parts in the pattern to
fail, the matching engine backs up and recalculates the beginning
part--that's why it's called backtracking.

Here is an example of backtracking: Let's say you want to find the word
following "foo" in the string "Food is on the foo table.":

     $_ = "Food is on the foo table.";
     if ( /\b(foo)\s+(\w+)/i ) {
     	print "$2 follows $1.\n";
     }

When the match runs, the first part of the regular expression
(`\b(foo)') finds a possible match right at the beginning of the string,
and loads up $1 with "Foo".  However, as soon as the matching engine
sees that there's no whitespace following the "Foo" that it had saved in
$1, it realizes its mistake and starts over again one character after
where it had the tentative match.  This time it goes all the way until
the next occurrence of "foo". The complete regular expression matches
this time, and you get the expected output of "table follows foo."

Sometimes minimal matching can help a lot.  Imagine you'd like to match
everything between "foo" and "bar".  Initially, you write something like
this:

     $_ =  "The food is under the bar in the barn.";
     if ( /foo(.*)bar/ ) {
     	print "got <$1>\n";
     }

Which perhaps unexpectedly yields:

     got <d is under the bar in the >

That's because `.*' was greedy, so you get everything between the
*first* "foo" and the last "bar".  In this case, it's more effective
to use minimal matching to make sure you get the text between a "foo"
and the first "bar" thereafter.

     if ( /foo(.*?)bar/ ) { print "got <$1>\n" }
       got <d is under the >

Here's another example: let's say you'd like to match a number at the
end of a string, and you also want to keep the preceding part the match.
So you write this:

     $_ = "I have 2 numbers: 53147";
     if ( /(.*)(\d*)/ ) {				# Wrong!
     	print "Beginning is <$1>, number is <$2>.\n";
     }

That won't work at all, because `.*' was greedy and gobbled up the whole
string. As `\d*' can match on an empty string the complete regular
expression matched successfully.

     Beginning is <I have 2 numbers: 53147>, number is <>.

Here are some variants, most of which don't work:

     $_ = "I have 2 numbers: 53147";
     @pats = qw{
     	(.*)(\d*)
     	(.*)(\d+)
     	(.*?)(\d*)
     	(.*?)(\d+)
     	(.*)(\d+)$
     	(.*?)(\d+)$
     	(.*)\b(\d+)$
     	(.*\D)(\d+)$
     };

     for $pat (@pats) {
     	printf "%-12s ", $pat;
     	if ( /$pat/ ) {
     	    print "<$1> <$2>\n";
     	} else {
     	    print "FAIL\n";
     	}
     }

That will print out:

     (.*)(\d*)    <I have 2 numbers: 53147> <>
     (.*)(\d+)    <I have 2 numbers: 5314> <7>
     (.*?)(\d*)   <> <>
     (.*?)(\d+)   <I have > <2>
     (.*)(\d+)$   <I have 2 numbers: 5314> <7>
     (.*?)(\d+)$  <I have 2 numbers: > <53147>
     (.*)\b(\d+)$ <I have 2 numbers: > <53147>
     (.*\D)(\d+)$ <I have 2 numbers: > <53147>

As you see, this can be a bit tricky.  It's important to realize that a
regular expression is merely a set of assertions that gives a definition
of success.  There may be 0, 1, or several different ways that the
definition might succeed against a particular string.  And if there are
multiple ways it might succeed, you need to understand backtracking to
know which variety of success you will achieve.

When using lookahead assertions and negations, this can all get even
tricker.  Imagine you'd like to find a sequence of non-digits not
followed by "123".  You might try to write that as

     $_ = "ABC123";
     if ( /^\D*(?!123)/ ) {				# Wrong!
         print "Yup, no 123 in $_\n";
     }

But that isn't going to match; at least, not the way you're hoping.  It
claims that there is no 123 in the string.  Here's a clearer picture of
why it that pattern matches, contrary to popular expectations:

     $x = 'ABC123' ;
     $y = 'ABC445' ;

     print "1: got $1\n" if $x =~ /^(ABC)(?!123)/ ;
     print "2: got $1\n" if $y =~ /^(ABC)(?!123)/ ;

     print "3: got $1\n" if $x =~ /^(\D*)(?!123)/ ;
     print "4: got $1\n" if $y =~ /^(\D*)(?!123)/ ;

This prints

     2: got ABC
     3: got AB
     4: got ABC

You might have expected test 3 to fail because it seems to a more
general purpose version of test 1.  The important difference between
them is that test 3 contains a quantifier (`\D*') and so can use
backtracking, whereas test 1 will not.  What's happening is that you've
asked "Is it true that at the start of $x, following 0 or more
non-digits, you have something that's not 123?"  If the pattern matcher
had let `\D*' expand to "ABC", this would have caused the whole pattern
to fail.  The search engine will initially match `\D*' with "ABC".  Then
it will try to match `(?!123' with "123" which, of course, fails.  But
because a quantifier (`\D*') has been used in the regular expression,
the search engine can backtrack and retry the match differently in the
hope of matching the complete regular expression.

Well now, the pattern really, *really* wants to succeed, so it uses the
standard regexp back-off-and-retry and lets `\D*' expand to just "AB"
this time.  Now there's indeed something following "AB" that is not
"123".  It's in fact "C123", which suffices.

We can deal with this by using both an assertion and a negation.  We'll
say that the first part in $1 must be followed by a digit, and in fact,
it must also be followed by something that's not "123".  Remember that
the lookaheads are zero-width expressions--they only look, but don't
consume any of the string in their match.  So rewriting this way
produces what you'd expect; that is, case 5 will fail, but case 6
succeeds:

     print "5: got $1\n" if $x =~ /^(\D*)(?=\d)(?!123)/ ;
     print "6: got $1\n" if $y =~ /^(\D*)(?=\d)(?!123)/ ;

     6: got ABC

In other words, the two zero-width assertions next to each other work
like they're ANDed together, just as you'd use any builtin assertions:
`/^$/' matches only if you're at the beginning of the line AND the end
of the line simultaneously.  The deeper underlying truth is that
juxtaposition in regular expressions always means AND, except when you
write an explicit OR using the vertical bar.  `/ab/' means match "a" AND
(then) match "b", although the attempted matches are made at different
positions because "a" is not a zero-width assertion, but a one-width
assertion.

One warning: particularly complicated regular expressions can take
exponential time to solve due to the immense number of possible ways
they can use backtracking to try match.  For example this will take a
very long time to run

     /((a{0,5}){0,5}){0,5}/

And if you used *'s instead of limiting it to 0 through 5 matches, then
it would take literally forever--or until you ran out of stack space.


Version 8 Regular Expressions
-----------------------------

In case you're not familiar with the "regular" Version 8 regexp
routines, here are the pattern-matching rules not described above.

Any single character matches itself, unless it is a *metacharacter* with
a special meaning described here or above.  You can cause characters
which normally function as metacharacters to be interpreted literally by
prefixing them with a "\" (e.g., "\." matches a ".", not any character;
"\\" matches a "\").  A series of characters matches that series of
characters in the target string, so the pattern `blurfl' would match
"blurfl" in the target string.

You can specify a character class, by enclosing a list of characters in
`[]', which will match any one of the characters in the list.  If the
first character after the "[" is "^", the class matches any character
not in the list.  Within a list, the "-" character is used to specify a
range, so that `a-z' represents all the characters between "a" and "z",
inclusive.  If you want "-" itself to be a member of a class, put it at
the start or end of the list, or escape it with a backslash.  (The
following all specify the same class of three characters: `[-az]',
`[az-]', and `[a\-z]'.  All are different from `[a-z]', which specifies
a class containing twenty-six characters.)

Characters may be specified using a metacharacter syntax much like that
used in C: "\n" matches a newline, "\t" a tab, "\r" a carriage return,
"\f" a form feed, etc.  More generally, \*nnn*, where *nnn* is a string
of octal digits, matches the character whose ASCII value is *nnn*.
Similarly, \x*nn*, where *nn* are hexadecimal digits, matches the
character whose ASCII value is *nn*. The expression \cx matches the
ASCII character control-x.  Finally, the "." metacharacter matches any
character except "\n" (unless you use `/s').

You can specify a series of alternatives for a pattern using "|" to
separate them, so that `fee|fie|foe' will match any of "fee", "fie", or
"foe" in the target string (as would `f(e|i|o)e').  Note that the first
alternative includes everything from the last pattern delimiter ("(",
"[", or the beginning of the pattern) up to the first "|", and the last
alternative contains everything from the last "|" to the next pattern
delimiter.  For this reason, it's common practice to include
alternatives in parentheses, to minimize confusion about where they
start and end.  Note however that "|" is interpreted as a literal with
square brackets, so if you write `[fee|fie|foe]' you're really only
matching `[feio|]'.

Within a pattern, you may designate subpatterns for later reference by
enclosing them in parentheses, and you may refer back to the nth
subpattern later in the pattern using the metacharacter \n.  Subpatterns
are numbered based on the left to right order of their opening
parenthesis.  Note that a backreference matches whatever actually
matched the subpattern in the string being examined, not the rules for
that subpattern.  Therefore, `(0|0x)\d*\s\1\d*' will match "0x1234
0x4321",but not "0x1234 01234", because subpattern 1 actually matched
"0x", even though the rule `0|0x' could potentially match the leading 0
in the second number.


WARNING on \1 vs $1
-------------------

Some people get too used to writing things like

     $pattern =~ s/(\W)/\\\1/g;

This is grandfathered for the RHS of a substitute to avoid shocking the
*sed* addicts, but it's a dirty habit to get into.  That's because in
PerlThink, the righthand side of a s/// is a double-quoted string.  \1
in the usual double-quoted string means a control-A.  The customary Unix
meaning of \1 is kludged in for s///.  However, if you get into the
habit of doing that, you get yourself into trouble if you then add an
`/e' modifier.

     s/(\d+)/ \1 + 1 /eg;

Or if you try to do

     s/(\d+)/\1000/;

You can't disambiguate that by saying `\{1}000', whereas you can fix it
with `${1}000'.  Basically, the operation of interpolation should not be
confused with the operation of matching a backreference.  Certainly they
mean two different things on the *left* side of the s///.


SEE ALSO
--------

"Mastering Regular Expressions" (see *Note Perlbook: perlbook,) by
Jeffrey Friedl.



File: perl.info, Node: perlbook, Next: perlembed, Prev: perlpod, Up: Top

Perl book information
*********************



NAME
====

perlbook - Perl book information


DESCRIPTION
===========

You can order Perl books from O'Reilly & Associates, 1-800-998-9938.
Local/overseas is +1 707 829 0515.  If you can locate an O'Reilly order
form, you can also fax to +1 707 829 0104.  If you're web-connected, you
can even mosey on over to http://www.ora.com/ for an online order form.

*Programming Perl, Second Edition* is a reference work that covers
nearly all of Perl, while *Learning Perl, Second Edition* is a
tutorial that covers the most frequently used subset of the language.
You might also check out the very handy, inexpensive, and compact
*Perl 5 Desktop Reference*, especially when the thought of lugging
the 676-page Camel around doesn't make much sense.  *Mastering Regular
Expressions*, by Jeffrey Friedl, is a reference work that covers the art
and implementation of regular expressions in various languages including
Perl.

     Programming Perl, Second Edition (the Camel Book):
     	ISBN 1-56592-149-6	(English)

     Learning Perl, Second Edition (the Llama Book):
     	ISBN 1-56592-284-0      (English)

     Perl 5 Desktop Reference (the reference card):
     	ISBN 1-56592-187-9	(brief English)

     Mastering Regular Expressions (the Hip Owl Book):
	ISBN 1-56592-257-3      (English)



File: perl.info, Node: perlrun, Next: perlfunc, Prev: perlre, Up: Top

how to execute the Perl interpreter
***********************************



NAME
====

perlrun - how to execute the Perl interpreter


SYNOPSIS
========

*perl*	[ *-sTuU* ]
	[ *-hv* ] [ -V[:*configvar*] ]
	[ *-cw* ] [ -d[:*debugger*] ] [ -D[*number/list*] ]
	[ *-pna* ] [ -F*pattern* ] [ -l[*octal*] ] [ -0[*octal*] ]
	[ -Idir ] [ -m[-]*module* ] [ -M[-]*'module...'* ]
	[ -P ]
	[ -S ]
	[ -x[dir] ]
	[ -i[*extension*] ]
	[ -e *'command'* ] [ *--* ] [ *programfile* ] [ argument ]...


DESCRIPTION
===========

Upon startup, Perl looks for your script in one of the following
places:

  1. Specified line by line via -e switches on the command line.

  2. Contained in the file specified by the first filename on the command line.
     (Note that systems supporting the #! notation invoke interpreters this way.)

  3. Passed in implicitly via standard input.  This works only if there are
     no filename arguments--to pass arguments to a STDIN script you
     must explicitly specify a "-" for the script name.

With methods 2 and 3, Perl starts parsing the input file from the
beginning, unless you've specified a -x switch, in which case it
scans for the first line starting with #! and containing the word
"perl", and starts there instead.  This is useful for running a script
embedded in a larger message.  (In this case you would indicate the end
of the script using the `__END__' token.)

The #! line is always examined for switches as the line is being
parsed.  Thus, if you're on a machine that allows only one argument
with the #! line, or worse, doesn't even recognize the #! line, you
still can get consistent switch behavior regardless of how Perl was
invoked, even if -x was used to find the beginning of the script.

Because many operating systems silently chop off kernel interpretation of
the #! line after 32 characters, some switches may be passed in on the
command line, and some may not; you could even get a "-" without its
letter, if you're not careful.  You probably want to make sure that all
your switches fall either before or after that 32 character boundary.
Most switches don't actually care if they're processed redundantly, but
getting a - instead of a complete switch could cause Perl to try to
execute standard input instead of your script.  And a partial -I switch
could also cause odd results.

Parsing of the #! switches starts wherever "perl" is mentioned in the line.
The sequences "-*" and "- " are specifically ignored so that you could,
if you were so inclined, say

     #!/bin/sh -- # -*- perl -*- -p
     eval 'exec /usr/bin/perl $0 -S ${1+"$@"}'
         if $running_under_some_shell;

to let Perl see the -p switch.

If the #! line does not contain the word "perl", the program named after
the #! is executed instead of the Perl interpreter.  This is slightly
bizarre, but it helps people on machines that don't do #!, because they
can tell a program that their SHELL is /usr/bin/perl, and Perl will then
dispatch the program to the correct interpreter for them.

After locating your script, Perl compiles the entire script to an
internal form.  If there are any compilation errors, execution of the
script is not attempted.  (This is unlike the typical shell script,
which might run part-way through before finding a syntax error.)

If the script is syntactically correct, it is executed.  If the script
runs off the end without hitting an exit() or die() operator, an
implicit `exit(0)' is provided to indicate successful completion.


#! and quoting on non-Unix systems
----------------------------------

Unix's #! technique can be simulated on other systems:

OS/2
     Put

          extproc perl -S -your_switches

     as the first line in `*.cmd' file (-S due to a bug in cmd.exe's
     `extproc' handling).

MS-DOS
     Create a batch file to run your script, and codify it in
     `ALTERNATIVE_SHEBANG' (see the `dosish.h' file in the source
     distribution for more information).

Win95/NT
     The Win95/NT installation, when using the Activeware port of Perl,
     will modify the Registry to associate the .pl extension with the
     perl interpreter.  If you install another port of Perl, including
     the one in the Win32 directory of the Perl distribution, then
     you'll have to modify the Registry yourself.

Macintosh
     Macintosh perl scripts will have the appropriate Creator and Type,
     so that double-clicking them will invoke the perl application.

Command-interpreters on non-Unix systems have rather different ideas on
quoting than Unix shells.  You'll need to learn the special characters
in your command-interpreter (*, `\' and `"' are common) and how to
protect whitespace and these characters to run one-liners (see -e
below).

On some systems, you may have to change single-quotes to double ones,
which you must *NOT* do on Unix or Plan9 systems.  You might also have
to change a single % to a %%.

For example:

     # Unix
     perl -e 'print "Hello world\n"'

     # MS-DOS, etc.
     perl -e "print \"Hello world\n\""

     # Macintosh
     print "Hello world\n"
      (then Run "Myscript" or Shift-Command-R)

     # VMS
     perl -e "print ""Hello world\n"""

The problem is that none of this is reliable: it depends on the command
and it is entirely possible neither works.  If 4DOS was the command
shell, this would probably work better:

     perl -e "print <Ctrl-x>"Hello world\n<Ctrl-x>""

CMD.EXE in Windows NT slipped a lot of standard Unix functionality in
when nobody was looking, but just try to find documentation for its
quoting rules.

Under the Macintosh, it depends which environment you are using.  The
MacPerl shell, or MPW, is much like Unix shells in its support for
several quoting variants, except that it makes free use of the
Macintosh's non-ASCII characters as control characters.

There is no general solution to all of this.  It's just a mess.


Switches
--------

A single-character switch may be combined with the following switch, if
any.

     #!/usr/bin/perl -spi.bak	# same as -s -p -i.bak

Switches include:

-0[*digits*]
     specifies the input record separator ($/) as an octal number.  If there are
     no digits, the null character is the separator.  Other switches may
     precede or follow the digits.  For example, if you have a version of
     *find* which can print filenames terminated by the null character, you
     can say this:

          find . -name '*.bak' -print0 | perl -n0e unlink

     The special value 00 will cause Perl to slurp files in paragraph
     mode.  The value 0777 will cause Perl to slurp files whole because
     there is no legal character with that value.

-a
     turns on autosplit mode when used with a -n or -p.  An implicit
     split command to the @F array is done as the first thing inside the
     implicit while loop produced by the -n or -p.

          perl -ane 'print pop(@F), "\n";'

     is equivalent to

          while (<>) {
          	@F = split(' ');
          	print pop(@F), "\n";
          }

     An alternate delimiter may be specified using -F.

-c
     causes Perl to check the syntax of the script and then exit without
     executing it.  Actually, it *will* execute BEGIN, END, and use
     blocks, because these are considered as occurring outside the
     execution of your program.

-d
     runs the script under the Perl debugger.  See *Note Perldebug:
     perldebug,.

*-d:*foo
     runs the script under the control of a debugging or tracing module
     installed as Devel::foo. E.g., *-d:DProf* executes the script using
     the Devel::DProf profiler.  See *Note Perldebug: perldebug,.

-Dnumber
-Dlist
     sets debugging flags.  To watch how it executes your script, use
     *-D14*.  (This works only if debugging is compiled into your
     Perl.)  Another nice value is *-D1024*, which lists your compiled
     syntax tree.  And *-D512* displays compiled regular expressions. As
     an alternative specify a list of letters instead of numbers (e.g.,
     *-D14* is equivalent to *-Dtls*):

          1  p  Tokenizing and Parsing
          2  s  Stack Snapshots
          4  l  Label Stack Processing
          8  t  Trace Execution
                 16  o  Operator Node Construction
                 32  c  String/Numeric Conversions
                 64  P  Print Preprocessor Command for -P
                128  m  Memory Allocation
                256  f  Format Processing
                512  r  Regular Expression Parsing
               1024  x  Syntax Tree Dump
               2048  u  Tainting Checks
               4096  L  Memory Leaks (not supported anymore)
               8192  H  Hash Dump -- usurps values()
              16384  X  Scratchpad Allocation
              32768  D  Cleaning Up

-e *commandline*
     may be used to enter one line of script.  If -e is given, Perl will
     not look for a script filename in the argument list.  Multiple -e
     commands may be given to build up a multi-line script.  Make sure
     to use semicolons where you would in a normal program.

-F*pattern*
     specifies the pattern to split on if -a is also in effect.  The
     pattern may be surrounded by `//', `""', or `''', otherwise it will
     be put in single quotes.

-h
     prints a summary of the options.

-i[*extension*]
     specifies that files processed by the `<>' construct are to be
     edited in-place.  It does this by renaming the input file, opening
     the output file by the original name, and selecting that output
     file as the default for print() statements.  The extension, if
     supplied, is added to the name of the old file to make a backup
     copy.  If no extension is supplied, no backup is made.  From the
     shell, saying

          $ perl -p -i.bak -e "s/foo/bar/; ... "

     is the same as using the script:

          #!/usr/bin/perl -pi.bak
          s/foo/bar/;

     which is equivalent to

          #!/usr/bin/perl
          while (<>) {
          	if ($ARGV ne $oldargv) {
          	    rename($ARGV, $ARGV . '.bak');
          	    open(ARGVOUT, ">$ARGV");
          	    select(ARGVOUT);
          	    $oldargv = $ARGV;
          	}
          	s/foo/bar/;
          }
          continue {
          	print;	# this prints to original filename
          }
          select(STDOUT);

     except that the -i form doesn't need to compare $ARGV to $oldargv
     to know when the filename has changed.  It does, however, use
     ARGVOUT for the selected filehandle.  Note that STDOUT is restored
     as the default output filehandle after the loop.

     You can use eof without parenthesis to locate the end of each input
     file, in case you want to append to each file, or reset line
     numbering (see example in `eof', *Note Perlfunc: perlfunc,).

-I*directory*
     Directories specified by -I are prepended to the search path for
     modules (`@INC'), and also tells the C preprocessor where to search
     for include files.  The C preprocessor is invoked with -P; by
     default it searches /usr/include and /usr/lib/perl.

-l[*octnum*]
     enables automatic line-ending processing.  It has two effects:  first,
     it automatically chomps "$/" (the input record separator) when used
     with -n or -p, and second, it assigns "$\"
     (the output record separator) to have the value of *octnum* so that
     any print statements will have that separator added back on.  If
     *octnum* is omitted, sets "$\" to the current value of "$/".  For
     instance, to trim lines to 80 columns:

          perl -lpe 'substr($_, 80) = ""'

     Note that the assignment `$\ = $/' is done when the switch is
     processed, so the input record separator can be different than the
     output record separator if the -l switch is followed by a -0
     switch:

          gnufind / -print0 | perl -ln0e 'print "found $_" if -p'

     This sets $\ to newline and then sets $/ to the null character.

-m[-]*module*
-M[-]*module*
-M[-]*'module ...'*
*-[mM]*[-]*module=arg[,arg]...*
     -m*module* executes use *module* `();' before executing your
     script.

     -M*module* executes use *module* `;' before executing your
     script.  You can use quotes to add extra code after the module
     name, e.g., `-M'module qw(foo bar)''.

     If the first character after the -M or -m is a dash (-) then the
     'use' is replaced with 'no'.

     A little builtin syntactic sugar means you can also say
     `-mmodule=foo,bar' or `-Mmodule=foo,bar' as a shortcut for
     `-M'module qw(foo bar)''.  This avoids the need to use quotes when
     importing symbols.  The actual code generated by `-Mmodule=foo,bar'
     is `use module split(/,/,q{foo,bar})'.  Note that the = form
     removes the distinction between -m and -M.

-n
     causes Perl to assume the following loop around your script, which
     makes it iterate over filename arguments somewhat like *sed -n* or
     *awk*:

          while (<>) {
          	...		# your script goes here
          }

     Note that the lines are not printed by default.  See -p to have
     lines printed.  If a file named by an argument cannot be opened for
     some reason, Perl warns you about it, and moves on to the next
     file.

     Here is an efficient way to delete all files older than a week:

          find . -mtime +7 -print | perl -nle 'unlink;'

     This is faster than using the `-exec' switch of *find* because you
     don't have to start a process on every filename found.

     BEGIN and END blocks may be used to capture control before or after
     the implicit loop, just as in *awk*.

-p
     causes Perl to assume the following loop around your script, which
     makes it iterate over filename arguments somewhat like *sed*:

          while (<>) {
          	...		# your script goes here
          } continue {
          	print or die "-p destination: $!\n";
          }

     If a file named by an argument cannot be opened for some reason,
     Perl warns you about it, and moves on to the next file.  Note that
     the lines are printed automatically.  An error occuring during
     printing is treated as fatal.  To suppress printing use the -n
     switch.  A -p overrides a -n switch.

     BEGIN and END blocks may be used to capture control before or after
     the implicit loop, just as in awk.

-P
     causes your script to be run through the C preprocessor before
     compilation by Perl.  (Because both comments and cpp directives
     begin with the # character, you should avoid starting comments with
     any words recognized by the C preprocessor such as "if", "else", or
     "define".)

-s
     enables some rudimentary switch parsing for switches on the command
     line after the script name but before any filename arguments (or
     before a *--*).  Any switch found there is removed from @ARGV and
     sets the corresponding variable in the Perl script.  The following
     script prints "true" if and only if the script is invoked with a
     *-xyz* switch.

          #!/usr/bin/perl -s
          if ($xyz) { print "true\n"; }

-S
     makes Perl use the PATH environment variable to search for the
     script (unless the name of the script contains directory
     separators).  On some platforms, this also makes Perl append
     suffixes to the filename while searching for it.  For example, on
     Win32 platforms, the ".bat" and ".cmd" suffixes are appended if a
     lookup for the original name fails, and if the name does not
     already end in one of those suffixes.  If your Perl was compiled
     with DEBUGGING turned on, using the -Dp switch to Perl shows how
     the search progresses.

     If the file supplied contains directory separators (i.e. it is an
     absolute or relative pathname), and if the file is not found,
     platforms that append file extensions will do so and try to look
     for the file with those extensions added, one by one.

     On DOS-like platforms, if the script does not contain directory
     separators, it will first be searched for in the current directory
     before being searched for on the PATH.  On Unix platforms, the
     script will be searched for strictly on the PATH.

     Typically this is used to emulate #! startup on platforms that
     don't support #!.  This example works on many platforms that have a
     shell compatible with Bourne shell:

          #!/usr/bin/perl
          eval 'exec /usr/bin/perl -S $0 ${1+"$@"}'
          	    if $running_under_some_shell;

     The system ignores the first line and feeds the script to /bin/sh,
     which proceeds to try to execute the Perl script as a shell script.
     The shell executes the second line as a normal shell command, and
     thus starts up the Perl interpreter.  On some systems $0 doesn't
     always contain the full pathname, so the -S tells Perl to search
     for the script if necessary.  After Perl locates the script, it
     parses the lines and ignores them because the variable
     $running_under_some_shell is never true.  A better construct than
     $* would be `${1+"$@"}', which handles embedded spaces and such in
     the filenames, but doesn't work if the script is being interpreted
     by csh.  To start up sh rather than csh, some systems may have to
     replace the #! line with a line containing just a colon, which will
     be politely ignored by Perl.  Other systems can't control that, and
     need a totally devious construct that will work under any of csh,
     sh, or Perl, such as the following:

          eval '(exit $?0)' && eval 'exec /usr/bin/perl -S $0 ${1+"$@"}'
          & eval 'exec /usr/bin/perl -S $0 $argv:q'
          	if $running_under_some_shell;

-T
     forces "taint" checks to be turned on so you can test them.
     Ordinarily these checks are done only when running setuid or
     setgid.  It's a good idea to turn them on explicitly for programs
     run on another's behalf, such as CGI programs.  See *Note Perlsec:
     perlsec,.

-u
     causes Perl to dump core after compiling your script.  You can then
     take this core dump and turn it into an executable file by using the
     *undump* program (not supplied).  This speeds startup at the expense of
     some disk space (which you can minimize by stripping the
     executable).  (Still, a "hello world" executable comes out to about
     200K on my machine.)  If you want to execute a portion of your
     script before dumping, use the dump() operator instead.  Note:
     availability of *undump* is platform specific and may not be
     available for a specific port of Perl.

-U
     allows Perl to do unsafe operations.  Currently the only "unsafe"
     operations are the unlinking of directories while running as
     superuser, and running setuid programs with fatal taint checks
     turned into warnings.

-v
     prints the version and patchlevel of your Perl executable.

-V
     prints summary of the major perl configuration values and the
     current value of @INC.

*-V:*name
     Prints to STDOUT the value of the named configuration variable.

-w
     prints warnings about variable names that are mentioned only once,
     and scalar variables that are used before being set.  Also warns
     about redefined subroutines, and references to undefined
     filehandles or filehandles opened read-only that you are attempting
     to write on.  Also warns you if you use values as a number that
     doesn't look like numbers, using an array as though it were a
     scalar, if your subroutines recurse more than 100 deep, and
     innumerable other things.

     You can disable specific warnings using `__WARN__' hooks, as
     described in *Note Perlvar: perlvar, and `warn', *Note Perlfunc:
     perlfunc,. See also `warn', *Note Perldiag: perldiag, and `warn',
     *Note Perltrap: perltrap,.

-x *directory*
     tells Perl that the script is embedded in a message.  Leading
     garbage will be discarded until the first line that starts with #!
     and contains the string "perl".  Any meaningful switches on that
     line will be applied.  If a directory name is specified, Perl will
     switch to that directory before running the script.  The -x switch
     controls only the disposal of leading garbage.  The script must be
     terminated with `__END__' if there is trailing garbage to be
     ignored (the script can process any or all of the trailing garbage
     via the DATA filehandle if desired).


ENVIRONMENT
===========

HOME
     Used if chdir has no argument.

LOGDIR
     Used if chdir has no argument and HOME is not set.

PATH
     Used in executing subprocesses, and in finding the script if -S is
     used.

PERL5LIB
     A colon-separated list of directories in which to look for Perl library
     files before looking in the standard library and the current
     directory.  If PERL5LIB is not defined, PERLLIB is used.  When running
     taint checks (because the script was running setuid or setgid, or the
     -T switch was used), neither variable is used.  The script should
     instead say

          use lib "/my/directory";

PERL5OPT
     Command-line options (switches).  Switches in this variable are
     taken as if they were on every Perl command line.  Only the
     *-[DIMUdmw]* switches are allowed.  When running taint checks
     (because the script was running setuid or setgid, or the -T switch
     was used), this variable is ignored.

PERLLIB
     A colon-separated list of directories in which to look for Perl
     library files before looking in the standard library and the
     current directory.  If PERL5LIB is defined, PERLLIB is not used.

PERL5DB
     The command used to load the debugger code.  The default is:

          BEGIN { require 'perl5db.pl' }

PERL5SHELL (specific to WIN32 port)
     May be set to an alternative shell that perl must use internally
     for executing "backtick" commands or system().  Perl doesn't use
     COMSPEC for this purpose because COMSPEC has a high degree of
     variability among users, leading to portability concerns.  Besides,
     perl can use a shell that may not be fit for interactive use, and
     setting COMSPEC to such a shell may interfere with the proper
     functioning of other programs (which usually look in COMSPEC to
     find a shell fit for interactive use).

PERL_DEBUG_MSTATS
     Relevant only if your perl executable was built with
     *-DDEBUGGING_MSTATS*, if set, this causes memory statistics to be
     dumped after execution.  If set to an integer greater than one,
     also causes memory statistics to be dumped after compilation.

PERL_DESTRUCT_LEVEL
     Relevant only if your perl executable was built with *-DDEBUGGING*,
     this controls the behavior of global destruction of objects and
     other references.

Perl also has environment variables that control how Perl handles data
specific to particular natural languages.  See *Note Perllocale:
perllocale,.

Apart from these, Perl uses no other environment variables, except to
make them available to the script being executed, and to child
processes.  However, scripts running setuid would do well to execute the
following lines before doing anything else, just to keep people honest:

     $ENV{PATH} = '/bin:/usr/bin';    # or whatever you need
     $ENV{SHELL} = '/bin/sh' if exists $ENV{SHELL};
     delete @ENV{qw(IFS CDPATH ENV BASH_ENV)};




File: perl.info, Node: perldsc, Next: perllol, Prev: perlref, Up: Top

Perl Data Structures Cookbook
*****************************



NAME
====

perldsc - Perl Data Structures Cookbook


DESCRIPTION
===========

The single feature most sorely lacking in the Perl programming language
prior to its 5.0 release was complex data structures.  Even without
direct language support, some valiant programmers did manage to emulate
them, but it was hard work and not for the faint of heart.  You could
occasionally get away with the `$m{$LoL,$b}' notation borrowed from
*awk* in which the keys are actually more like a single concatenated
string `"$LoL$b"', but traversal and sorting were difficult.  More
desperate programmers even hacked Perl's internal symbol table directly,
a strategy that proved hard to develop and maintain--to put it mildly.

The 5.0 release of Perl let us have complex data structures.  You may
now write something like this and all of a sudden, you'd have a array
with three dimensions!

     for $x (1 .. 10) {
     	for $y (1 .. 10) {
     	    for $z (1 .. 10) {
     		$LoL[$x][$y][$z] =
     		    $x ** $y + $z;
     	    }
     	}
     }

Alas, however simple this may appear, underneath it's a much more
elaborate construct than meets the eye!

How do you print it out?  Why can't you say just `print @LoL'?  How do
you sort it?  How can you pass it to a function or get one of these back
from a function?  Is is an object?  Can you save it to disk to read back
later?  How do you access whole rows or columns of that matrix?  Do all
the values have to be numeric?

As you see, it's quite easy to become confused.  While some small
portion of the blame for this can be attributed to the reference-based
implementation, it's really more due to a lack of existing documentation
with examples designed for the beginner.

This document is meant to be a detailed but understandable treatment of
the many different sorts of data structures you might want to develop.
It should also serve as a cookbook of examples.  That way, when you need
to create one of these complex data structures, you can just pinch,
pilfer, or purloin a drop-in example from here.

Let's look at each of these possible constructs in detail.  There are
separate sections on each of the following:

   * arrays of arrays
   * hashes of arrays
   * arrays of hashes
   * hashes of hashes
   * more elaborate constructs

But for now, let's look at some of the general issues common to all of
these types of data structures.


REFERENCES
==========

The most important thing to understand about all data structures in Perl
-- including multidimensional arrays--is that even though they might
appear otherwise, Perl `@ARRAY's and `%HASH'es are all internally
one-dimensional.  They can hold only scalar values (meaning a string,
number, or a reference).  They cannot directly contain other arrays or
hashes, but instead contain *references* to other arrays or hashes.

You can't use a reference to a array or hash in quite the same way that
you would a real array or hash.  For C or C++ programmers unused to
distinguishing between arrays and pointers to the same, this can be
confusing.  If so, just think of it as the difference between a
structure and a pointer to a structure.

You can (and should) read more about references in the perlref(1) man
page.  Briefly, references are rather like pointers that know what they
point to.  (Objects are also a kind of reference, but we won't be
needing them right away--if ever.)  This means that when you have
something which looks to you like an access to a two-or-more-dimensional
array and/or hash, what's really going on is that the base type is
merely a one-dimensional entity that contains references to the next
level.  It's just that you can use it as though it were a
two-dimensional one.  This is actually the way almost all C
multidimensional arrays work as well.

     $list[7][12]			# array of arrays
     $list[7]{string}			# array of hashes
     $hash{string}[7]			# hash of arrays
     $hash{string}{'another string'}	# hash of hashes

Now, because the top level contains only references, if you try to print
out your array in with a simple print() function, you'll get something
that doesn't look very nice, like this:

     @LoL = ( [2, 3], [4, 5, 7], [0] );
     print $LoL[1][2];
       7
     print @LoL;
       ARRAY(0x83c38)ARRAY(0x8b194)ARRAY(0x8b1d0)

That's because Perl doesn't (ever) implicitly dereference your
variables.  If you want to get at the thing a reference is referring to,
then you have to do this yourself using either prefix typing indicators,
like `${$blah}', `@{$blah}', `@{$blah[$i]}', or else postfix pointer
arrows, like `$a->[3]', `$h->{fred}', or even `$ob->method()->[3]'.


COMMON MISTAKES
===============

The two most common mistakes made in constructing something like an
array of arrays is either accidentally counting the number of elements
or else taking a reference to the same memory location repeatedly.
Here's the case where you just get the count instead of a nested array:

     for $i (1..10) {
     	@list = somefunc($i);
     	$LoL[$i] = @list;	# WRONG!
     }

That's just the simple case of assigning a list to a scalar and getting
its element count.  If that's what you really and truly want, then you
might do well to consider being a tad more explicit about it, like this:

     for $i (1..10) {
     	@list = somefunc($i);
     	$counts[$i] = scalar @list;
     }

Here's the case of taking a reference to the same memory location again
and again:

     for $i (1..10) {
     	@list = somefunc($i);
     	$LoL[$i] = \@list;	# WRONG!
     }

So, what's the big problem with that?  It looks right, doesn't it?
After all, I just told you that you need an array of references, so by
golly, you've made me one!

Unfortunately, while this is true, it's still broken.  All the
references in @LoL refer to the *very same place*, and they will
therefore all hold whatever was last in @list!  It's similar to the
problem demonstrated in the following C program:

     #include <pwd.h>
     main() {
     	struct passwd *getpwnam(), *rp, *dp;
     	rp = getpwnam("root");
     	dp = getpwnam("daemon");

     printf("daemon name is %s\nroot name is %s\n",
     	dp->pw_name, rp->pw_name);
         }

Which will print

     daemon name is daemon
     root name is daemon

The problem is that both `rp' and `dp' are pointers to the same location
in memory!  In C, you'd have to remember to malloc() yourself some new
memory.  In Perl, you'll want to use the array constructor `[]' or the
hash constructor `{}' instead.  Here's the right way to do the preceding
broken code fragments:

     for $i (1..10) {
     	@list = somefunc($i);
     	$LoL[$i] = [ @list ];
     }

The square brackets make a reference to a new array with a copy of
what's in @list at the time of the assignment.  This is what you want.

Note that this will produce something similar, but it's much harder to
read:

     for $i (1..10) {
     	@list = 0 .. $i;
     	@{$LoL[$i]} = @list;
     }

Is it the same?  Well, maybe so--and maybe not.  The subtle difference
is that when you assign something in square brackets, you know for sure
it's always a brand new reference with a new copy of the data.
Something else could be going on in this new case with the
`@{$LoL[$i]}}' dereference on the left-hand-side of the assignment.  It
all depends on whether `$LoL[$i]' had been undefined to start with, or
whether it already contained a reference.  If you had already populated
@LoL with references, as in

     $LoL[3] = \@another_list;

Then the assignment with the indirection on the left-hand-side would use
the existing reference that was already there:

     @{$LoL[3]} = @list;

Of course, this *would* have the "interesting" effect of clobbering
 @another_list.  (Have you ever noticed how when a programmer says
something is "interesting", that rather than meaning "intriguing",
they're disturbingly more apt to mean that it's "annoying", "difficult",
or both?  :-)

So just remember always to use the array or hash constructors with `[]'
or `{}', and you'll be fine, although it's not always optimally
efficient.

Surprisingly, the following dangerous-looking construct will actually
work out fine:

     for $i (1..10) {
         my @list = somefunc($i);
         $LoL[$i] = \@list;
     }

That's because my() is more of a run-time statement than it is a
compile-time declaration *per se*.  This means that the my() variable is
remade afresh each time through the loop.  So even though it *looks* as
though you stored the same variable reference each time, you actually
did not!  This is a subtle distinction that can produce more efficient
code at the risk of misleading all but the most experienced of
programmers.  So I usually advise against teaching it to beginners.  In
fact, except for passing arguments to functions, I seldom like to see
the gimme-a-reference operator (backslash) used much at all in code.
Instead, I advise beginners that they (and most of the rest of us)
should try to use the much more easily understood constructors `[]' and
`{}' instead of relying upon lexical (or dynamic) scoping and hidden
reference-counting to do the right thing behind the scenes.

In summary:

     $LoL[$i] = [ @list ];	# usually best
     $LoL[$i] = \@list;		# perilous; just how my() was that list?
     @{ $LoL[$i] } = @list;	# way too tricky for most programmers


CAVEAT ON PRECEDENCE
====================

Speaking of things like `@{$LoL[$i]}', the following are actually the
same thing:

     $listref->[2][2]	# clear
     $$listref[2][2]	# confusing

That's because Perl's precedence rules on its five prefix dereferencers
(which look like someone swearing: `$ @ * % &') make them bind more
tightly than the postfix subscripting brackets or braces!  This will no
doubt come as a great shock to the C or C++ programmer, who is quite
accustomed to using `*a[i]' to mean what's pointed to by the *i'th*
element of a.  That is, they first take the subscript, and only then
dereference the thing at that subscript.  That's fine in C, but this
isn't C.

The seemingly equivalent construct in Perl, `$$listref[$i]' first does
the deref of `$listref', making it take $listref as a reference to an
array, and then dereference that, and finally tell you the *i'th* value
of the array pointed to by $LoL. If you wanted the C notion, you'd have
to write `${$LoL[$i]}' to force the `$LoL[$i]' to get evaluated first
before the leading `$' dereferencer.


WHY YOU SHOULD ALWAYS `use strict'
==================================

If this is starting to sound scarier than it's worth, relax.  Perl has
some features to help you avoid its most common pitfalls.  The best way
to avoid getting confused is to start every program like this:

     #!/usr/bin/perl -w
     use strict;

This way, you'll be forced to declare all your variables with my() and
also disallow accidental "symbolic dereferencing".  Therefore if you'd
done this:

     my $listref = [
     	[ "fred", "barney", "pebbles", "bambam", "dino", ],
     	[ "homer", "bart", "marge", "maggie", ],
     	[ "george", "jane", "elroy", "judy", ],
     ];

     print $listref[2][2];

The compiler would immediately flag that as an error *at compile time*,
because you were accidentally accessing `@listref', an undeclared
variable, and it would thereby remind you to write instead:

     print $listref->[2][2]


DEBUGGING
=========

Before version 5.002, the standard Perl debugger didn't do a very nice
job of printing out complex data structures.  With 5.002 or above, the
debugger includes several new features, including command line editing
as well as the x command to dump out complex data structures.  For
example, given the assignment to $LoL above, here's the debugger output:

     DB<1> X $LoL
     $LoL = ARRAY(0x13b5a0)
        0  ARRAY(0x1f0a24)
     	  0  'fred'
     	  1  'barney'
     	  2  'pebbles'
     	  3  'bambam'
     	  4  'dino'
        1  ARRAY(0x13b558)
     	  0  'homer'
     	  1  'bart'
     	  2  'marge'
     	  3  'maggie'
        2  ARRAY(0x13b540)
     	  0  'george'
     	  1  'jane'
     	  2  'elroy'
     	  3  'judy'

There's also a lowercase x command which is nearly the same.


CODE EXAMPLES
=============

Presented with little comment (these will get their own manpages
someday) here are short code examples illustrating access of various
types of data structures.


LISTS OF LISTS
==============


Declaration of a LIST OF LISTS
------------------------------

     @LoL = (
            [ "fred", "barney" ],
            [ "george", "jane", "elroy" ],
            [ "homer", "marge", "bart" ],
          );


Generation of a LIST OF LISTS
-----------------------------

     # reading from file
     while ( <> ) {
         push @LoL, [ split ];
     }

     # calling a function
     for $i ( 1 .. 10 ) {
         $LoL[$i] = [ somefunc($i) ];
     }

     # using temp vars
     for $i ( 1 .. 10 ) {
         @tmp = somefunc($i);
         $LoL[$i] = [ @tmp ];
     }

     # add to an existing row
     push @{ $LoL[0] }, "wilma", "betty";


Access and Printing of a LIST OF LISTS
--------------------------------------

     # one element
     $LoL[0][0] = "Fred";

     # another element
     $LoL[1][1] =~ s/(\w)/\u$1/;

     # print the whole thing with refs
     for $aref ( @LoL ) {
         print "\t [ @$aref ],\n";
     }

     # print the whole thing with indices
     for $i ( 0 .. $#LoL ) {
         print "\t [ @{$LoL[$i]} ],\n";
     }

     # print the whole thing one at a time
     for $i ( 0 .. $#LoL ) {
         for $j ( 0 .. $#{ $LoL[$i] } ) {
             print "elt $i $j is $LoL[$i][$j]\n";
         }
     }


HASHES OF LISTS
===============


Declaration of a HASH OF LISTS
------------------------------

     %HoL = (
            flintstones        => [ "fred", "barney" ],
            jetsons            => [ "george", "jane", "elroy" ],
            simpsons           => [ "homer", "marge", "bart" ],
          );


Generation of a HASH OF LISTS
-----------------------------

     # reading from file
     # flintstones: fred barney wilma dino
     while ( <> ) {
         next unless s/^(.*?):\s*//;
         $HoL{$1} = [ split ];
     }

     # reading from file; more temps
     # flintstones: fred barney wilma dino
     while ( $line = <> ) {
         ($who, $rest) = split /:\s*/, $line, 2;
         @fields = split ' ', $rest;
         $HoL{$who} = [ @fields ];
     }

     # calling a function that returns a list
     for $group ( "simpsons", "jetsons", "flintstones" ) {
         $HoL{$group} = [ get_family($group) ];
     }

     # likewise, but using temps
     for $group ( "simpsons", "jetsons", "flintstones" ) {
         @members = get_family($group);
         $HoL{$group} = [ @members ];
     }

     # append new members to an existing family
     push @{ $HoL{"flintstones"} }, "wilma", "betty";


Access and Printing of a HASH OF LISTS
--------------------------------------

     # one element
     $HoL{flintstones}[0] = "Fred";

     # another element
     $HoL{simpsons}[1] =~ s/(\w)/\u$1/;

     # print the whole thing
     foreach $family ( keys %HoL ) {
         print "$family: @{ $HoL{$family} }\n"
     }

     # print the whole thing with indices
     foreach $family ( keys %HoL ) {
         print "family: ";
         foreach $i ( 0 .. $#{ $HoL{$family} } ) {
             print " $i = $HoL{$family}[$i]";
         }
         print "\n";
     }

     # print the whole thing sorted by number of members
     foreach $family ( sort { @{$HoL{$b}} <=> @{$HoL{$a}} } keys %HoL ) {
         print "$family: @{ $HoL{$family} }\n"
     }

     # print the whole thing sorted by number of members and name
     foreach $family ( sort {
     			    @{$HoL{$b}} <=> @{$HoL{$a}}
     					||
     				    $a cmp $b
     	    } keys %HoL )
     {
         print "$family: ", join(", ", sort @{ $HoL{$family}), "\n";
     }


LISTS OF HASHES
===============


Declaration of a LIST OF HASHES
-------------------------------

     @LoH = (
            {
                Lead     => "fred",
                Friend   => "barney",
            },
            {
                Lead     => "george",
                Wife     => "jane",
                Son      => "elroy",
            },
            {
                Lead     => "homer",
                Wife     => "marge",
                Son      => "bart",
            }
      );


Generation of a LIST OF HASHES
------------------------------

     # reading from file
     # format: LEAD=fred FRIEND=barney
     while ( <> ) {
         $rec = {};
         for $field ( split ) {
             ($key, $value) = split /=/, $field;
             $rec->{$key} = $value;
         }
         push @LoH, $rec;
     }

     # reading from file
     # format: LEAD=fred FRIEND=barney
     # no temp
     while ( <> ) {
         push @LoH, { split /[\s+=]/ };
     }

     # calling a function  that returns a key,value list, like
     # "lead","fred","daughter","pebbles"
     while ( %fields = getnextpairset() ) {
         push @LoH, { %fields };
     }

     # likewise, but using no temp vars
     while (<>) {
         push @LoH, { parsepairs($_) };
     }

     # add key/value to an element
     $LoH[0]{pet} = "dino";
     $LoH[2]{pet} = "santa's little helper";


Access and Printing of a LIST OF HASHES
---------------------------------------

     # one element
     $LoH[0]{lead} = "fred";

     # another element
     $LoH[1]{lead} =~ s/(\w)/\u$1/;

     # print the whole thing with refs
     for $href ( @LoH ) {
         print "{ ";
         for $role ( keys %$href ) {
             print "$role=$href->{$role} ";
         }
         print "}\n";
     }

     # print the whole thing with indices
     for $i ( 0 .. $#LoH ) {
         print "$i is { ";
         for $role ( keys %{ $LoH[$i] } ) {
             print "$role=$LoH[$i]{$role} ";
         }
         print "}\n";
     }

     # print the whole thing one at a time
     for $i ( 0 .. $#LoH ) {
         for $role ( keys %{ $LoH[$i] } ) {
             print "elt $i $role is $LoH[$i]{$role}\n";
         }
     }


HASHES OF HASHES
================


Declaration of a HASH OF HASHES
-------------------------------

     %HoH = (
            flintstones => {
     		lead      => "fred",
     		pal       => "barney",
            },
            jetsons     => {
     		lead      => "george",
     		wife      => "jane",
     		"his boy" => "elroy",
            },
            simpsons    => {
     		lead      => "homer",
     		wife      => "marge",
     		kid       => "bart",
     	},
     );


Generation of a HASH OF HASHES
------------------------------

     # reading from file
     # flintstones: lead=fred pal=barney wife=wilma pet=dino
     while ( <> ) {
         next unless s/^(.*?):\s*//;
         $who = $1;
         for $field ( split ) {
             ($key, $value) = split /=/, $field;
             $HoH{$who}{$key} = $value;
         }

     # reading from file; more temps
     while ( <> ) {
         next unless s/^(.*?):\s*//;
         $who = $1;
         $rec = {};
         $HoH{$who} = $rec;
         for $field ( split ) {
             ($key, $value) = split /=/, $field;
             $rec->{$key} = $value;
         }
     }

     # calling a function  that returns a key,value hash
     for $group ( "simpsons", "jetsons", "flintstones" ) {
         $HoH{$group} = { get_family($group) };
     }

     # likewise, but using temps
     for $group ( "simpsons", "jetsons", "flintstones" ) {
         %members = get_family($group);
         $HoH{$group} = { %members };
     }

     # append new members to an existing family
     %new_folks = (
         wife => "wilma",
         pet  => "dino";
     );

     for $what (keys %new_folks) {
         $HoH{flintstones}{$what} = $new_folks{$what};
     }


Access and Printing of a HASH OF HASHES
---------------------------------------

     # one element
     $HoH{flintstones}{wife} = "wilma";

     # another element
     $HoH{simpsons}{lead} =~ s/(\w)/\u$1/;

     # print the whole thing
     foreach $family ( keys %HoH ) {
         print "$family: { ";
         for $role ( keys %{ $HoH{$family} } ) {
             print "$role=$HoH{$family}{$role} ";
         }
         print "}\n";
     }

     # print the whole thing  somewhat sorted
     foreach $family ( sort keys %HoH ) {
         print "$family: { ";
         for $role ( sort keys %{ $HoH{$family} } ) {
             print "$role=$HoH{$family}{$role} ";
         }
         print "}\n";
     }

     # print the whole thing sorted by number of members
     foreach $family ( sort { keys %{$HoH{$b}} <=> keys %{$HoH{$a}} } keys %HoH ) {
         print "$family: { ";
         for $role ( sort keys %{ $HoH{$family} } ) {
             print "$role=$HoH{$family}{$role} ";
         }
         print "}\n";
     }

     # establish a sort order (rank) for each role
     $i = 0;
     for ( qw(lead wife son daughter pal pet) ) { $rank{$_} = ++$i }

     # now print the whole thing sorted by number of members
     foreach $family ( sort { keys %{ $HoH{$b} } <=> keys %{ $HoH{$a} } } keys %HoH ) {
         print "$family: { ";
         # and print these according to rank order
         for $role ( sort { $rank{$a} <=> $rank{$b} }  keys %{ $HoH{$family} } ) {
             print "$role=$HoH{$family}{$role} ";
         }
         print "}\n";
     }


MORE ELABORATE RECORDS
======================


Declaration of MORE ELABORATE RECORDS
-------------------------------------

Here's a sample showing how to create and use a record whose fields are
of many different sorts:

     $rec = {
     	 TEXT      => $string,
     	 SEQUENCE  => [ @old_values ],
     	 LOOKUP    => { %some_table },
     	 THATCODE  => \&some_function,
     	 THISCODE  => sub { $_[0] ** $_[1] },
     	 HANDLE    => \*STDOUT,
     };

     print $rec->{TEXT};

     print $rec->{LIST}[0];
     $last = pop @ { $rec->{SEQUENCE} };

     print $rec->{LOOKUP}{"key"};
     ($first_k, $first_v) = each %{ $rec->{LOOKUP} };

     $answer = $rec->{THATCODE}->($arg);
     $answer = $rec->{THISCODE}->($arg1, $arg2);

     # careful of extra block braces on fh ref
     print { $rec->{HANDLE} } "a string\n";

     use FileHandle;
     $rec->{HANDLE}->autoflush(1);
     $rec->{HANDLE}->print(" a string\n");


Declaration of a HASH OF COMPLEX RECORDS
----------------------------------------

     %TV = (
        flintstones => {
            series   => "flintstones",
            nights   => [ qw(monday thursday friday) ],
            members  => [
                { name => "fred",    role => "lead", age  => 36, },
                { name => "wilma",   role => "wife", age  => 31, },
                { name => "pebbles", role => "kid",  age  =>  4, },
            ],
        },

     jetsons     => {
         series   => "jetsons",
         nights   => [ qw(wednesday saturday) ],
         members  => [
             { name => "george",  role => "lead", age  => 41, },
             { name => "jane",    role => "wife", age  => 39, },
             { name => "elroy",   role => "kid",  age  =>  9, },
         ],
      },

     simpsons    => {
         series   => "simpsons",
         nights   => [ qw(monday) ],
         members  => [
             { name => "homer", role => "lead", age  => 34, },
             { name => "marge", role => "wife", age => 37, },
             { name => "bart",  role => "kid",  age  =>  11, },
         ],
      },
           );


Generation of a HASH OF COMPLEX RECORDS
---------------------------------------

     # reading from file
     # this is most easily done by having the file itself be
     # in the raw data format as shown above.  perl is happy
     # to parse complex data structures if declared as data, so
     # sometimes it's easiest to do that

     # here's a piece by piece build up
     $rec = {};
     $rec->{series} = "flintstones";
     $rec->{nights} = [ find_days() ];

     @members = ();
     # assume this file in field=value syntax
     while (<>) {
         %fields = split /[\s=]+/;
         push @members, { %fields };
     }
     $rec->{members} = [ @members ];

     # now remember the whole thing
     $TV{ $rec->{series} } = $rec;

     ###########################################################
     # now, you might want to make interesting extra fields that
     # include pointers back into the same data structure so if
     # change one piece, it changes everywhere, like for examples
     # if you wanted a {kids} field that was an array reference
     # to a list of the kids' records without having duplicate
     # records and thus update problems.
     ###########################################################
     foreach $family (keys %TV) {
         $rec = $TV{$family}; # temp pointer
         @kids = ();
         for $person ( @{ $rec->{members} } ) {
             if ($person->{role} =~ /kid|son|daughter/) {
                 push @kids, $person;
             }
         }
         # REMEMBER: $rec and $TV{$family} point to same data!!
         $rec->{kids} = [ @kids ];
     }

     # you copied the list, but the list itself contains pointers
     # to uncopied objects. this means that if you make bart get
     # older via

     $TV{simpsons}{kids}[0]{age}++;

     # then this would also change in
     print $TV{simpsons}{members}[2]{age};

     # because $TV{simpsons}{kids}[0] and $TV{simpsons}{members}[2]
     # both point to the same underlying anonymous hash table

     # print the whole thing
     foreach $family ( keys %TV ) {
         print "the $family";
         print " is on during @{ $TV{$family}{nights} }\n";
         print "its members are:\n";
         for $who ( @{ $TV{$family}{members} } ) {
             print " $who->{name} ($who->{role}), age $who->{age}\n";
         }
         print "it turns out that $TV{$family}{lead} has ";
         print scalar ( @{ $TV{$family}{kids} } ), " kids named ";
         print join (", ", map { $_->{name} } @{ $TV{$family}{kids} } );
         print "\n";
     }


Database Ties
=============

You cannot easily tie a multilevel data structure (such as a hash of
hashes) to a dbm file.  The first problem is that all but GDBM and
Berkeley DB have size limitations, but beyond that, you also have
problems with how references are to be represented on disk.  One
experimental module that does partially attempt to address this need is
the MLDBM module.  Check your nearest CPAN site as described in *Note
Perlmodlib: perlmodlib, for source code to MLDBM.


SEE ALSO
========

perlref(1), perllol(1), perldata(1), perlobj(1)


AUTHOR
======

Tom Christiansen <`tchrist@perl.com'>

Last update: Wed Oct 23 04:57:50 MET DST 1996



