Info file: pm.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `bigpm.texi'
using `texinfmt.el' version 2.32 of 19 November 1993.





File: pm.info, Node: Data/Flow, Next: Data/Locations, Prev: Data/Dumper, Up: Module List

Perl extension for simple-minded recipe-controlled build of data.
*****************************************************************



NAME
====

Data::Flow - Perl extension for simple-minded recipe-controlled build of
data.


SYNOPSIS
========

     use Data::Flow;
     $recipes = { path  => { default => './MANIFEST'},
     	       contents => { prerequisites => ['path', 'x'] ,
     			     process => 
     			     sub {
     			       my $data = shift; 
     			       $data->{ shift() } = `cat $data->get('path')`
     				 x $data->get('x');
     			     }
     			   },
     	     };

     $request = new Data::Flow $recipes;
     $request->set( x => 1);
     print $request->get('contents');

     tie %request, Data::Flow, $recipes;
     $request{x} = 1;
     print $request{contents};


DESCRIPTION
===========

The module Data::Flow provides its services via objects. The objects may
be obtained by the usual

     $request = new Data::Flow $recipes;

paradigm. The argument $recipes is a hash reference, which provides the
rules for request processing. The objects support two methods, set() and
get(). The first one is used to provide input data for processing, the
second one to obtain the output.

The unit of requested information is a *field*. The method set() takes a
pair `field => value', the method get() takes one argument: the `field'.

Every object is created without any fields filled, but it knows how to
*construct* fields basing on other fields or some global into. This
knowledge is provided in the argument $recipe of the new()
function. This is a reference to a hash, keyed by fields. The values of
this hash are hash references themselves, which describe how to acquire
the *field* which is the corresponding key of the initial hash.

The internal hashes may have the following keys:

default
     describes the default value for the key, if none is provided by
     set(). The value becomes the value of the field of the object. No
     additional processing is performed. Example:

          default => $Config{installdir}

`prerequisites'
     gives the fields which are needed for the construction of the given
     field. The corresponding value is an array references. The array
     contains the *required* fields.

     If `defaults' did not satisfy the request for a field, but
     `$recipe->{field}{prerequisites}' exists, the *required* fields are
     build before any further processing is done. Example:

          prerequisites => [ qw(prefix arch) ]

`process'
     contains the rule to build the field. The value is a reference to a
     subroutine taking 2 arguments: the object $request, and the name of
     the required field. It is up to the subroutine to actually fill the
     corresponding field of $data, an error condition is raised if it
     did not. Example:

          process => sub { my $data = shift;
          		   $data->set( time => localtime(time) ) }

output
     the corresponing value has the same meaning as for `process', but the
     return value of the subroutine is used as the value of the
     *field*. Example:

          output => sub { localtime(time) }

`filter'
     contains the rule to build the field basing on other fields. The value
     is a reference to an array. The first element of the array is a
     reference to a subroutine, the rest contains names of the fields. When
     the subroutine is called, the arguments are the values of fields of
     the object $request which appear in the array (in the same order). The
     return value of the subroutine is used as the value of the
     *field*. Example:

          filter => [ sub { shift + shift },
          	      'first_half', 'second_half' ]

     Note that the mentioned field will be automatically marked as
     prerequisites.

`class_filter'
     is similar to `filter', but the first argument is the name of the
     method to call, second one is the name of the package to use for
     the method invocation. The rest contains names of field to provide
     as method arguments. Example:

          class_filter => [ 'new', 'FileHandle', 'filename' ]

`method_filter'
     is similar to `class_filter', but the second argument is the name
     of the field which is used to call the method upon. Example:

          method_filter => [ 'show', 'widget_name', 'current_display' ]


Tied interface
--------------

The access to the same functionality is available via tied hash
interface.


AUTHOR
======

Ilya Zakharevich, ilya@math.ohio-state.edu


SEE ALSO
========

perl(1), make(1).




File: pm.info, Node: Data/Locations, Next: Data/Locations/Shell, Prev: Data/Flow, Up: Module List

recursive placeholders in the data you generate
***********************************************



NAME
====

Data::Locations - recursive placeholders in the data you generate

"Locations" free you from the need to GENERATE data in the same order in
which it will be USED later.

They allow you to define insertion points in the middle of your data
which you can fill in later, at any time you want!

For instance you do not need to write output files in rigidly sequential
order anymore using this module.

Instead, write the data to locations in the order which is the most
appropriate and natural for you!

When you're finished, write your data to a file or process it otherwise,
purely in memory (faster!).

Most important: You can nest these placeholders in any way you want!

Potential infinite recursions are detected automatically and refused.

This means that you can GENERATE data ONLY ONCE in your program and USE
it MANY TIMES at different places, while the data itself is stored in
memory only once.

Maybe a picture will help to better understand this concept:

Think of "locations" as folders (or drawers) containing papers in a
sequential order, most of which contain printable text or data, while
some may contain the name of another folder (or drawer).

When dumping a location to a file, the papers contained in it are
printed one after another in the order they were originally stored.
When a paper containing the name of another location is encountered,
however, the contents of that location are processed before continuing
to print the remaining papers of the current location. And so forth, in
a recursive descent.

Note that you are not confined to dumping locations to a file, you can
also process them directly in memory (you can read back the contents of
any given location item after item or all at once)!

Note further that you may create as many locations with as many embedded
locations, as many nesting levels deep as your available memory will
permit.

Not even Clodsahamp's multidimensionally expanded tree house (see Alan
Dean Foster's fantasy novel "Spellsinger" for more details!)  can
compare with this! `:-)'

See `Tie::Handle(3)' in this node and the example given at the end of
this manpage for how to tie data locations to file handles in order to
further simplify writing data to and reading data from locations.

See `Data::Locations::Shell(3)' in this node for even more ease of use:
Use only ONE object reference instead of TWO (one for the location
itself and one for the file handle the location has been tied to) which
you can use as a file handle AND as a "Data::Locations" object
reference, at the same time!

Note that this module is fully compatible with "Data::Locations", i.e.,
if you change all occurrences of "Data::Locations" in your program to
"Data::Locations::Shell", your program should work exactly as before -
with the added benefit that you don't need to "tie()" your locations to
a file handle explicitly anymore in order to be able to use "`print
$location @items;'" and "`$item = <$location>;'", for instance.


SYNOPSIS
========

   * `use Data::Locations;'

   * `$location = Data::Locations->new();'

   * `$location = Data::Locations->new($filename);'

   * `$sublocation = $location->new();'

   * `$sublocation = $location->new($filename);'

   * `$location->filename($filename);'

   * `$filename = $location->filename();'

   * `$location->print(@items);'

   * `$location->println(@items);'

   * `$location->printf($format,@items);'

   * `$ok = Data::Locations->dump();'

   * `$ok = $location->dump();'

   * `$ok = $location->dump($filename);'

   * `$item = $location->read();'

   * `@list = $location->read();'

   * `Data::Locations->reset();'

   * `$location->reset();'

   * `Data::Locations->traverse(\&callback_function);'

   * `$location->traverse(\&callback_function);'

   * `Data::Locations->delete();'

   * `$location->delete();'

   * `$location->tie('FILEHANDLE');'

   * `$location->tie($filehandle);'


TROUBLE-SHOOTING
================

Note that the warning messages which this module might want to issue
will only appear if you use the -w switch!

Use this switch either on the command line:

     % perl -w example.pl

or append it to the "shell-bang" line at the top of (i.e., the very
first line of) your script:

     #!/usr/local/bin/perl -w

Remember: If something strange has gone wrong with your program and
you're not sure where you should look for help, try the -w switch
first. It will often point out exactly where the trouble is.

Whenever you get mysterious behavior, try the -w switch!!! Whenever you
don't get mysterious behavior, try using -w anyway.


DESCRIPTION
===========

   * `use Data::Locations;'

     Enables the use of locations in your program.

   * `$location = Data::Locations->new();'

     The CLASS METHOD "new()" creates a new top-level location
     ("top-level" means that it isn't embedded in any other location).

     Note that CLASS METHODS are invoked using the NAME of their class,
     i.e., "Data::Locations" in this case, in contrast to OBJECT METHODS
     which are invoked using an object reference such as returned by the
     class's object constructor method (which "new()" happens to be).

     Any location that you intend to dump to a file later on in your
     program needs to have a filename associated with it, which you can
     either specify using one of the variants of the "new()" method
     where you supply a filename (as the one shown immediately below),
     or by setting this filename using the method "filename()" (see
     further below), or by specifying an explicit filename when invoking
     the "dump()" method itself (see also further below) on a particular
     location.

     Otherwise an error will occur when you try to dump the location (in
     fact, a warning message is printed to the screen (if the -w switch
     is set) and the location will simply not be dumped to a file, but
     program execution continues).

   * `$location = Data::Locations->new($filename);'

     This variant of the CLASS METHOD "new()" creates a new top-level
     location ("top-level" means that it isn't embedded in any other
     location) and assigns a default filename to it.

     Note that this filename is simply passed through to the Perl
     "open()" function later on (which is called internally when you
     dump your locations to a file), which means that any legal Perl
     filename may be used such as ">-" (for writing to STDOUT) and "|
     more", to give you just two of the more exotic examples!

     See the section on "open()" in `perlfunc(1)' in this node for more
     details!

   * `$sublocation = $location->new();'

     The OBJECT METHOD "new()" creates a new location which is embedded
     in the given location "$location" at the current position (defined
     by what has been printed to the embedding location till this
     moment).

     Such nested locations usually do not need a filename associated
     with them (because they will be dumped to the same file as the
     location in which they are embedded), unless you want to dump this
     location to a file of its own, additionally.

     In the latter case, use the variant of the "new()" method shown
     immediately below or the method "filename()" (see below) to set
     this filename, or call the method "dump()" (explained further
     below) with an appropriate filename argument.

   * `$sublocation = $location->new($filename);'

     This variant of the OBJECT METHOD "new()" creates a new location
     which is embedded in the given location "$location" at the current
     position (defined by what has been printed to the embedding
     location till this moment) and assigns a default filename to it.

     See the section on "open()" in `perlfunc(1)' in this node for more
     details about what filenames you may use (i.e., which filenames are
     legal)!

   * `$location->filename($filename);'

     This object method stores a filename along with the given location
     which will be used as the default filename when dumping that
     location.

     You may set the filename associated with any given location using
     this method any number of times.

     Note that you can use this very same method "filename()" in order
     to retrieve the default filename that has been stored along with a
     given location if you call it WITHOUT any parameters (see also
     immediately below).

   * `$filename = $location->filename();'

     When called without parameters, this object method returns the
     default filename that has previously been stored along with the
     given location, using either the method "new()" or this very same
     method, "filename()" (but with a filename passed to it as its
     (only) argument).

   * `$location->print(@items);'

     This object method prints the given arguments to the indicated
     location, i.e., appends the given items to the given location.

     IMPORTANT FEATURE:

     Note that you can EMBED any given location IN MORE THAN ONE
     surrounding location using this method!

     Simply use a statement similar to this one:

          $location->print($sublocation);

     This embeds location "$sublocation" in location "$location" at the
     current position (defined by what has been printed to location
     "$location" till this moment).

     This is especially useful if you are generating data once in your
     program which you need at several places in your output.

     This saves a lot of memory because only a reference of the embedded
     location is stored in every embedding location instead of all the
     data, which is stored in memory only once!

     Note that other references than "Data::Locations" object references
     are illegal, trying to "print" such a reference to a location will
     result in a warning message (if the -w switch is set) and the
     reference will simply be ignored.

     Note also that potential infinite recursions (which would occur
     when a given location contained itself, directly or indirectly!)
     are detected automatically and refused (with an appropriate error
     message and program abortion).

     Because of the necessity for this check, it is more efficient to
     embed locations using the object method "new()" (where possible)
     than with this mechanism, because embedding an empty new location
     is always possible without checking.

     REMEMBER that in order to minimize the number of "print()" method
     calls in your program (remember that lazyness is a programmer's
     virtue!) you can always use the "here-document" syntax:

          $location->print(<<"VERBATIM");
          Article: $article
            Price: $price
            Stock: $stock
          VERBATIM

     Remember also that the type of quotes (single/double) around the
     terminating string ("VERBATIM" in this example) determines wether
     variables inside the given text will be interpolated or not!

     See `perldata(1)' in this node for more details!

   * `$location->println(@items);'

     Same as the "print()" method above, except that a "newline"
     character ("`\n'") is appended at the end of the list of items to
     be printed (just a newline character is printed if no arguments (=
     an empty argument list) are given).

   * `$location->printf($format,@items);'

     This method is an analogue of the Perl (and C library) function
     "printf()".

     See the section on "printf()" in `perlfunc(1)' in this node and
     `printf(3)' in this node or `sprintf(3)' in this node on your
     system for an explanation of its possible uses.

   * `$ok = Data::Locations->dump();'

     This CLASS METHOD dumps all top-level locations to their default
     files (whose filenames must have been stored previously along with
     each location using the method "new()" or "filename()").

     Note that a warning message will be printed (if the -w switch is
     set) if any of the top-level locations happens to lack a default
     filename and that the respective location will simply not be dumped
     to a file!

     Did I mention that you should definitely consider using the -w
     switch?

     (Program execution continues in order to facilitate debugging of
     your program and to save a maximum of your data in memory which
     would be lost otherwise!)

     Moreover, should any problem arise with any of the top-level
     locations (for instance no filename given or filename invalid or
     unable to open the specified file), then this method returns
     "false" (0).

     The method returns "true" (1) only if ALL top-level locations have
     been written to their respective files successfully.

     Note also that a ">" is prepended to this default filename just
     before opening the file if the default filename does not begin with
     ">", "|" or "+" (leading white space is ignored).

     This does not change the filename which is stored along with the
     location, however.

     Finally, note that this method does not affect the contents of the
     locations that are being dumped.

     If you want to delete all your locations once they have been dumped
     to their respective files, call the class method "delete()"
     (explained further below) EXPLICITLY.

   * `$ok = $location->dump();'

     The OBJECT METHOD "dump()" dumps the given location to its default
     file (whose filename must have been stored previously along with
     this location using the method "new()" or "filename()").

     Note that a warning message will be printed (if the -w switch is
     set) if the location happens to lack a default filename and that
     the location will simply not be dumped to a file!

     (Program execution continues in order to facilitate debugging of
     your program and to save a maximum of your data in memory which
     would be lost otherwise!)

     Moreover, should any problem arise with the given location (for
     instance no filename given or filename invalid or unable to open
     the specified file), then this method returns "false" (0).

     The method returns "true" (1) if the given location has been
     successfully written to its respective file.

     Note also that a ">" is prepended to this default filename just
     before opening the file if the default filename does not begin with
     ">", "|" or "+" (leading white space is ignored).

     This does not change the filename which is stored along with the
     location, however.

     Finally, note that this method does not affect the contents of the
     location being dumped.

     If you want to delete this location once it has been dumped, call
     the object method "delete()" (explained further below) EXPLICITLY.

   * `$ok = $location->dump($filename);'

     This variant of the OBJECT METHOD "dump()" does the same as the
     variant described immediately above, except that it overrides the
     default filename stored along with the given location and uses the
     indicated filename instead.

     Note that the stored filename is just being overridden, BUT NOT
     CHANGED.

     I.e., if you call the method "dump()" again without a filename
     argument after calling it with an explicit filename argument once,
     the initial filename stored with the given location will be used,
     NOT the filename that you specified explicitly the last time when
     you called "dump()"!

     Should any problem arise with the given location (for instance if
     the given filename is invalid or empty or if Perl was unable to
     open the specified file), then this method returns "false" (0).

     The method returns "true" (1) if the given location has been
     successfully written to the specified file.

     (Note that if the given filename is empty or contains only white
     space, the method does NOT fall back to the filename previously
     stored along with the given location because doing so could
     overwrite valuable data!)

     Note also that a ">" is prepended to the given filename if it does
     not begin with ">", "|" or "+" (leading white space is ignored).

     Finally, note that this method does not affect the contents of the
     location being dumped.

     If you want to delete this location once it has been dumped, call
     the object method "delete()" (explained further below) EXPLICITLY.

   * `$item = $location->read();'

     In "scalar" context, the object method "read()" returns the next
     item of data from the given location.

     If you have never read from this particular location before,
     "read()" will automatically start at the beginning.

     Otherwise each call of "read()" will return successive items from
     the given location, thereby traversing the given location
     recursively through all embedded locations which it may or may not
     contain.

     To start reading at the beginning of the given location again,
     invoke the method "reset()" (see a little further below) on that
     location.

     The method returns "undef" when there is no more data to read.

     (Calling "read()" again thereafter will simply continue to return
     "undef")

     Note that you can continue to read data from the given location
     even after receiving "undef" from this method if you "print()" some
     more data to this location before attempting to "read()" from it
     again!

     Remember to use "reset()" if this is not what you want.

     Finally, note that you can read from two (or any number of)
     different locations at the same time, even if any of them is
     embedded (directly or indirectly) in any other of the locations you
     are currently reading from, without any interference!

     This is because the state information associated with each "read()"
     operation is stored along with the (given) location for which the
     "read()" method has been called, and NOT with the locations the
     "read()" visits during its recursive descent.

   * `@list = $location->read();'

     In "array" or "list" context, the object method "read()" returns
     the rest of the contents of the given location, starting from where
     the last "read()" left off, or from the beginning of the given
     location if you never read from this particular location before or
     if you called the method "reset()" (see below this method) for this
     location just before calling "read()".

     The method returns a single (possibly very long!) list containing
     all the items of data the given location and all of its embedded
     locations (if any) contain - in other words, the data contained in
     all these nested locations is returned in a "flattened" way.

     The method returns an empty list if the given location is empty or
     if the last "read()" read past the end of the data in the given
     location.

     Remember to use "reset()" whenever you want to make absolutely sure
     that you will be reading the whole contents of the given location!

     For an explanation of "scalar" versus "array" or "list" context,
     see the section on "Context" in `perldata(1)' in this node!

   * `Data::Locations->reset();'

     The CLASS METHOD "reset()" calls the OBJECT METHOD "reset()" (see
     immediately below) for EVERY location that exists - NOT just for
     the top-level locations!

   * `$location->reset();'

     The OBJECT METHOD "reset()" deletes the state information
     associated with the given location which is used by the "read()"
     method to determine the next item of data it should return.

     After using "reset()" on a given location, any subsequent "read()"
     on the same location will start reading at the beginning of that
     location.

     This method has no other (side) effects whatsoever.

     The method does nothing if there is no state information associated
     with the given location, i.e., if the location has never been
     accessed using the "read()" method or if "reset()" has already been
     called for it before.

   * `Data::Locations->traverse(\&callback_function);'

     The CLASS METHOD "traverse()" cycles through all top-level
     locations (in the order in which they were created) and calls the
     callback function you specified once for each of them.

     Expect one parameter handed over to your callback function which is
     the object reference to the location in question.

     Since callback functions can do a lot of unwanted things, use this
     method with great precaution!

   * `$location->traverse(\&callback_function);'

     The OBJECT METHOD "traverse()" performs a recursive descent on the
     given location just as the method "dump()" does internally, but
     instead of printing the items of data contained in the location to
     a file, this method calls the callback function you specified once
     for each item stored in the location.

     Expect one parameter handed over to your callback function which is
     the next chunk of data contained in the given location (or the
     locations embedded therein).

     Since callback functions can do a lot of unwanted things, use this
     method with great precaution!

     See at the end of this manpage for an example of how to use the two
     variants of the "traverse()" method!

     Using the object method "traverse()" is an alternate way of reading
     back the contents of a given location - besides using the (object)
     method "read()" - completely in memory (i.e., without writing the
     contents of the given location to a file and reading that file back
     in).

     Note that the method "traverse()" is completely independent from
     the method "read()" and that it has nothing to do with the state
     information associated with the "read()" method (which can be reset
     to point to the beginning of the location using the method
     "reset()").

     This means that you can "traverse()" and "read()" (and "reset()")
     the same location at the same time without any interference.

   * `Data::Locations->delete();'

     The CLASS METHOD "delete()" deletes all locations and their
     contents, which allows you to start over completely from scratch.

     Note that you do not need to call this method in order to
     initialize this class before using it; the "`use Data::Locations;'"
     statement is sufficient.

     BEWARE that any references to locations you might still be holding
     in your program become invalid by invoking this method!

     If you try to invoke a method using such an invalidated reference,
     an error message (with program abortion) similar to this one will
     occur:

     `Can't locate object method "method" via package "[Error: stale
     reference!]"'  `at program.pl line 65.'

   * `$location->delete();'

     The OBJECT METHOD "delete()" deletes the CONTENTS of the given
     location - the location CONTINUES TO EXIST and REMAINS EMBEDDED
     where it was!

     The associated filename stored along with the given location is
     also NOT AFFECTED by this.

     Note that a complete removal of the given location itself INCLUDING
     all references to this location which may still be embedded
     somewhere in other locations is unnecessary if, subsequently, you
     do not print anything to this location anymore!

     If the given location is a top-level location, you might want to
     set the associated filename to "/dev/null", though, using the
     method "filename()" (before or after deleting the location, this
     makes no difference).

     BEWARE that the locations that were previously embedded in the
     given (now deleted) location may not be contained in any other
     location anymore after invoking this method!

     If this happens, the affected "orphan" locations will be
     transformed into top-level locations automatically.

     Note however that you may have to define a default filename for
     these orphaned locations (if you haven't done so previously) before
     invoking "`Data::Locations->dump();'" in order to avoid data loss
     and the warning message that will occur otherwise!

     (The warning message will appear only if the -w switch is set,
     though)

   * `$location->tie('FILEHANDLE');'

     The object method "tie()" is inherited from the module
     "Tie::Handle" and allows you to tie a file handle to a location so
     that you can access the location as though it was a file, using
     Perl's built-in functions for handling files.

     Note that this feature depends on Perl version 5.004 (or higher)
     and that it cannot be used with previous versions of Perl (see the
     installation instructions in the file "INSTALL" in this
     distribution for how to disable this feature in such a case, since
     trying to use this feature with Perl versions prior to 5.004 will
     result in compilation errors).

     You can either specify the file handle to which your location
     should be tied by name (called a "symbolic" file handle) or by
     reference (as explained further below).

     A symbolic file handle can be given either as a literal string such
     as "STDOUT", "MYHANDLE" or "MYPACKAGE::MYHANDLE", or as a Perl
     variable containing that name.

     Note, by the way, that the type of quotes used to enclose these
     literal symbolic file handles does not matter, unless you are
     building the name of your file handle using interpolated variables
     such as in "`${prefix}${name}${suffix}'", for example, where double
     quotes are essential.

     After a file handle has been tied to a location, you can use all of
     Perl's built-in functions (except for "getc()", "read()" and
     "sysread()") for dealing with files on that location (via its
     associated file handle)!

     See `Tie::Handle(3)' in this node and `perlfunc(1)' in this node
     for more details, as well as the example given at the end of this
     manpage.

     Note however that calling the Perl (built-in) functions "open()"
     and "close()" on a tied file handle has no effect on the location
     which is tied to it!

     (But beware that they attempt to open and close the specified file,
     respectively, even though this is useless in this case!)

     Note also that you will get errors if you try to read from a tied
     file handle which you opened for output only using "open()", or
     vice-versa!

     Therefore it is best not to use the built-in Perl functions
     "open()" and "close()" on tied file handles at all.

     Instead, if you want to restart reading from the beginning of any
     given location, rather invoke the method "reset()" on it!

     Note further that always when you tie a file handle to a location
     the method "reset()" is called internally for that location.

     The same happens when you untie a file handle from its associated
     location, i.e., when you dissociate the bond between the two; in
     this case, "reset()" is called again in order to leave the location
     in a well-defined state.

   * `$location->tie($filehandle);'

     Use this variant of the object method "tie()" to specify the file
     handle to which the given location shall be tied BY REFERENCE, or
     if you have a scalar variable containing the name of the (symbolic)
     file handle to use.

     To supply a file handle object reference to this method, you must
     first call the object constructor method "new()" of either the
     "FileHandle" or the "IO::Handle" class (either one works):

          $filehandle = FileHandle->new();
          $filehandle = IO::Handle->new();

     (Don't forget to "use FileHandle;" or "use IO::Handle;" before
     that!)

     Then you can tie that file handle to one of the locations of this
     module.

     In order not to confuse the variables containing object references
     to your locations and the variables containing file handles, I
     suggest to use some naming convention to differentiate between the
     two.

     For example you could use "`$loc_<name>'" for location object
     references and "`$fh_<name>'" for file handles - the variables with
     the same "`<name>'" would then refer to exactly the same location.


EXAMPLE #1
==========

     #!/usr/local/bin/perl -w

     use strict;
     no strict "vars";

     use Data::Locations;

     $head = Data::Locations->new();  ##  E.g. for interface definitions
     $body = Data::Locations->new();  ##  E.g. for implementation

     $head->filename("example.h");
     $body->filename("example.c");

     $common = $head->new();    ##  Embed a new location in "$head"
     $body->print($common);     ##  Embed this same location in "$body"

     ##  Create some more locations...

     $copyright = Data::Locations->new("/dev/null");
     $includes  = Data::Locations->new("/dev/null");
     $prototype = Data::Locations->new("/dev/null");

     ##  ...and embed them in location "$common":

     $common->print($copyright,$includes,$prototype);

     ##  This is just to show you an alternate (though less efficient) way!
     ##  Normally you would use:
     ##      $copyright = $common->new();
     ##      $includes  = $common->new();
     ##      $prototype = $common->new();

     $head->println(";");  ##  The final ";" after a prototype
     $body->println();     ##  Just a newline after a function header

     $body->println("{");
     $body->println('    printf("Hello, world!\n");');
     $body->println("}");

     $includes->print("#include <");
     $library = $includes->new();     ##  Nesting even deeper still...
     $includes->println(">");

     $prototype->print("void hello(void)");

     $copyright->println("/*");
     $copyright->println("   Copyright (c) 1997 by Steffen Beyer.");
     $copyright->println("   All rights reserved.");
     $copyright->println("*/");

     $library->print("stdio.h");

     $copyright->filename("default.txt");

     $copyright->dump(">-");

     print "default filename = '", $copyright->filename(), "'\n";

     Data::Locations->dump();

     __END__

When executed, this example will print

     /*
        Copyright (c) 1997 by Steffen Beyer.
        All rights reserved.
     */
     default filename = 'default.txt'

to the screen and create the following two files:

     ::::::::::::::
     example.c
     ::::::::::::::
     /*
        Copyright (c) 1997 by Steffen Beyer.
        All rights reserved.
     */
     #include <stdio.h>
     void hello(void)
     {
         printf("Hello, world!\n");
     }

     ::::::::::::::
     example.h
     ::::::::::::::
     /*
        Copyright (c) 1997 by Steffen Beyer.
        All rights reserved.
     */
     #include <stdio.h>
     void hello(void);


EXAMPLE #2
==========

     #!/usr/local/bin/perl -w

     use strict;
     no strict "vars";

     use Data::Locations;

     $html = Data::Locations->new("example.html");

     $html->println("<HTML>");
     $head = $html->new();
     $body = $html->new();
     $html->println("</HTML>");

     $head->println("<HEAD>");
     $tohead = $head->new();
     $head->println("</HEAD>");

     $body->println("<BODY>");
     $tobody = $body->new();
     $body->println("</BODY>");

     $tohead->print("<TITLE>");
     $title = $tohead->new();
     $tohead->println("</TITLE>");

     $tohead->print('<META NAME="description" CONTENT="');
     $description = $tohead->new();
     $tohead->println('">');

     $tohead->print('<META NAME="keywords" CONTENT="');
     $keywords = $tohead->new();
     $tohead->println('">');

     $tobody->println("<CENTER>");

     $tobody->print("<H1>");
     $tobody->print($title);      ##  re-using this location!!
     $tobody->println("</H1>");

     $contents = $tobody->new();

     $tobody->println("</CENTER>");

     $title->print("Locations Example HTML-Page");

     $description->print("Example for generating HTML pages");
     $description->print(" using 'Locations'");

     $keywords->print("Locations, magic, recursive");

     $contents->println("This page was generated using the");
     $contents->println("<P>");
     $contents->println("&quot;<B>Locations</B>&quot;");
     $contents->println("<P>");
     $contents->println("module for Perl.");

     Data::Locations->dump();

     __END__

When executed, this example will produce the following file
("example.html"):

     <HTML>
     <HEAD>
     <TITLE>Locations Example HTML-Page</TITLE>
     <META NAME="description" CONTENT="Example for generating HTML pages using 'Locations'">
     <META NAME="keywords" CONTENT="Locations, magic, recursive">
     </HEAD>
     <BODY>
     <CENTER>
     <H1>Locations Example HTML-Page</H1>
     This page was generated using the
     <P>
     &quot;<B>Locations</B>&quot;
     <P>
     module for Perl.
     </CENTER>
     </BODY>
     </HTML>


EXAMPLE #3
==========

     #!/usr/local/bin/perl -w

     ##  WARNING: use the "-w" switch or this example won't work as described!

     package Non::Sense;  ##  works equally well with other packages than "main"!

     use strict;
     use vars qw($level0 $level1 $level2 $level3 $fh $fake);

     use FileHandle;
     use Data::Locations;

     $level0 = Data::Locations->new("level0.txt");  ##  create topmost location

     $level0->print(<<'VERBATIM');
     First line : $level0 : ->print() : (here-doc syntax)
     VERBATIM

     $level1 = $level0->new();    ##  create 1st nested location (1 level deep)

     $level0->print(<<'VERBATIM');
     Last line : $level0 : ->print() : (here-doc syntax)
     VERBATIM

     $level1->tie('STDOUT');      ##  tie this location to file handle STDOUT

     print 'First line : $level1 : print "..." : (default: STDOUT)'."\n";

     $level2 = $level1->new();    ##  create 2nd nested location (2 levels deep)

     $fh = FileHandle->new();     ##  create new file handle (IO::Handle also works)

     $level2->tie($fh);           ##  tie this location to file handle $fh

     select($fh);                 ##  select $fh as the default file handle

     print 'First line : $level2 : print "..." : (default: $fh)'."\n";

     print STDOUT 'Last line : $level1 : print STDOUT "..." : (default: $fh)'."\n";

     $level3 = $level2->new();    ##  create 3rd nested location (3 levels deep)

     select(STDOUT);              ##  re-enable STDOUT as the default file handle

     print $fh 'Last line : $level2 : print $fh "..." : (default: STDOUT)'."\n";

     $SIG{__WARN__} = sub         ##  trap all warnings
     {
         print STDERR "WARNING intercepted:\n", @_, "End Of Warning.\n";
     };

     ##  NOTE  that without this trap, warnings go to the system standard error
     ##        channel DIRECTLY, WITHOUT passing through the file handle STDERR!

     $level3->tie('STDERR');      ##  tie this location to file handle STDERR

     $fake = \$fh;

     $level3->print($fake);       ##  provoke a warning message (-w switch!)

     $level3->dump();             ##  provoke another warning message (-w switch!)

     untie *STDOUT;               ##  untie location $level1 and file handle STDOUT

     while (<STDERR>)             ##  read from location $level3
     {
         if (/^Data::Locations::/)
         {
             s/\n+//g;
             s/^.+\(\):\s*//;
             print "Warning: $_\n";
         }
     }

     while (<STDERR>) { print; }  ##  prints nothing because location wasn't reset

     ${tied *STDERR}->reset();    ##  alternative:  $level3->reset();

     while (<STDERR>) { print; }  ##  now prints contents of location $level3

     Data::Locations->dump();     ##  write output file "level0.txt"

     __END__

When running this example, the following text will be printed to the
screen (provided that you used the -w switch!):

     Warning: illegal reference 'REF' ignored at test.pl line 59
     Warning: no filename given at test.pl line 61
     WARNING intercepted:
     Data::Locations::print(): illegal reference 'REF' ignored at test.pl line 59
     End Of Warning.
     WARNING intercepted:
     Data::Locations::dump_location(): no filename given at test.pl line 61
     End Of Warning.

The example also produces an output file named "level0.txt" with the
following contents:

     First line : $level0 : ->print() : (here-doc syntax)
     First line : $level1 : print "..." : (default: STDOUT)
     First line : $level2 : print "..." : (default: $fh)
     WARNING intercepted:
     Data::Locations::print(): illegal reference 'REF' ignored at test.pl line 59
     End Of Warning.
     WARNING intercepted:
     Data::Locations::dump_location(): no filename given at test.pl line 61
     End Of Warning.
     Last line : $level2 : print $fh "..." : (default: STDOUT)
     Last line : $level1 : print STDOUT "..." : (default: $fh)
     Last line : $level0 : ->print() : (here-doc syntax)


EXAMPLE #4
==========

The following code fragment is an example of how you can use the
callback mechanism of this class to collect the contents of all
top-level locations in a string (which is printed to the screen in this
example):

     sub concat
     {
         $string .= $_[0];
     }

     sub list
     {
         $string .= $ruler;
         $string .= "\"" . $_[0]->filename() . "\":\n";
         $string .= $ruler;
         $_[0]->traverse(\&concat);
         $string .= "\n" unless ($string =~ /\n$/);
     }

     $ruler = '=' x 78 . "\n";

     $string = '';

     Data::Locations->traverse(\&list);

     $string .= $ruler;

     print $string;


SEE ALSO
========

Data::Locations::Shell(3), Tie::Handle(3), perl(1), perldata(1),
perlfunc(1), perlsub(1), perlmod(1), perlref(1), perlobj(1), perlbot(1),
perltoot(1), perltie(1), printf(3), sprintf(3).


VERSION
=======

This man page documents "Data::Locations" version 3.0.


AUTHOR
======

Steffen Beyer <sb@sdm.de>.


COPYRIGHT
=========

Copyright (c) 1997 by Steffen Beyer. All rights reserved.


LICENSE
=======

This package is free software; you can redistribute and/or modify it
under the same terms as Perl itself.




File: pm.info, Node: Data/Locations/Shell, Next: Data/ShowTable, Prev: Data/Locations, Up: Module List

adds additional features to Data::Locations
*******************************************



NAME
====

Data::Locations::Shell - adds additional features to Data::Locations

"use Data::Locations::Shell;" INSTEAD of "use Data::Locations;" and
replace all occurrences of "Data::Locations" in your program by
"Data::Locations::Shell".

The advantage of using "Data::Locations::Shell" instead of
"Data::Locations" is that you don't need TWO object references for the
SAME location anymore: One for the location itself and one for the file
handle the location has been tied to.

Instead, you have only ONE object reference you can do everything with:
Use it as a file handle in Perl's built-in functions for dealing with
files, AND use it to invoke methods from the "Data::Locations" class, at
the same time!

Note also that this module is fully compatible with "Data::Locations",
i.e., if you change all occurrences of "Data::Locations" in your program
to "Data::Locations::Shell", your program should work exactly as before
- with the added benefit that you don't need to "tie()" your locations
to a file handle explicitly anymore in order to be able to use "`print
$location @items;'" and "`$item = <$location>;'", for instance, as shown
below (for a more detailed description of these methods, see
`Data::Locations(3)' in this node).

Note however that "Data::Locations::Shell" needs Perl version 5.004 (or
higher) in order to run (whereas "Data::Locations" can do with previous
versions of Perl).


SYNOPSIS
========

   * `use Data::Locations::Shell;'

   * `$filehandle = Data::Locations::Shell->new();'

   * `$filehandle = Data::Locations::Shell->new($filename);'

   * `$subfilehandle = $filehandle->new();'

   * `$subfilehandle = $filehandle->new($filename);'

   * `$filehandle->filename($filename);'

   * `$filename = $filehandle->filename();'

   * `$filehandle->print(@items);'

   * `$filehandle->println(@items);'

   * `$filehandle->printf($format,@items);'

   * `print $filehandle @items;'

   * `printf $filehandle $format, @items;'

   * `$ok = Data::Locations::Shell->dump();'

   * `$ok = $filehandle->dump();'

   * `$ok = $filehandle->dump($filename);'

   * `$item = $filehandle->read();'

   * `@list = $filehandle->read();'

   * `$item = <$filehandle>;'

   * `@list = <$filehandle>;'

   * `Data::Locations::Shell->reset();'

   * `$filehandle->reset();'

   * `Data::Locations::Shell->traverse(\&callback_function);'

   * `$filehandle->traverse(\&callback_function);'

   * `Data::Locations::Shell->delete();'

   * `$filehandle->delete();'

   * `$filehandle->tie('FILEHANDLE');'


DESCRIPTION
===========

See `Data::Locations(3)' in this node for a full description.

Note that you can "tie()" the same location to several file handles at
the same time, hence the existence of the "tie()" method in this module
as well.

Note further that once you did "use Data::Locations::Shell;" you can
also use all the methods of the module "Data::Locations" (because
"Data::Locations" is loaded implicitly and automatically by
"Data::Locations::Shell"), i.e., you can have "Data::Locations" and
"Data::Locations::Shell" objects at the same time, but there is no way
of converting an object of the class "Data::Locations" into one of the
class "Data::Locations::Shell"!


SEE ALSO
========

Data::Locations(3), Tie::Handle(3), IO::Handle(1), perl(1), perldata(1),
perlfunc(1), perlsub(1), perlmod(1), perlref(1), perlobj(1), perlbot(1),
perltoot(1), perltie(1), printf(3), sprintf(3).


VERSION
=======

This man page documents "Data::Locations::Shell" version 3.0.


AUTHOR
======

Steffen Beyer <sb@sdm.de>.


COPYRIGHT
=========

Copyright (c) 1997 by Steffen Beyer. All rights reserved.


LICENSE
=======

This package is free software; you can redistribute and/or modify it
under the same terms as Perl itself.




File: pm.info, Node: Data/ShowTable, Next: Date/Convert, Prev: Data/Locations/Shell, Up: Module List

routines to display tabular data in several formats.
****************************************************



NAME
====

ShowTable - routines to display tabular data in several formats.


USAGE
=====

`use Data::ShowTable;'

ShowTable { *parameter* => value, ... };

ShowTable *\@titles*, *\@types*, *\@widths*, *\&row_sub* [, *\&fmt_sub*
];

ShowDatabases *\@dbnames*;

ShowDatabases { *parameter* => value, ... };

ShowTables *\@tblnames*;

ShowTables { *parameter* => value, ... };

ShowColumns *\@columns*, *\@col_types*, *\@col_lengths*, *\@col_attrs*;

ShowColumns { *parameter* => value, ... };

ShowBoxTable *\@titles*, *\@types*, *\@widths*, *\&row_sub* [,
*\&fmt_sub* ];

ShowBoxTable { *parameter* => value, ... };

ShowSimpleTable *\@titles*, *\@types*, *\@widths*, *\&row_sub* [,
*\&fmt_sub*];

ShowSimpleTable { *parameter* => value, ... };

ShowHTMLTable *\@titles*, *\@types*, *\@widths*, *\&row_sub* [,
*\&fmt_sub*];

ShowHTMLTable { *parameter* => value, ... };

ShowListTable *\@titles*, *\@types*, *\@widths*, *\&row_sub* [,
*\&fmt_sub*];

ShowListTable { *parameter* => value, ... };

`package Data::ShowTable';

$Show_Mode = 'mode';

$Max_Table_Width = number;

$Max_List_Width = number;

$No_Escape = *flag*;

%URL_Keys = { "*$colname*" => "*$col_URL*", ... };

*@Title_Formats* = ( *fmt1_html*, <fmt2_html>, ... );

*@Data_Formats* = ( *fmt1_html*, <fmt2_html>, ... );

ShowRow *$rewindflag*, *\$index*, *$col_array_1* [, *$col_array_2*,
...;]

*$fmt* = ShowTableValue $value, $type, $max_width, $width, $precision, $showmode;

[*$plaintext* = ] PlainText [*$htmltext*];


DESCRIPTION
===========

The ShowTable module provides subroutines to display tabular data,
typially from a database, in nicely formatted columns, in several
formats.  Its arguments can either be given in a fixed order, or, as a
single, anonymous hash-array.

The output format for any one invocation can be one of four possible
styles:

Box
     A tabular format, with the column titles and the entire table
     surrounded by a "box" of "`+'", "-", and "`|'" characters.  See
     `"ShowBoxTable"' in this node for details.

Table
     A simple tabular format, with columns automatically aligned, with
     column titles.  See `"ShowSimpleTable"' in this node.

List
     A list style, where columns of data are listed as a name:value
     pair, one pair per line, with rows being one or more column values,
     separated by an empty line.  See `"ShowListTable"' in this node.

HTML
     The data is output as an HTML *TABLE*, suitable for display through
     a *Web*-client.  See `"ShowHTMLTable"' in this node.  Input can
     either be plain ASCII text, or text with embedded HTML elements,
     depending upon an argument or global parameter.

The subroutines which perform these displays are listed below.


EXPORTED NAMES
==============

This module exports the following subroutines:

     ShowDatabases    - show list of databases
     ShowTables       - show list of tables
     ShowColumns      - show table of column info
     ShowTable        - show a table of data
     ShowRow          - show a row from one or more columns
     ShowTableValue   - show a single column's value
     ShowBoxTable     - show a table of data in a box
     ShowListTable    - show a table of data in a list
     ShowSimpleTable  - show a table of data in a simple table
     ShowHTMLTable    - show a table of data using HTML
     PlainText	  - convert HTML text into plain text

All of these subroutines, and others, are described in detail in the
following sections.


MODULES
=======


ShowTable
=========

Format and display the contents of one or more rows of data.

  ShowTable { *parameter* => value, ... };

  ShowTable *\@titles*, *\@types*, *\@widths*, *\&row_sub* 
[, *\&fmt_sub* [, $max_width ] [, *$show_mode* ] ];

The ShowTable subroutine displays tabular data aligned in columns, with
headers.  ShowTable supports four *modes* of display: Box, Table, List,
and HTML.  Each mode is described separately below.

The arguments to ShowTable may be given in one of two ways: as a
hashed-array, or by a combination of fixed order arguments, and some
package-global variable settings.  The hash-array parameters correspond
to the fixed arguments and the global-parameter settings.

In the list below, both the hash-array parameter name and the
fixed-order argument name is given as the value.  In the case where
there is no fixed-order argument for a given parameter-value pair, then
the corresponding global variable name is given.

`titles' => *\@titles*
     A reference to an array of column names, or titles.  If a
     particular column name is null, then the string `Field_num' is used
     by default.  To have a column have no title, use the empty string.

`types' => *\@types*
     A reference to an array of types, one for each column.  These types
     are passed to the *fmt_sub* for appropriate formatting.  Also, if a
     column type matches the regexp "`/text|char|string/i'", then the
     column alignment will be left-justified, otherwise it will be
     right-justified.

`widths' => *\@widths*
     A reference to an array of column widths, which may be given as an
     integer, or as a string of the form: "*width*.*precision*".

`row_sub' => *\&row_sub*
     A reference to a subroutine which successively returns rows of
     values in an array.  It is called for two purposes, each described
     separately:

     * To fetch successive rows of data:

          @row = &$row_sub(0);

     When given a null, zero, or empty argument, the next row is
     returned.

     * To initialize or rewind the data traversal.

          $rewindable = &$row_sub(1);

     When invoked with a non-null argument, the subroutine should rewind its
     row pointer to start at the first row of data.  If the data which
     *row_sub* is traversing is not rewindable, it must return zero or null.
     If the data is rewindable, a non-null, non-zero value should be
     returned.

     The *row_sub* must expect to be invoked once with a non-null
     argument, in order to discover whether or not the data is
     rewindable.  If the data cannot be rewound, *row_sub* will
     thereafter only be called with a zero argument.

     Specifically, *row_sub* subroutine is used in this manner:

          $rewindable = &$row_sub(1);
          if ($rewindable) {
              while ((@row = &$row_sub(0)), $#row >= 0) {
                  # examine lengths for optimal formatting
              }
              &$row_sub(1);   # rewind
          }
          while ((@row = &$row_sub(0)), $#row >= 0) {
              # format the data
          }

     The consequence of data that is not rewindable, a reasonably nice
     table will still be formatted, but it may contain fairly large
     amounts of whitespace for wide columns.

`fmtsub' => *\&fmt_sub*
     A reference to a subroutine which formats a value, according to its
     type, width, precision, and the current column width.  It is
     invoked either with a fixed list of arguments, or with a hash-array
     of parameter and value pairs.

          $string = &fmt_sub { I<parameter> => I<value>, ... };

          $string = &fmt_sub($value, $type, $max_width, $width, $precision)

     If *\&fmt_sub* is omitted, then a default subroutine,
     ShowTableValue, will be used, which will use Perl's standard string
     formatting rules.

     The arguments to *\&fmt_sub*, either as values passed in a fixed
     order, or as part of the parameter value pair, are described in the
     section on `"ShowTableValue' in this node below.

`max_width' => number,
     The maximum table width, including the table formatting characters.
     If not given, defaults to the global variable $Max_Table_Width;

`show_mode' => 'mode',
     The display mode of the output.  One of five strings: `'Box'',
     `'Table'', `'Simple'', `'List'', and `'HTML''.


ShowDatabases
=============

Show a list of database names.

  ShowDatabases *\@dbnames*;

  ShowDatabases { 'data' => *\@dbnames*, *parameter* =>
value, ...};

ShowDatabases is intended to be used to display a list of database
names, under the column heading of "Databases".  It is a special case
usage of ShowTable (and can thus be passed any parameter suitable for
ShowTable.

The argument, *\@dbnames*, is a reference to an array of strings, used
as the values of the single column display.


ShowTables
==========

Show an array of table names.

  ShowTables *\@tblnames*;

  ShowTables { 'data' => *\@tblnames*, *parameter* => value, ...};

ShowTables is used to display a list of table names, under the column
heading of "Tables".  It is a special case usage of ShowTable, and can
be passed any `"ShowTable"' in this node argument parameter.


ShowColumns
===========

Display a table of column names, types, and attributes.

  ShowColumns { *parameter* => values, ... };

  ShowColumns *\@columns*, *\@col_types*, *\@col_lengths*, *\@col_attrs*;

The ShowColumns subroutine displays a table of column names, types,
lengths, and other attributes in a nicely formatted table.  It is a
special case usage of ShowTable, and can be passed any argument suitable
for `"ShowTable"' in this node;

The arguments are:

`columns' = *\@columns*
     An array of column names.  This provides the value for the first
     column of the output.

`col_types' = *\@col_types*
     An array of column types names.  This provides the value for the
     second column.

`col_lengths' = *\@col_lengths*
     An array of maximum lengths for corresponding columns.  This
     provides the value for the third column of the output.

`col_attrs' = *\@col_attrs*
     An array of column attributes array references (ie: an array of
     arrays).  The attributes array for the first column are at
     "*$col_attrs*-\>[0]".  The first attribute of the second column is
     "*$col_attrs*-\>[1][0]".

The columns, types, lengths, and attributes are displayed in a table
with the column headings: "Column", "Type", "Length", and "Attributes".
This is a special case usage of ShowTable, and can be passed additional
arguments suitable for `"ShowTable"' in this node.


ShowBoxTable
============

Show tabular data in a box.

  ShowBoxTable { *parameter* = value, ... };

  ShowBoxTable *\@titles*, *\@types*, *\@widths*, *\&row_sub*
      [, [ *\&fmt_sub* ] [, $max_width ] ];

The ShowBoxTable displays tabular data in titled columns using a "box"
of ASCII graphics, looking something like this:
 

     +------------+----------+-----+----------+ 
     | Column1    | Column2  | ... | ColumnN  |
     +------------+----------+-----+----------+
     | Value11    | Value12  | ... | Value 1M |
     | Value21    | Value22  | ... | Value 2M |
     | Value31    | Value32  | ... | Value 3M |
     |  ...       |  ...     | ... |  ...     |
     | ValueN1    | ValueN2  | ... | Value NM |
     +------------+----------+-----+----------+

The arguments are the same as with `"ShowTable"' in this node.  If the
*@titles* array is empty, the header row is omitted.


ShowSimpleTable
===============

Display a table of data using a simple table format.

  ShowSimpleTable *\@titles*, *\@types*, *\@widths*, *\&row_sub* [, *\&fmt_sub*];

  ShowSimpleTable { *parameter* => values, ... };

The ShowSimpleTable subroutine formats data into a simple table of
aligned columns, in the following example:

     Column1  Column2  Column3
     -------  -------  -------
     Value1   Value2   Value3
     Value12  Value22  Value32

Columns are auto-sized by the data's widths, plus two spaces between
columns.  Values which are too long for the maximum colulmn width are
wrapped within the column.


ShowHTMLTable
=============

Display a table of data nicely using HTML tables.

  ShowHTMLTable { *parameter* => value, ... };

  ShowHTMLTable *\@titles*, *\@types*, *\@widths*, *\&row_sub*
[, *\&fmt_sub* [, $max_width [, *\%URL_Keys* [, *$no_escape* 
[, I<\@title_formats [, I<\@data_formats [, *$table_attrs* ] ] ] ] ] ] ];

The ShowHTMLTable displays one or more rows of columns of data using the
HTML C<\<TABLE\>> feature.  In addition to the usual parameter arguments
of `"ShowTable"' in this node, the following parameter arguments are
defined:

`url_keys' => *\%URL_Keys*,
     This is a hash array of column names (titles) and corresponding
     base URLs.  The values of any column names or indexes occuring as
     keys in the hash array will be generated as hypertext anchors using
     the associated printf-like string as the base URL. Either the
     column name or the column index (beginning with 1) may be used as
     the hash key.

     In the string value, these macros can be substituted:

     "`%K'" is replaced with the column name.

     "`%V'" is replaced with the column value;

     "`%I'" is replaced with the column index.

     For example, if we define the array:

          $base_url = "http://www.$domain/cgi/lookup?col=%K?val=%V";
          %url_cols = ('Author' => $base_url,
          		 'Name'   => $base_url);

     Then, the values in the Author column will be generated with the
     following HTML text:

          <A HREF="http://www.$domain/cgi/lookup?col=Author?val=somevalue>somevalue</A>

     and the values in the Name column will be generated with the URL:

          <A HREF="http://www.$domain/cgi/lookup?col=Name?val=othervalue>othervalue</A>

     If this variable is not given, it will default to the global
     variable `\%URL_Keys'.

`no_escape' => boolean,
     Unless *$no_escape* is set, HTML-escaping is performed on the data
     values in order to properly display the special HTML formatting
     characters : '\<', '\>', and '&'.  If you wish to display data with
     embedded HTML text, you must set *$no_escape*.

     Enabling embedded HTML, turns on certain heuristics which enable
     the user to more completely define appearance of the table.  For
     instance, any C<\<TR\>> tokens found embedded *anywhere* within a
     row of data will be placed at the front of the row, within the
     generated C<\<TR\>>.

     Similarly, a row of data containing the C<\<THEAD\>> or
     C<\<TFOOT\>> tokens, and their closing counterparts, will begin and
     end, respectively a table header or footer data.

`title_formats' => *\@title_formats*,
`tformats' => *\@title_formats*,
     An array of HTML formatting elements for the column titles, one for
     each column.  Each array element is a list of one or more HTML
     elements, given as C<\<ELEMENT\>> or plainly, `ELEMENT', and
     separated by a comma `','', semi-colon `';'', or vertical bar
     `'|''.  Each given HTML element is prepended to the corresponding
     column title, in the order given.  The corresponding HTML closing
     elements are appended in the opposite order.

     For example, if *\@title_formats* contains the two elements:

          [ 'FONT SIZE=+2,BOLD', 'FONT COLOR=red,EM' ]

     then the text output for the title of the first column would be:

          <FONT SIZE=+2><BOLD>I<column_1_title></BOLD></FONT>

     If `title_formats' is omitted, the global variable *@Title_Formats*
     is used by default.

`data_formats' => *\@data_formats*,
`dformats' => *\@data_formats*,
     Similar to `title_formats', this array provides HTML formatting for
     the columns of each row of data.  If `data_formats' is omitted or
     null, then the global variable *\@Data_Formats* is used by default.

`table_attrs' => *$table_attrs*,
     This variable defines a string of attributes to be inserted within
     the C<\<TABLE\>> token.  For example, if the user wishes to have no
     table border:

          ShowHTMLTable { 
          	...
          	table_attrs => 'BORDER=0', 
              ...
          };


ShowListTable
=============

Display a table of data using a list format.

  ShowListTable { *parameter* => value, ... };

  ShowListTable *\@titles*, *\@types*, *\@widths*, *\&row_sub* 
[, *\&fmt_sub* [, $max_width [, *$wrap_margin* ] ] ];

The arguments for ShowListTable are the same as for `"ShowTable"' in
this node, except for those described next.

`max_width' = number,
`wrap_margin' = number,
     Lines are truncated, and wrapped when their length exceeds
     $max_width.  Wrapping is done on a word-basis, unless the resulting
     right margin exceeds *$wrap_margin*, in which case the line is
     simply truncated at the $max_width limit.

     The $max_width variable defaults to $Max_List_Width.  The
     *$wrap_margin* defaults to $List_Wrap_Margin.

In List mode, columns (called "fields" in List mode) are displayed wth a
field name and value pair per line, with records being one or more
fields .  In other words, the output of a table would look something
like this:

     Field1_1: Value1_1
     Field1_2: Value1_2
     Field1_3: Value1_3
     ...
     Field1-N: Value1_M
     <empty line>
     Field2_1: Value2_1
     Field2_2: Value2_2
     Field2_3: Value2_3
     ...
     Field2_N: Value2_N
     ...
     FieldM_1: ValueM_1
     FieldM_2: ValueM_2
     ...
     FieldM_N: ValueM_N
     <empty line>
     <empty line>

Characteristics of List mode:

   * two empty lines indicate the end of data.

   * An empty field (column) may be omitted, or may have a label, but no
     data.

   * A long line can be continue by a null field (column):

          Field2: blah blah blah
                : blah blah blah

   * On a continuation, the null field is an arbitrary number of leading
     white space, a colon ':', a single blank or tab, followed by the
     continued text.

   * Embedded newlines are indicated by the escape mechanism "\n".
     Similarly, embedded tabs are indicated with "\t", returns with
     "\r".

   * If the *@titles* array is empty, the field names "`Field_'*NN*" are
     used instead.


ShowRow
=======

Fetch rows successively from one or more columns of data.

  ShowRow *$rewindflag*, *\$index*, *$col_array_1* [, *$col_array_2*, ...;]

The ShowRow subroutine returns a row of data from one or more columns of
data.  It is designed to be used as a *callback* routine, within the
ShowTable routine.  It can be used to select elements from one or more
array reference arguments.

If passed two or more array references as arguments, elements of the
arrays selected by *$index* are returned as the "row" of data.

If a single array argument is passed, and each element of the array is
itself an array, the subarray is returned as the "row" of data.

If the *$rewindflag* flag is set, then the *$index* pointer is reset to
zero, and "true" is returned (a scalar 1).  This indicates that the data
is rewindable to the ShowTable routines.

When the *$rewindflag* is not set, then the current row of data, as
determined by *$index* is returned, and *$index* will have been
incremented.

An actual invocation (from ShowColumns) is:

     ShowTable \@titles, \@types, \@lengths, 
         sub { &ShowRow( $_[0], \$current_row, $col_names, $col_types,
                         $col_lengths, \@col_attrs); };

In the example above, after each invocation, the *$current_row* argument
will have been incremented.


ShowTableValue
==============

Prepare and return a formatted representation of a value.  A value
argument, using its corresponding type, effective width, and precision
is formatted into a field of a given maximum width.

  *$fmt* = ShowTableValue $value, $type, $max_width, $width, $precision, $showmode;

`width' => $width
$width
     The width of the current value.  If omittied, $max_width is
     assumed.

`precision' => $precision
$precision
     The number of decimal digits; zero is assumed if omittied.

value => $value
$value
     The value to be formatted.

$type
     The type name of the value; eg: `char', `varchar', int, etc.

`maxwidth' => $max_width
$max_width
     The maximum width of any value in the current value's column.  If
     $width is zero or null, $max_width is used by default.  $max_width
     is also used as a minimum width, in case $width is a smaller value.

$width
     The default width of the value, obtained from the width
     specification of the column in which this value occurs.

$precision
     The precision specification, if any, from the column width
     specification.

$showmode
     The mode of the output: one of "table", "list", "box", or "html".
     Currently, only the "html" mode is significant: it is used to avoid
     using HTML tokens as part of the formatted text and length
     calculations.


PlainText
=========

  *$plaintext* = *&PlainText*(*$htmltext*);

  *&PlainText*

This function removes any HTML formatting sequences from the input
argument, or from $_ if no argument is given.  The resulting plain text
is returned as the result.


VARIABLES
=========

The following variables may be set by the user to affect the display
(with the defaults enclosed in square brackets [..]):

$Show_Mode [Box]
     This is the default display mode when using ShowTable.  The
     environment variable, `$ENV{'SHOW_MODE'}', is used when this
     variable is null or the empty string.  The possible values for this
     variable are: `"Box"', `"List"', `"Table"', and `"HTML"'.  Case is
     insignificant.

$List_Wrap_Margin [2]
     This variable's value determines how large a margin to keep before
     wrarpping a long value's display in a column.  This value is only
     used in "List" mode.

$Max_List_Width [80]
     This variable, used in "List" mode, is used to determine how long
     an output line may be before wrapping it.  The environment
     variable, `$ENV{'COLUMNS'}', is used to define this value when it
     is null.

$Max_Table_Width ['']
     This variable, when set, causes all tables to have their columns
     scaled such that their total combined width does not exceed this
     value.  When this variable is not set, which is the default case,
     there is no maximum table width, and no scaling will be done.

$No_Escape ['']
     If set, allows embedded HTML text to be included in the data
     displayed in an HTML-formatted table.  By default, the HTML
     formatting characters ("<", ">", and "&") occuring in values are
     escaped.

%URL_Keys
     In HTML mode, this variable is used to recognize which columns are
     to be displayed with a corresponding hypertext anchor.  See
     `"ShowHTMLTable"' in this node for more details.

*@HTML_Elements*
     An array of HTML elements (as of HTML 3.0) used to recognize and
     strip for width calculations.

$HTML_Elements
     A regular expression string formed from the elements of
     *@HTML_Elements*.


INTERNAL SUBROUTINES
====================


get_params
==========

  my *$args* = *&get_params* *\@argv*, *\%params*, *\@arglist*;

Given the *@argv* originally passed to the calling sub, and the hash of
named parameters as *%params*, and the array of parameter names in the
order expected for a pass-by-value invocation, set the values of each of
the variables named in *@vars*.

If the only element of the *@argv* is a hash array, then set the
variables to the values of their corresponding parameters used as keys
to the hash array.  If the parameter is not a key of the *%params* hash,
and is not a key in the global hash *%ShowTableParams*, then an error is
noted.

When *@argv* has multiple elements, or is not a hash array, set each
variable, in the order given within *@arglist*, to the values from the
*@argv*, setting the variables named by each value in *%params*.

Variables may given either by name or by reference.

The result is a HASH array reference, either corresponding directly to
the HASH array passed as the single argument, or one created by
associating the resulting variable values to the parameter names
associated with the variable names.


html_formats
============

  (*$prefixes*,*$suffixes*) = html_formats *\@html_formats*;

The *html_format* function takes an array reference of HTML formatting
elements *\@html_formats*, and builds two arrays of strings: the first:
*$prefixes*, is an array of prefixes containing the corresponding HTML
formatting elements from *\@html_formats*, and the second,
*$suffixes*, containing the appropriate HTML closing elements, in the
opposite order.

The result is designed to be used as prefixes and suffixes for the
corresponding titles and column values.

The array *\@html_formats* contains lists of HTML formatting elements,
one for each column (either title or data).  Each array element is a
list of one or more HTML elements, either given in HTML syntax, or as a
"plain" name (ie: given as C<\<ELEMENT\>> or plainly, `ELEMENT').
Multiple elements are separated by a comma `',''.

The resulting array of *$prefixes* contains the corresponding opening
elements, in the order given, with the proper HTML element syntax.  The
resulting array of *$suffixes* contains the closing elements, in the
opposite order given, with the proper HTML element syntax.

For example, if *\@html_formats* contains the two elements:

     [ 'FONT SIZE=+2,BOLD', 'FONT COLOR=red,EM' ]

then the resulting two arrays will be returned as:

     [ [ '<FONT SIZE=+2><BOLD>', '<FONT COLOR=red><EM>' ],
       [ '</FONT></BOLD>',	'</FONT></EM>' ] ]


calc_widths
===========

  ($num_cols, $widths, $precision, $max_widths) =
  *&calc_widths*( $widthspec, $titles, $rewindable,
      $row_sub, $fmt_sub, $types, $showmode, 
      $max_width);


DESCRIPTION
-----------

calc_widths is a generalized subroutine used by all the ShowTable
variant subroutines to setup internal variables prior to formatting for
display.  *Calc_widths* handles the column width and precision analysis,
including scanning the data (if rewindable) for appropriate default
values.

The number of columns in the data is returned, as well as three arrays:
the declared column widths, the column precision values, and the maximum
column widths.


RETURN VALUES
-------------

$num_cols
     is the number of columns in the data.  If the data is not
     rewindable, this is computed as the maximum of the number of
     elements in the $widthspec array and the number of elements in the
     $titles array.  When the data is rewindable, this is the maximum of
     the number of columns of each row of data.

$widths
     is the column widths array ref, without the precision specs (if
     any).  Each column's width value is determined by the original
     $widthspec value and/or the maximum length of the formatted data
     for the column.

$precision
     is the precision component (if any) of the original $widthspec
     array ref.  If there was no original precision component from the
     $widthspec, and the data is rewindable, then the data is examined
     to determine the maximum default precision.

$max_widths
     is the ref to the array of maximum widths for the given columns.


ARGUMENTS
---------

$widthspec
     A reference to an array of column width (or length) values, each
     given as an integer, real number, or a string value of
     "*width*.*precision*".  If a value is zero or null, the length of
     the corresponding formatted data (if rewindable) and column title
     length are used to determine a reasonable default.

     If a column's *width* portion is a positive, non-zero number, then
     the column will be this wide, regardless of the values lengths of
     the data in the column.

     If the column's *width* portion is given as a negative number, then the
     positive value is used as a minimum column width, with no limit on the
     maximum column width.  In other words, the column will be at least
     *width* characters wide.

     If the data is not rewindable, and a column's width value is null
     or zero, then the length of the column title is used.  This may
     cause severe wrapping of data in the column, if the column data
     lengths are much greater than the column title widths.

$titles
     The array ref to the column titles; used to determine the minimum
     acceptable width, as well as the default number of columns.  If the
     $titles array is empty, then the $widthspec array is used to
     determine the default number of columns.

$rewindable
     A flag indicating whether or not the data being formatted is
     rewindable.  If this is true, a pass over the data will be done in
     order to calculate the maximum lengths of the actual formatted
     data, using $fmt_sub (below), rather than just rely on the declared
     column lengths.  This allows for optimal column width adjustments
     (ie: the actual column widths may be less than the declared column
     widths).

     If it is not desired to have the column widths dynamically
     adjusted, then set the $rewindable argument to 0, even if the data
     is rewindable.

$row_sub
     The code reference to the subroutine which returns the data;
     invoked only if $rewindable is non-null.

$fmt_sub
     The subroutine used to determine the length of the data when
     formatted; if this is omitted or null, the length of the data is
     used by default.  The $fmt_sub is used only when the data is
     rewindable.

$types
     An array reference to the types of each of the value columns; used
     only when $fmt_sub is invoked.

$showmode
     A string indicating the mode of the eventual display; one of four
     strings: "`box'", "`table'", "list", and "`html'".  Used to adjust
     widths for formatting requirements.

$max_width
     The maximum width of the table being formatted.  If set, and the
     total sum of the individual columns exceeds this value, the column
     widths are scaled down uniformly.  If not set (null), no column
     width scaling is done.


putcell
=======

  *$wrapped* = *&putcell*( *\@cells*, $c, *$cell_width*, *\@prefix*, *\@suffix*, *$wrap_flag* );

Output the contents of an array cell at *$cell*[$c], causing text longer
than *$cell_width* to be saved for output on subsequent calls.
Prefixing the output of each cell's value is a string from the
two-element array *@prefix*.  Suffixing each cell's value is a string
from the two-element array *@suffix*.  The first element of either array
is selected when *$wrap_flag* is zero or null, or when there is no more
text in the current to be output.  The second element is selected when
*$wrap_flag* is non-zero, and when there is more text in the current
cell to be output.

In the case of text longer than *$cell_width*, a non-zero value is
returned.

Cells with undefined data are not output, nor are the prefix or suffix
strings.


center
======

Center a string within a given width.

  *$field* = center *$string*, $width;


max
===

Compute the maximum value from a list of values.

  *$max* = *&max*( *@values* );


min
===

Compute the minum value from a list of values.

  *$min* = *&min*( *@values* );


max_length
==========

Compute the maximum length of a set of strings in an array reference.

  *$maxlength* = *&max_length*( *\@array_ref* );


htmltext
========

Translate regular text for output into an HTML document.  This means
certain characters, such as "&", ">", and "<" must be escaped.

  *$output* = *&htmltext*( *$input* [, *$allflag* ] );

If *$allflag* is non-zero, then all characters are escaped.  Normally,
only the four HTML syntactic break characters are escaped.


out
===

Print text followed by a newline.

  out *$fmt* [, *@text* ];


put
===

Print text (without a trailing newline).

  out *$fmt* [, *@text* ];


AUTHOR
======

Alan K. Stebbens <aks@sgi.com>


BUGS
====

   * Embedded HTML is how the user can insert formatting overrides.
     However, the HTML formatting techniques have not been given much
     consideration -- feel free to provide constructive feedback.




