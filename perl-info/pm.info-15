Info file: pm.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `bigpm.texi'
using `texinfmt.el' version 2.32 of 19 November 1993.





File: pm.info, Node: Date/Convert, Next: Date/DateCalc, Prev: Data/ShowTable, Up: Module List

Convert Between any two Calendrical Formats
*******************************************



NAME
====

Date::Convert - Convert Between any two Calendrical Formats


SYNOPSIS
========

     use Date::DateCalc;

     $date=new Date::Convert::Gregorian(1997, 11, 27);
     @date=$date->date;
     convert Date::Convert::Hebrew $date;
     print $date->date_string, "\n";

Currently defined subclasses:

     Date::Convert::Astro
     Date::Convert::Gregorian
     Date::Convert::Hebrew
     Date::Convert::Julian

Date::Convert is intended to allow you to convert back and forth between
any arbitrary date formats (ie. pick any from: Gregorian, Julian,
Hebrew, Astronomical, and any others that get added on).  It does this
by having a separate subclass for each format, and requiring each class
to provide standardized methods for converting to and from the date
format of the base class.  In this way, instead of having to code a
conversion routine for going between and two arbitrary formats foo and
bar, the function only needs to convert foo to the base class and the
base class to bar.  Ie:

     Gregorian <--> Base class <--> Hebrew

The base class includes a *Convert* method to do this transparently.

Nothing is exported because it wouldn't make any sense to export.  :)


DESCRIPTION
===========

Fucntion can be split into several categories:

   * Universal functions available for all subclasses (ie. all formats).
     The fundamental conversion routines fit this category.

   * Functions that are useful but don't necessarily make sense for all
     subclasses.  The overwhelming majority of functions fall into this
     category.  Even such seemingly universal concepts as year, for
     instance, don't apply to all date formats.

   * Private functions that are required of all subclasses,
     ie. initialize.  These should *not* be called by users.

Here's the breakdown by category:


Functions Defined for all Subclasses
------------------------------------

new
     Create a new object in the specified format with the specified
     start paramaters, ie. `$date = new Date::Convert::Gregorian(1974,
     11, 27)'.  The start parameters vary with the subclass.  My
     personal preference is to order in decreasing order of generality
     (ie. year first, then month, then day, or year then week, etc.)

     This can have a default date, which should probably be "today".

date
     Extract the date in a format appropriate for the subclass.
     Preferably this should match the format used with new, so

          (new date::Convert::SomeClass(@a))->date;

     should be an identity function on @a if @a was in a legitmate
     format.

date_string
     Return the date in a pretty format.

convert
     Change the date to a new format.


Non-universal functions
-----------------------

year
     Return just the year element of date.

month
     Just like year.

day
     Just like year and month.

is_leap
     Boolean.  Note that (for *::Hebrew* and *::Gregorian*, at least!)
     this can be also be used as a static.  That is, you can either say
     	$date->is_leap or
     	is_leap Date::Convert::Hebrew 5757


Private functions that are required of all subclasses
-----------------------------------------------------

You shouldn't call these, but if you want to add a class, you'll need to
write them!  Or it, since at the moment, there's only one.

initialize
     Read in args and initialize object based on their values.  If there
     are no args, initialize with the base class's initialize (which
     will initialize in the default way described above for new.)  Note
     the American spelling of "initialize": "z", not "s".


SUBCLASS SPECIFIC NOTES
=======================


Astro
-----

The "astro" calendar is just the number of days from a certain reference
point.  It has no notion of years, making it an extremely easy calendar
for conversion purposes.  I believe that the formal names for this are
"Astronomical Day Number" and "Julian Day Number" (not to be confused
with the Julian calendar).

The subclass is little more than the base class, and as the lowest
common denominator, doesn't have any special functions.


Gregorian
---------

The Gregorian calendar is a purely solar calendar, with a month that is
only an approximation of a lunar month.  It is based on the old Julian
(Roman) calendar.  This is the calendar that has been used by most of
the Western world for the last few centuries.  The time of its adoption
varies from country to country.  This *::Gregorian* allows you to
extrapolate back to 1 A.D., as per the prorgamming tradition, even
though the calendar definitely was not in use then.

In addition to the required methods, Gregorian also has year, month,
day, and is_leap methods.  As mentioned above, is_leap can also be used
statically.


Hebrew
------

This is the traditional Jewish calendar.  It's based on the solar year,
on the lunar month, and on a number of additional rules created by
Rabbis to make life tough on people who calculate calendars.  :) If you
actually wade through the source, you should note that the seventh month
really does come before the first month, that's not a bug.

It comes with the following additional methods: year, month, day,
is_leap, *rosh*, *part_add*, and *part_mult*.  *rosh* returns the astro
day corresponding to "Rosh HaShana" (New year) for a given year, and can
also be invoked as a static.  *part_add* and *part_mult* are useful
functions for Hebrew calendrical calculations are not for much else; if
you're not familiar with the Hebrew calendar, don't worry about them.


Islamic
-------

The traditional Muslim calendar, a purely lunar calendar with a year
that is a rough approximation of a solar year.  Currently unimplemented.


Julian
------

The old Roman calendar, allegedly named for Julius Caesar.  Purely
solar, with a month that is a rough approximation of the lunar month.
Used extensively in the Western world up to a few centuries ago, then
the West gradually switched over to the more accurate Gregorian.  Now
used only by the Eastern Orthodox Church, AFAIK.


ADDING NEW SUBCLASSES
=====================

This section describes how to extend *Date::Convert* to add your
favorite date formats.  If you're not interested, feel free to skip it.
:)

There are only three function you *have* to write to add a new subclass:
you need initialize, date, and date_string.  Of course, helper functions
would probably help. . .  You do *not* need to write a new or convert
function, since the base class handles them nicely.

First, a quick conceptual overhaul: the base class uses an "astronomical
format" ("Julian day format") borrowed from *emacs*.  This is just days
numbered absolutely from an extremely long time ago.  I don't know much
about it, but it's really easy to use, particularly if you have emacs
and emacs' *calendar mode*.  Each Date::Convert object is a reference to
a hash (as in all OO perl) and includes a special "astro" value stored
under a reserved "astro" key.  When initialize initializes an object,
say a Gregorian date, it stores whatever data it was given in the object
and it also calculates the "astro" equivalent of the date and stores it,
too.  If the user converts to another date, the object is wiped clean of
all data except "astro".  Then when the date method for the new format
is called, it calculates the date in the new format from the "astro"
data.

Now that I've thoroughly confused you, here's a more compartmentalized
version:

initialize
     Take the date supplied as argument as appropriate to the format,
     and convert it to "astro" format.  Store it as `$$self{'astro'}'.
     You might also want to store other data, ie. *::Gregorian* stores
     `$$self{'year'}', `$$self{'month'}', and `$$self{'day'}'.  If no
     args are supplied, explicitly call the base class's initialize,
     ie. `Date::Convert::initialize', to initialize with a default
     'astro' date and nothing else.

     *NOTE:*  I may move the default behavior into the new constructor.

date
     Return the date in a appropriate format.  Note that the only fact
     that date can take as given is that `$$self{'astro'}' is defined,
     ie. this object may *not* have been initialized by the initialize
     of this object's class.  For instance, you might have it check if
     `$$self{'year'}' is defined.  If it is, then you have the year
     component, otherwise, you calculate year from `$$self{'astro'}'.

date_string
     This is the easy part.  Just call date, then return a pretty string
     based on the values.

*NOTE:* The *::Astro* subclass is a special case, since it's nearly an
empty subclass (ie. it's just the base class with the required methods
filled out).  Don't use it as an example!  The easiest code to follow
would have been *::Julian* except that Julian inherits from
*::Gregorian*.  Maybe I'll reverse that. . .


EXAMPLES
========

     #!/usr/local/bin/perl5 -w

     use Date::Convert;

     $date=new Date::Convert::Gregorian(1974, 11, 27);
     convert Date::Convert::Hebrew $date;
     print $date->date_string, "\n";

My Gregorian birthday is 27 Nov 1974.  The above prints my Hebrew
birthday.

     convert Date::Convert::Gregorian $date;
     print $date->date_string, "\n";

And that converts it back and prints it in Gregorian.

     $guy = new Date::Convert::Hebrew (5756, 7, 8);
     print $guy->date_string, " -> ";
     convert Date::Convert::Gregorian $guy;
     print $guy->date_string, "\n";

Another day, done in reverse.

     @a=(5730, 3, 2);
     @b=(new Date::Convert::Hebrew @a)->date;
     print "@a\n@b\n";

The above should be an identity for any list @a that represents a
legitimate date.

     #!/usr/local/bin/perl -an

     use Date::Convert;

     $date = new Date::Convert::Gregorian @F;
     convert Date::Convert::Hebrew $date;
     print $date->date_string, "\n";

And that's a quick Greg -> Hebrew conversion program, for those times
when people ask.


SEE ALSO
========

perl(1), Date::DateCalc(3)


VERSION
=======

Date::Convert 0.14 (pre-alpha)


AUTHOR
======

Mordechai T. Abzug <morty@umbc.edu>


ACKNOWLEDGEMENTS AND FURTHER READING
====================================

The basic idea of using astronomical dates as an intermediary between
all calculations comes from Dershowitz and Reingold.  Reingold's code is
the basis of emacs's calendar mode.  Two papers describing their work
(which I used to own, but lost!  Darn.) are:

``Calendrical Calculations'' by Nachum Dershowitz and Edward M. Reingold,
*Software--Practice and Experience*, Volume 20, Number 9 (September,
1990), pages 899-928.  ``Calendrical Calculations, Part II: Three
Historical Calendars'' by E. M. Reingold, N. Dershowitz, and S. M. Clamen,
*Software--Practice and Experience*, Volume 23, Number 4 (April, 1993),
pages 383-404.

They were also scheduled to come out with a book on calendrical
calculations in Dec. 1996, but as of March 1997, it still isn't out yet.

The Hebrew calendrical calculations are largely based on a cute little
English book called *The Hebrew Calendar* (I think. . .)  in a box
somewhere at my parents' house.  (I'm organized, see!)  I'll have to dig
around next time I'm there to find it.  If you want to access the
original Hebrew sources, let me give you some advice: Hilchos Kiddush
HaChodesh in the Mishneh Torah is not the Rambam's most readable
treatment of the subject.  He later wrote a little pamphlet called
"MaAmar HaEibur" which is both more complete and easier to comprehend.
It's included in "Mich't'vei HaRambam" (or some such; I've *got* to
visit that house), which was reprinted just a few years ago.

Steffen Beyer's Date::DateCalc showed me how to use MakeMaker and write
POD documentation.  Of course, any error is my fault, not his!


COPYRIGHT
=========

Copyright 1997 by Mordechai T. Abzug


LICENSE STUFF
=============

You can distribute, modify, and otherwise mangle Date::Convert under the
same terms as perl.




File: pm.info, Node: Date/DateCalc, Next: Date/DateCalcLib, Prev: Date/Convert, Up: Module List

Gregorian Calendar Date Calculations
************************************



NAME
====

Date::DateCalc - Gregorian Calendar Date Calculations

in compliance with ISO/R 2015-1971 and DIN 1355 standards


SYNOPSIS
========

`use Date::DateCalc;'

(in which case you must fully qualify every function with the name of
this module, for example `$flag = Date::DateCalc::leap($year)')

or

`use Date::DateCalc' `qw( leap check_date compress uncompress
check_compressed' `compressed_to_short calc_days day_of_week
dates_difference' `calc_new_date date_time_difference
calc_new_date_time' `date_to_short date_to_string week_number
first_in_week' `weeks_in_year day_name_tab month_name_tab decode_day'
`decode_month decode_date days_in_month );'

(or only portions thereof, whatever you need)

or

`use DateCalc qw(:all);'

(which imports everything).


DESCRIPTION
===========


===========
-----------


Convention:
-----------


===========
-----------

In the following, "$year" stands for a "complete" year number (like
"1995", for instance), whereas "$yy" may be an abbreviated year number
(like "95") OR a complete year number.

Year numbers must be positive integers (greater than zero).

"$mm" stands for the number of a month (from 1 to 12), and "$dd" is the
number of a day in a month (from 1 to 28,29,30 or 31, depending on the
month and the year).

Hint: The functions that support abbreviated year numbers are the
functions whose names contain the word "compress" and the function
"decode_date()".


====================
--------------------


`$flag = leap($year);'
----------------------


====================
--------------------

This function returns a boolean value which is "true" (1) if the year
"$year" is a leap year, and "false" (0) otherwise.

No check is made if the year "$year" is in the valid range.

For years less than 1, the result is probably meaningless (it IS almost
meaningless, anyway, for years before 1582).


==================================
----------------------------------


`$flag = check_date($year,$mm,$dd);'
------------------------------------


==================================
----------------------------------

This function returns a boolean value which is "true" (1) if the three
numbers "$year", "$mm" and "$dd" represent a valid date, and "false" (0)
otherwise.

When determining validity, leap years are taken into account, i.e., the
29th of february is rejected in non-leap years.

Year numbers must be greater than zero (negative values will be
interpreted as large positive numbers due to their internal 2's
complement binary representation). A year number of zero is invalid.


==============================
------------------------------


`$date = compress($yy,$mm,$dd);'
--------------------------------


==============================
------------------------------

This function encodes a date in 16 bits. The encoding scheme is as
follows:

     Bit-No.:       FEDCBA9 8765 43210
     Contents:      yyyyyyy mmmm ddddd

All bits equal to zero is equivalent to "<no date>".

Through this encoding scheme, it is possible to COMPARE ENCODED DATES
for equality and ORDER (less than/greater than) WITHOUT any previous
DECODING!!

Note however that contiguous dates DO NOT NECESSARILY have contiguous
compressed representations!

I.e., incrementing the compressed representation of a date may or MAY
NOT yield a valid new date!

Note also that this function can only handle dates within one century.

This century can be biased at will by choosing a base century and year
(also called an "epoch"). In this module, the base century is set to
1900 and the base year to 70 (standard on UNIX systems).

This allows the function to handle dates from 1970 up to 2069.

If the year "$yy" is equal to, say, 95, it is automatically assumed that
1995 is meant. However, if you specify a year number which is SMALLER
than 70, like 64, for instance, it is assumed that you meant 2064.

You are not confined to abbreviated year numbers (smaller than 100),
however. The function also accepts complete year numbers, provided that
they are in the supported range (that is, from 1970 to 2069).

If no valid date is specified, zero is returned.


======================================
--------------------------------------


`($cc,$yy,$mm,$dd) = uncompress($date);'
----------------------------------------


======================================
--------------------------------------

This function decodes dates that were encoded by "compress()".  It
returns the century, year, month and day of the date encoded in "$date"
in the variables "$cc", "$yy", "$mm" and "$dd", respectively.

The expression "$cc + $yy" yields the complete year number (for example,
1900 + 95 = 1995).

If "$date" is zero or does not contain the compressed representation of
a valid date, an empty list is returned.


================================
--------------------------------


`$flag = check_compressed($date);'
----------------------------------


================================
--------------------------------

This function returns a boolean value which is "true" (1) if "$date"
contains a valid encoded date, and "false" (0) otherwise.

When determining validity, leap years are taken into account, i.e., the
29th of february is rejected in non-leap years.


======================================
--------------------------------------


`$datestr = compressed_to_short($date);'
----------------------------------------


======================================
--------------------------------------

This function converts the encoded date in "$date" to a string of the
format "dd-mmm-yy", which is returned.

("mmm" is the 3-letter abbreviation (in English) of the month's name.)

If the date in "$date" is invalid, the string "<no date>" is returned.

Note that the string which is returned by this function is always
exactly 9 characters long.


=================================
---------------------------------


`$days = calc_days($year,$mm,$dd);'
-----------------------------------


=================================
---------------------------------

This function returns the (theoretical) number of days between the first
of january of the year one and the given date *plus one*.

I.e., the value returned for the first of january of the year one is 1,
the value returned for the second of january of the year one is 2, and
so on.

This is because there is no year zero; the christian calendar starts
with the year one. Consequently, there is also no day zero; the calendar
starts with the first day, i.e., day one.

The function doesn't take into account the change from the Julian to the
Gregorian calendar (used today) in 1582 (or later, for some countries),
it simply extrapolates the gregorian calendar backwards.

This function is used internally to calculate the difference in days
between two dates and to calculate the day of week.

Use this function to compare dates for "less than" and "greater than",
or to compare dates for equality more easily.

Zero is returned if no valid date is specified.

(This is another reason why "`calc_days(1,1,1)'" is equal to one and not
to zero!)


======================================
--------------------------------------


`$weekday = day_of_week($year,$mm,$dd);'
----------------------------------------


======================================
--------------------------------------

This function calculates the day of week for the given date (which must
be a valid date).

The return values have the following meaning:

     0       =       Error
     1       =       Monday
     2       =       Tuesday
     3       =       Wednesday
     4       =       Thursday
     5       =       Friday
     6       =       Saturday
     7       =       Sunday

The value zero is returned if the date is not valid.


============================================================
------------------------------------------------------------


`$days = dates_difference($year1,$mm1,$dd1,$year2,$mm2,$dd2);'
--------------------------------------------------------------


============================================================
------------------------------------------------------------

This function calculates the difference in days between the two given
dates.

The function calculates the difference "date 2" - "date 1", i.e., you
normally specify the two dates in chronological order.

If date 1 is later than date 2, the result will be negative, which
allows you to use this function to compare dates.

If one of the two dates is invalid, the result will degrade to the value
of the function "calc_days()" for the other date (possibly negative). If
both dates are invalid, the result is zero.

It is the user's responsibility to make sure that both dates are valid
(use "check_date()" for this)!


=======================================================
-------------------------------------------------------


`($year,$mm,$dd) = calc_new_date($year,$mm,$dd,$offset);'
---------------------------------------------------------


=======================================================
-------------------------------------------------------

Starting from the given date, a new date can be calculated with this
function which is "$offset" days away from the original date. "$offset"
may be positive (for a date later than the original date) or negative
(for a date earlier than the given date).

If the given date is invalid or the new date cannot be calculated (for
instance, if the new date would be before the year one), an empty list
is returned.

To calculate a new date with a year, month and day offset, see the
function "year_month_day_offset()" in the "Date::DateCalcLib" module.


===========================================
-------------------------------------------


`($days,$hh,$mm,$ss) = date_time_difference( $year1,$month1,$day1,$hh1,$mm1,$ss1, $year2,$month2,$day2,$hh2,$mm2,$ss2 );'
-------------------------------------------------------------------------------------------------------------------------


===========================================
-------------------------------------------

This function calculates the difference in days, hours, minutes and
seconds between the two given dates.

The function calculates the difference "date 2" - "date 1", i.e., you
normally specify the two dates in chronological order.

If date 1 is later than date 2, the result will be negative in every of
the four return values, which allows you to use this function to compare
dates and to feed its output into the function explained next in this
text, "calc_new_date_time()".

If one (or both) of the two date/time pairs is invalid, an empty list is
returned.

A date/time pair is invalid either when the date is invalid or when the
values for hour, minute and second are outside the range of 0..23, 0..59
and 0..59, respectively.


=====================================================
-----------------------------------------------------


`($year,$month,$day,$hh,$mm,$ss) = calc_new_date_time( $year,$month,$day,$hh,$mm,$ss, $days_offset,$hh_offset,$mm_offset,$ss_offset );'
---------------------------------------------------------------------------------------------------------------------------------------


=====================================================
-----------------------------------------------------

Starting from the given date and time, a new date and time can be
calculated with this function.

The new date will be "$days_offset" days and "$hh_offset" hours,
"$mm_offset" minutes and "$ss_offset" seconds away from the original
date. The values of these four offsets may be positive or negative,
independently from each other. This means that you can add, for
instance, 9 hours and subtract 5 minutes at the same time.

If the new date and time cannot be calculated (for instance, if the
given date is invalid or the new date would be before the year one, or
the values for hour, minute and second are outside the range of 0..23,
0..59 and 0..59, respectively), an empty list is returned.


========================================
----------------------------------------


`$datestr = date_to_short($year,$mm,$dd);'
------------------------------------------


========================================
----------------------------------------

This function converts the given date to a string of the format "www
dd-mmm-yyyy", which is returned.

"www" is a (3-letter) abbreviation of the day of week, and "mmm" is a
(3-letter) abbreviation of the month (both in English).

If the given date is invalid, the string "<no date>" is returned.


=========================================
-----------------------------------------


`$datestr = date_to_string($year,$mm,$dd);'
-------------------------------------------


=========================================
-----------------------------------------

This function converts the given date to a string of the format
"wwwwwwwww, dd mmmmmmmmm yyyy", which is returned.

"wwwwwwwww" is the day of week and "mmmmmmmmm" the name of the month
(both in English).

If the given date is invalid, the string "<no date>" is returned.


===========================================
-------------------------------------------


`($week,$year) = week_number($year,$mm,$dd);'
---------------------------------------------


===========================================
-------------------------------------------

This function calculates the number of the week in which the given date
lies.

This can occasionally be the last week of the previous year or the first
week of the next year.

If the given date is invalid, an empty list is returned.


=============================================
---------------------------------------------


`($year,$mm,$dd) = first_in_week($week,$year);'
-----------------------------------------------


=============================================
---------------------------------------------

This function calculates the date of the first day (the Monday) of the
given week in the given year.

The return value "$year" is adjusted accordingly if the first day of the
given week lies in the previous year.

If the week number is invalid (less than one or greater than the number
of weeks of the given year, as returned by the function
"weeks_in_year()"), or if the year is invalid or the date cannot be
calculated (for example, if the calculated date would be before the year
one), an empty list is returned.

With help of the expression

     ($year,$mm,$dd) = first_in_week(week_number($year,$mm,$dd));

it is possible to easily calculate the date of the Monday belonging to
the week in which the given date lies.

(However, a fatal Perl error will occur if the given date is invalid!)

Alternatively, the expression

     ($year,$mm,$dd) =
     calc_new_date($year,$mm,$dd,-day_of_week($year,$mm,$dd)+1);

can be used to achieve the same effect.

(An empty list is returned if the given date is invalid.)


==============================
------------------------------


`$weeks = weeks_in_year($year);'
--------------------------------


==============================
------------------------------

This function returns the number of weeks of the given year (52 or 53
weeks).

No check is made if the year "$year" is in the valid range.

For years less than 1, the result is probably meaningless.


===================================
-----------------------------------


`$day_name = day_name_tab($weekday);'
-------------------------------------


===================================
-----------------------------------

This function accesses the internal table of the days of week.

It returns the corresponding string for each numeric value of a day of
week (as returned by the function "day_of_week()").

The value of "$weekday" is taken modulo 8 (!) internally to prevent
out-of-range access to the internal array.

The strings which are returned are the following:

     0       =>      Error
     1       =>      Monday
     2       =>      Tuesday
     3       =>      Wednesday
     4       =>      Thursday
     5       =>      Friday
     6       =>      Saturday
     7       =>      Sunday


=====================================
-------------------------------------


`$month_name = month_name_tab($month);'
---------------------------------------


=====================================
-------------------------------------

This function accesses the internal table of the months' names.

It returns the corresponding string for each numeric value of a month.

The value of "$month" is taken modulo 13 (!) internally to prevent
out-of-range access to the internal array.

The strings which are returned are the following:

     0       =>      Error
     1       =>      January
     2       =>      February
     3       =>      March
     4       =>      April
     5       =>      May
     6       =>      June
     7       =>      July
     8       =>      August
     9       =>      September
     		10       =>      October
     		11       =>      November
     		12       =>      December


===============================
-------------------------------


`$weekday = decode_day($buffer);'
---------------------------------


===============================
-------------------------------

This function provides the inverse of the function "day_name_tab()".

Whereas "day_name_tab()" takes a number as its argument and returns a
string, "decode_day()" takes a string (of any length) and tries to match
it with the table of the names of days ("Monday", "Tuesday", and so on)
and returns the corresponding number (1..7).

Only the first 3 characters are checked (in case-insensitive manner) for
a unique match. If it uniquely identifies the day, you may also provide
only one or two characters:

     Name of the day:     Uniquely identified by:     Value returned:

     Monday        M, Mo, Mon, ... Monday            1
     Tuesday          Tu, Tue, ... Tuesday           2
     Wednesday     W, We, Wed, ... Wednesday         3
     Thursday         Th, Thu, ... Thursday          4
     Friday        F, Fr, Fri, ... Friday            5
     Saturday         Sa, Sat, ... Saturday          6
     Sunday           Su, Sun, ... Sunday            7

If there is no match, zero is returned.

This function is roughly equivalent to an associative array:

     %day_tab = ( 'Mon' => 1, 'Tue' => 2, 'Wed' => 3, 'Thu' => 4,
                  'Fri' => 5, 'Sat' => 6, 'Sun' => 7);
     $weekday = $day_tab{$buffer};

except for the capability of recognizing abbreviations and to be
case-independent.


===============================
-------------------------------


`$month = decode_month($buffer);'
---------------------------------


===============================
-------------------------------

This function provides the inverse of the function "month_name_tab()".

Whereas "month_name_tab" takes a number as its argument and returns a
string, "decode_month" takes a string (of any length) and tries to match
it with the table of the names of months ("January", "February", and so
on) and returns the corresponding number (1..12).

Only the first 3 characters are checked (in case-insensitive manner) for
a unique match. If it uniquely identifies the month, you may also
provide only one or two characters:

     Name of the month:     Uniquely identified by:     Value returned:

     January          Ja, Jan, ... January           1
     February      F, Fe, Feb, ... February          2
     March                Mar, ... March             3
     April            Ap, Apr, ... April             4
     May                  May, ... May               5
     June                 Jun, ... June              6
     July                 Jul, ... July              7
     August           Au, Aug, ... August            8
     September     S, Se, Sep, ... September         9
     October       O, Oc, Oct, ... October          10
     November      N, No, Nov, ... November         11
     December      D, De, Dec, ... December         12

If there is no match, zero is returned.

This function is roughly equivalent to an associative array:

     %month_tab = ( 'Jan' => 1, 'Feb' => 2, 'Mar' => 3, 'Apr' => 4,
                    'May' => 5, 'Jun' => 6, 'Jul' => 7, 'Aug' => 8,
                    'Sep' => 9, 'Oct' => 10, 'Nov' => 11, 'Dec' => 12);
     $month = $month_tab{$buffer};

except for the capability of recognizing abbreviations and to be
case-independent.


=======================================
---------------------------------------


`($year,$mm,$dd) = decode_date($buffer);'
-----------------------------------------


=======================================
---------------------------------------

Using this function, it is possible to parse dates in almost any format,
provided the date is given as "day - month - year".

(To decode dates in U.S. american format, i.e., dates given as "month -
day - year", see the function "decode_date_us()" in the
"Date::DateCalcLib" module.)

The day and the year must be given as numbers, the month may be
specified either by a number or an abbreviation (up to 3 characters
long) of the month's name in English (case is ignored).

If they uniquely identify the month, one or two letters are sufficient
(e.g. "s" for september or "ja" for january).

The year may be abbreviated as well, for instance "95" instead of
"1995". (Year numbers below 100 are incremented by 1900.)

Any number of non-digits (i.e., all characters NOT in [0-9]) may precede
the number of the day and follow the number of the year.

Any number of non-alphanumeric characters (i.e., all characters NOT in
[A-Za-z0-9]) may separate the number of the day and the month and the
month and the number of the year.

If after removing the preceding and trailing non-digit characters the
string consists only of digits, it is automatically mapped to the day,
month and year depending on its length, as intuitively as possible, as
follows:

     Length:        Mapping:
       3              dmy
       4              dmyy
       5              dmmyy
       6              ddmmyy
       7              dmmyyyy
       8              ddmmyyyy

Example:

All the following strings will be recognized as "January 3rd 1964":

     3.1.64
     3 1 64
     			 03.01.64
     			 03/01/64
     			3. Jan 1964
     			3. Jan '64
     			 03-Jan-64
     			 3.Jan1964
     3Jan64
      3ja64
      3164

If the function is unable to extract a valid date from its input, it
returns an empty list.


=================================
---------------------------------


`$days = days_in_month($year,$mm);'
-----------------------------------


=================================
---------------------------------

This function accesses the internal table of the months' lengths and
returns the length in days of the given month "$mm" in the given year
"$year".

It is necessary to specify the year "$year" since the length of the
month february is 29 instead of 28 in leap years.

This function is useful, for example, to calculate the last day of a
month or the last working-day (payday!) of a month.

Last working-day of the month (legal holidays not taken into account):

     $dd = days_in_month($year,$mm);
     $dw = day_of_week($year,$mm,$dd) - 1;
     if ($dw > 4)
     {
         ($year,$mm,$dd) = calc_new_date($year,$mm,$dd,4-$dw);
     }

Last working-day of the month (legal holidays taken into account):

(assuming that the array `$holiday[$year][$mm][$dd] = 1;' contains all
legal holidays)

     $dd = days_in_month($year,$mm);
     while (1)
     {
         while ($holiday[$year][$mm][$dd])
         {
             ($year,$mm,$dd) = calc_new_date($year,$mm,$dd,-1);
         }
         $dw = day_of_week($year,$mm,$dd) - 1;
         if ($dw > 4)
         {
             ($year,$mm,$dd) = calc_new_date($year,$mm,$dd,4-$dw);
         }
         else { last; }
     }

The value of "$mm" is taken modulo 13 (!) internally to prevent
out-of-range access to the internal array.

The values the internal array contains are the following:

     normal             leap
      month             year              year

     0                 0                 0
     1                31                31
     2                28                29
     3                31                31
     4                30                30
     5                31                31
     6                30                30
     7                31                31
     8                31                31
     9                30                30
     	  10                31                31
     	  11                30                30
     	  12                31                31


=====================================
-------------------------------------


`$version = Date::DateCalc::Version();'
---------------------------------------


=====================================
-------------------------------------

This function returns a string with the (numeric) version number of the
"DateCalc" extension package.

Since this function is not exported, you always have to qualify it
explicitly (i.e., "`Date::DateCalc::Version()'").

This is to avoid possible conflicts with version functions from other
packages.


EXAMPLE
=======

     #!perl -w

     use strict;
     no strict "vars";

     use Date::DateCalc qw(decode_date date_to_short dates_difference);

     print "\n";

     $ok = 0;
     while (! $ok)
     {
         print "Please enter the date of your birthday (day-month-year): ";
         $date = <STDIN>;
         print "\n";
         if (($yy1,$mm1,$dd1) = decode_date($date))
         {
             $datestr = date_to_short($yy1,$mm1,$dd1);
             print "Your date is: $datestr\n";
             print "\n";
             print "Is that correct? (Yes/No) ";
             $response = <STDIN>;
             print "\n";
             $ok = ($response =~ /^Y/i);
         }
     }
     print "Your birthday is: $datestr\n";
     print "\n";

     $ok = 0;
     while (! $ok)
     {
         print "Please enter today's date (day-month-year): ";
         $date = <STDIN>;
         print "\n";
         if (($yy2,$mm2,$dd2) = decode_date($date))
         {
             $datestr = date_to_short($yy2,$mm2,$dd2);
             print "Your date is: $datestr\n";
             print "\n";
             print "Is that correct? (Yes/No) ";
             $response = <STDIN>;
             print "\n";
             $ok = ($response =~ /^Y/i);
         }
     }
     print "Today's date is: $datestr\n";
     print "\n";

     $days = dates_difference($yy1,$mm1,$dd1,$yy2,$mm2,$dd2);
     print "You are $days days old.\n";
     print "\n";

     __END__


SEE ALSO
========

Date::DateCalcLib(3), perl(1), perlsub(1), perlmod(1), perlxs(1),
perlxstut(1), perlguts(1).


VERSION
=======

This man page documents "Date::DateCalc" version 3.2.


AUTHOR
======

Steffen Beyer <sb@sdm.de>.


COPYRIGHT
=========

Copyright (c) 1995, 1996, 1997 by Steffen Beyer. All rights reserved.


LICENSE
=======

This package is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.




File: pm.info, Node: Date/DateCalcLib, Next: Date/Format, Prev: Date/DateCalc, Up: Module List

Date Calculations Library
*************************



NAME
====

Date::DateCalcLib - Date Calculations Library

Library of useful date calculation functions


SYNOPSIS
========

   * `use Date::DateCalcLib qw( nth_wday_of_month_year' `decode_date_us
     decode_date_eu year_month_day_offset' `parse_date easter_sunday
     calendar );'

   * `use Date::DateCalcLib qw(:all);'

   * `($year,$mm,$dd) =
     nth_wday_of_month_year($nth,$wday,$month,$year);'

   * `($year,$mm,$dd) = decode_date_us($date);'

   * `($year,$mm,$dd) = decode_date_eu($date);'

   * `($year,$mm,$dd) =
     year_month_day_offset($year,$mm,$dd,$y_offs,$m_offs,$d_offs);'

   * `($year,$mm,$dd) = parse_date(`/bin/date`);'

   * `($year,$mm,$dd) = easter_sunday($year);'

   * `$string = calendar($year,$month);'


DESCRIPTION
===========

This module expands the functionality of the "Date::DateCalc" module
(see `Date::DateCalc(3)' in this node for more details), which is
intended to be a rather basic set of tools, with functions for various
special tasks like:

   * calculating the n-th weekday for a given month and year

   * parsing dates in U.S. american and european format

   * calculating a new date with a year, month and/or day offset

   * parsing the current date or the submission date of an e-mail
     message

   * calculating easter sunday and all the related christian feast days

   * printing a calendar for a given month and year

For a detailed description of each function, see below:

   * `use Date::DateCalcLib qw( nth_wday_of_month_year' `decode_date_us
     decode_date_eu year_month_day_offset' `parse_date easter_sunday
     calendar );'

     Use this statement to make the functions of this module available
     in your module or script.

     You can also use any subset of the functions listed above that you
     like by only including the names of the functions you actually need
     between the parentheses of the "qw()" operator above.

   * `use Date::DateCalcLib qw(:all);'

     Alternate and simpler way of importing ALL the functions exported
     by this module into your module or script.

   * `($year,$mm,$dd) =
     nth_wday_of_month_year($nth,$wday,$month,$year);'

     This function calculates the n-th weekday for a given month and
     year, for example the 3rd Thursday of a given month and year.

     "`$nth'" must be in the range 1 to 5 (for "the first" to "the
     fifth"), "`$wday'" must be in the range 1 to 7 (1 = Monday, 7 =
     Sunday), "`$month'" must (of course) be in the range 1 to 12 and
     "`$year'" must be greater than zero.

     The function returns an empty list if any of its parameters is
     illegal or if the requested date cannot be calculated (for
     instance, if there is no fifth "`$wday'" in the given month and
     year!).

     Example:

     Suppose you have a meeting (of some user group, for instance) in
     regular intervals, let's say the first Friday of each month, and
     that you want to send a mail to all members saying: "Remember:
     Tomorrow is our user group's meeting!" on the day before.

     Given the current date, you would go about this as follows:

     Convert the current date into days using the function "calc_days()"
     of the "Date::DateCalc" module. We'll refer to this number as "the
     number of days of the current date" below.

     Calculate the first Friday of the current month.

     Convert the resulting date into days using the function
     "calc_days()" of the "Date::DateCalc" module.

     See if the number of days of the current date *plus one* is the
     same as the number of days of the first Friday of the current
     month.

     If so, send your mail!

     If not, calculate the first Friday of the NEXT month (beware: if
     the month is equal to 12, you need to "wrap" it back to 1 and to
     increment the year number!).

     (This is necessary because the first Friday of any given month
     could fall on the first day of that month, which means that the day
     before that (when you want to send your mail!) is in the PREVIOUS
     month!)

     Convert the resulting date into days using the function
     "calc_days()" of the "Date::DateCalc" module.

     See if the number of days of the current date *plus one* is the
     same as the number of days of the first Friday of the next month.

     If so, send your mail!

     If not, you're done for today!

     (On a UNIX system, you would normally use a "cron" job running once
     every day to automatically carry out these calculations and to send
     the reminder mail.)

   * `($year,$mm,$dd) = decode_date_us($date);'

     Using this function, you can parse dates in almost any format,
     provided the date is given as "month - day - year".

     (To decode dates in european format, i.e., dates given as "day -
     month - year", see the function "decode_date_eu()" in this module
     or the function "decode_date()" in the "Date::DateCalc" module.)

     The day and the year must be given as numbers, the month may be
     specified either by a number or its name in English (however, only
     up to the 3 first characters are compared, any extra characters are
     ignored). The latter comparison is carried out in a
     case-insensitive manner.

     If they uniquely identify the month, one or two letters are
     sufficient (e.g., "s" for september or "ja" for january).

     The year may be abbreviated as well, for instance "97" instead of
     "1997". (Year numbers below 100 are incremented by 1900.)

     Note that leading zeros are ignored for all numeric values (=
     contiguous strings of digits).

     If the month given in the input string isn't numeric, any number of
     non-alphanumeric characters (i.e., all characters NOT in
     [A-Za-z0-9]) may precede and follow the month, and any number of
     non-digits (i.e., all characters NOT in [0-9]) may precede and
     follow the year.

     If separating non-digits between the day and year are missing, the
     string of digits following the month is automatically mapped to the
     day and year depending on its length, as intuitively as possible,
     as follows:

          Length:        Mapping:
            2              dy
            3              dyy
            4              ddyy
            5              dyyyy
            6              ddyyyy

     If the month given in the input string is numeric, any number of
     non-digits may precede the month, separate the month from the day
     and the day from the year, and follow the year.

     If separating non-digits are missing, the string of digits
     contained in the input string is automatically mapped to the month,
     day and year depending on its length, as intuitively as possible,
     as follows:

          Length:        Mapping:
            3              mdy
            4              mdyy
            5              mddyy
            6              mmddyy
            7              mddyyyy
            8              mmddyyyy

     Example:

     All the following strings will be recognized as "January 3rd 1964":

          1 3 64
          1.3.64
          		     01.03.64
          		     01/03/64
          		    Jan 3 1964
          		 January 3rd, 1964
          		    Jan 3. '64
          		     Jan-3-64
          		     Jan3.1964
           ja364
           1364

     If no valid date can be derived from the input string, the function
     returns an empty list.

   * `($year,$mm,$dd) = decode_date_eu($date);'

     Using this function, you can parse dates in almost any format,
     provided the date is given as "day - month - year".

     (To decode dates in U.S. american format, i.e., dates given as
     "month - day - year", see the function "decode_date_us()" in this
     module.)

     The day and the year must be given as numbers, the month may be
     specified either by a number or its name in English (however, only
     up to the 3 first characters are compared, any extra characters are
     ignored). The latter comparison is carried out in a
     case-insensitive manner.

     If they uniquely identify the month, one or two letters are
     sufficient (e.g., "s" for september or "ja" for january).

     The year may be abbreviated as well, for instance "97" instead of
     "1997". (Year numbers below 100 are incremented by 1900.)

     Note that this function is a little more flexible than the function
     "decode_date()" in the "Date::DateCalc" module since it allows any
     number of leading zeros for numeric values and any number of
     letters for the name of the month.

     If the month given in the input string isn't numeric, any number of
     non-alphanumeric characters (i.e., all characters NOT in
     [A-Za-z0-9]) may precede and follow the month (separating it from
     the day and the year), and any number of non-digits (i.e., all
     characters NOT in [0-9]) may precede the day and follow the year.

     If the month given in the input string is numeric, any number of
     non-digits may precede the day, separate the day from the month and
     the month from the year, and follow the year.

     In the latter case, if separating non-digits are missing, the
     string of digits contained in the input string is automatically
     mapped to the day, month and year depending on its length, as
     intuitively as possible, as follows:

          Length:        Mapping:
            3              dmy
            4              dmyy
            5              dmmyy
            6              ddmmyy
            7              dmmyyyy
            8              ddmmyyyy

     Example:

     All the following strings will be recognized as "January 3rd 1964":

          3.1.64
          3 1 64
          		     03.01.64
          		     03/01/64
          		    3. Jan 1964
          		  3 January 1964
          		    3. Jan '64
          		     03-Jan-64
          		     3.Jan1964
          3Jan64
           3ja64
           3164

     If no valid date can be derived from the input string, the function
     returns an empty list.

   * `($year,$mm,$dd) =
     year_month_day_offset($year,$mm,$dd,$y_offs,$m_offs,$d_offs);'

     Many people have asked for a function to calculate a new date,
     starting with a given date and a year, month and/or day offset. So
     here it is!

     Note that all parameters must be integers.

     The function ensures this by applying the "int()" function to every
     parameter.

     An empty list is returned if the given date or any (intermediate or
     final) result is invalid.

     Note that the day offset is added first using the "calc_new_date()"
     function of the "Date::DateCalc" module (see `Date::DateCalc(3)' in
     this node).

     Beware that an empty list is returned if this intermediate result
     is not a valid date!

     After this, the month offset is added and finally the year offset
     (with a possible carry over from the month) is added.

     Note that all three offsets may have any (integer) value (provided
     that all (intermediate or final) results are valid dates) and any
     sign (independently from each other!).

     If the final result happens to be the 29th of February in a
     non-leap year, it is substituted by the 1st of March.

     BEWARE that because the three offsets are always applied in the
     same order, and also because of the substitution mentioned above,
     the transformation calculated by this function is NOT REVERSIBLE,
     in general!

     (Unlike the "calc_new_date()" function of the "Date::DateCalc"
     module!)

     I.e.,

          ($year,$mm,$dd) =
          year_month_day_offset(
          year_month_day_offset($year,$mm,$dd, $y_offs,$m_offs,$d_offs),
          -$y_offs,-$m_offs,-$d_offs);

     will not, in general, return the original date!

     In the formula above, in order to reverse the effect of the first
     call to "year_month_day_offset()", the offsets do not only need to
     have the opposite sign, but they would also need to be applied in
     reverse order in the second call to "year_month_day_offset()"!

   * `($year,$mm,$dd) = parse_date($date);'

     This function is a (special!) relative of the "decode_date_us()"
     and "decode_date_eu()" function.

     In contrast to the "decode_date_us()" and "decode_date_eu()"
     function, however, the month is required to be a three-letter
     abbreviation of the month's name (in English).

     Moreover, the month's name is required to be followed by the day's
     number, separated by whitespace.

     Another restriction is that year numbers must lie in the range 1900
     to 2099.

     In compensation, the year number may come before or after the
     month/day pair.

     This function is especially designed to parse dates returned by the
     UNIX "date" command:

@asis{}
     
     `- 'Parse today's date:

          ($year,$mm,$dd) = parse_date(`/bin/date`);

@asis{}
     
     `- 'Parse date of submission of an e-mail:

          while (<MAIL>)
          {
              if (/^From \S/)
              {
                  ($year,$mm,$dd) = parse_date($_);
                  ...
              }
              ...
          }

@asis{}
     
     The function returns an empty list if it can't extract a valid date
     from the input string.

   * `($year,$mm,$dd) = easter_sunday($year);'

     Calculates the date of easter sunday for years in the range 1583 to
     2299 using Gauss' Rule.

     Returns an empty list for all arguments outside this range.

     Other christian feast days depend on easter sunday and can be
     calculated using the function "calc_new_date()" of the
     "Date::DateCalc" module (see `Date::DateCalc(3)' in this node for
     more info) as follows:

@asis{}
     
     `* 'Easter Sunday - 48

          ($year,$mm,$dd) = calc_new_date(easter_sunday($year),-48);

          Carnival Monday / Rosenmontag / Veille du Mardi Gras

@asis{}
     
     `* 'Easter Sunday - 47

          ($year,$mm,$dd) = calc_new_date(easter_sunday($year),-47);

          Mardi Gras / Faschingsdienstag, Karnevalsdienstag / Mardi Gras

@asis{}
     
     `* 'Easter Sunday - 46

          ($year,$mm,$dd) = calc_new_date(easter_sunday($year),-46);

          Ash Wednesday / Aschermittwoch / Mercredi des Cendres

@asis{}
     
     `* 'Easter Sunday - 7

          ($year,$mm,$dd) = calc_new_date(easter_sunday($year),-7);

          Palm Sunday / Palmsonntag / Dimanche des Rameaux

@asis{}
     
     `* 'Easter Sunday - 2

          ($year,$mm,$dd) = calc_new_date(easter_sunday($year),-2);

          Easter Friday / Karfreitag / Vendredi Saint

@asis{}
     
     `* 'Easter Sunday - 1

          ($year,$mm,$dd) = calc_new_date(easter_sunday($year),-1);

          Easter Saturday / Ostersamstag / Samedi de Paques

@asis{}
     
     `* 'Easter Sunday + 1

          ($year,$mm,$dd) = calc_new_date(easter_sunday($year),1);

          Easter Monday / Ostermontag / Lundi de Paques

@asis{}
     
     `* 'Easter Sunday + 39

          ($year,$mm,$dd) = calc_new_date(easter_sunday($year),39);

          Ascension of Christ / Christi Himmelfahrt / Ascension

@asis{}
     
     `* 'Easter Sunday + 49

          ($year,$mm,$dd) = calc_new_date(easter_sunday($year),49);

          Whitsunday / Pfingstsonntag / Dimanche de Pentecote

@asis{}
     
     `* 'Easter Sunday + 50

          ($year,$mm,$dd) = calc_new_date(easter_sunday($year),50);

          Whitmonday / Pfingstmontag / Lundi de Pentecote

@asis{}
     
     `* 'Easter Sunday + 60

          ($year,$mm,$dd) = calc_new_date(easter_sunday($year),60);

          Feast of Corpus Christi / Fronleichnam / Fete-Dieu

@asis{}
     
     For more information about easter sunday and how to calculate it,
     see also on USENET in news.answers

          Calendar FAQ, v. 1.6 (modified 26 Dec 1996) Part 1/3
          Calendar FAQ, v. 1.6 (modified 26 Dec 1996) Part 2/3
          Calendar FAQ, v. 1.6 (modified 26 Dec 1996) Part 3/3

     or

          http://www.math.uio.no/faq/calendars/faq.html

     or

          http://www.pip.dknet.dk/~pip10160/calendar.html

     All authored by

          Claus Tondering <c-t@pip.dknet.dk>

   * `$string = calendar($year,$month);'

     This function returns a string containing a calendar for the given
     month and year (which looks pretty much like the output of the UNIX
     "cal" command).

     The calendar is not printed directly but rather returned as a
     string in order to make post-processing possible, i.e., like
     staggering multiple month calendars together on one page to produce
     a calendar of a complete year, or transforming the day numbers into
     hyperlinks for incorporation of the calendar (with clickable day
     numbers) into an HTML page.

     The function returns an empty list if the given month or year is
     invalid.


SEE ALSO
========

Date::DateCalc(3).


VERSION
=======

This man page documents "Date::DateCalcLib" version 3.2.


AUTHOR
======

Steffen Beyer <sb@sdm.de>.


COPYRIGHT
=========

Copyright (c) 1997 by Steffen Beyer. All rights reserved.


LICENSE
=======

This package is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.




