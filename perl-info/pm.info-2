Info file: pm.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `bigpm.texi'
using `texinfmt.el' version 2.32 of 19 November 1993.





File: pm.info, Node: Apache, Next: Apache/AuthenDBI, Prev: AnyDBM_File, Up: Module List

Perl interface to the Apache server API
***************************************



NAME
====

Apache - Perl interface to the Apache server API


SYNOPSIS
========

     use Apache ();


DESCRIPTION
===========

This module provides a Perl interface the Apache API.  It is here mainly
for *mod_perl*, but may be used for other Apache modules that wish to
embed a Perl interpreter.  We suggest that you also consult the
description of the Apache C API at http://www.apache.org/docs/.


THE REQUEST OBJECT
==================

The request object holds all the information that the server needs to
service a request.  Apache *Perl*Handler*s will be given a reference to
the request object as parameter and may choose update or use it in
various ways.  Most of the methods described below obtain information
from or updates the request object.  The perl version of the request
object will be blessed into the *Apache* package, it is really a
`request_rec *' in disguise.

Apache->request([$r])
     The Apache->request method will return a reference to the request
     object.

     *Perl*Handler*s can obtain a reference to the request object when it
     is passed to them via `@_'.  However, scripts that run under 
     *Note Apache/Registry: Apache/Registry,, for example, need a way to access the request object.
     *Note Apache/Registry: Apache/Registry, will make a request object availible to these scripts
     by passing an object reference to `Apache->request($r)'.  If
     handlers use modules such as `CGI::Apache' that need to access
     `Apache->request' in this node, they too should do this
     (e.g. Apache::Status).

$r->as_string
     Returns a string representation of the request object.

$r->main
     If the current request is a sub-request, this method returns a
     blessed reference to the main request structure.

$r->prev
     This method returns a blessed reference to the previous (internal)
     request structure.

$r->next
     This method returns a blessed reference to the next (internal)
     request structure.

$r->is_main
     Returns true if the current request object is for the main request.

$r->is_initial_req
     Returns true if the current request is the first internal request,
     returns false if the request is a sub-request or interal redirect.


SUB REQUESTS
============

Apache provides a sub-request mechanism to lookup a uri or filename,
preforming all access checks, etc., without actually running the
response phase of the given request.  Notice, we have dropped the
`sub_req_' prefix here.  The `request_rec *' returned by the lookup
methods is blessed into the *Apache::SubRequest* class.  This way,
`destroy_sub_request()' is called automatically during
`Apache::SubRequest-'DESTROY> when the object goes out of scope.  The
*Apache::SubRequest* class inherits all the methods from the
*Apache* class.

$r->lookup_uri($uri)
          my $subr = $r->lookup_uri($uri); my $filename = $subr->filename;

          unless(-e $filename) {
             warn "can't stat $filename!\n";
          } 

$r->lookup_file($filename)
          my $subr = $r->lookup_file($filename);

$subr->run
          if($subr->run != OK) {
              $subr->log_error("something went wrong!");
          }


CLIENT REQUEST PARAMETERS
=========================

First we will take a look at various methods that can be used to
retrieve the request parameters sent from the client.
In the following examples, *$r* is a request object blessed into the 
*Apache* class, obtained by the first parameter passed to a handler subroutine
or *Apache->request*

$r->method( [$meth] )
     The $r->method method will return the request method.  It will be a
     string such as "GET", "HEAD" or "POST".  Passing an argument will
     set the method, mainly used for internal redirects.

$r->method_number( [$num] )
     The $r->method_number method will return the request method number.
     Each number corresponds to a string representation such as "GET",
     "HEAD" or "POST".  Passing an argument will set the method_number,
     mainly used for internal redirects and testing authorization
     restriction masks.

$r->the_request
     The request line send by the client, handy for logging, etc.

$r->proxyreq
     Returns true if the request is proxy http.  Mainly used during the
     filename translation stage of the request, which may be handled by
     a `PerlTransHandler'.

$r->header_only
     Returns true if the client is asking for headers only, e.g. if the
     request method was HEAD.

$r->protocol
     The $r->protocol method will return a string identifying the
     protocol that the client speaks.  Typical values will be "HTTP/1.0"
     or "HTTP/1.1".

$r->uri( [$uri] )
     The $r->uri method will return the requested URI, optionally
     changing it with the first argument.

$r->filename( [$filename] )
     The $r->filename method will return the result of the *URI -->
     filename* translation, optionally changing it with the first
     argument if you happen to be doing the translation.

$r->path_info( [$path_info] )
     The $r->path_info method will return what is left in the path after the
     *URI --> filename* translation, optionally changing it with the first 
     argument if you happen to be doing the translation.

$r->args
     The $r->args method will return the contents of the URI *query
     string*.  When called in a scalar context, the entire string is
     returned.  When called in a list context, a list of parsed key =>
     value pairs are returned, i.e. it can be used like this:

          $query = $r->args;
          %in    = $r->args;

$r->headers_in
     The $r->headers_in method will return a %hash of client request
     headers.  This can be used to initialize a perl hash, or one could
     use the $r->header_in() method (described below) to retrieve a
     specific header value directly.

$r->header_in( $header_name, [$value] )
     Return the value of a client header.  Can be used like this:

          $ct = $r->header_in("Content-type");

          $r->header_in($key, $val); #set the value of header '$key'

$r->content
     The $r->content method will return the entity body read from the
     client, but only if the request content type is
     `application/x-www-form-urlencoded'.  When called in a scalar
     context, the entire string is returned.  When called in a list
     context, a list of parsed key => value pairs are returned.  *NOTE*:
     you can only ask for this once, as the entire body is read from the
     client.

$r->read_client_block($buf, $bytes_to_read)
     Read from the entity body sent by the client.  Example of use:

          $r->read_client_block($buf, $r->header_in('Content-length'));

$r->read($buf, $bytes_to_read)
     This method uses read_client_block() to read data from the client,
     looping until it gets all of `$bytes_to_read' or a timeout happens.

     In addition, this method sets a timeout before reading with
     `$r->hard_timeout'

$r->get_remote_host
     Lookup the client's DNS hostname. If the configuration directive
     *HostNameLookups* is set to off, this returns the dotted decimal
     representation of the client's IP address instead. Might return
     undef if the hostname is not known.

$r->get_remote_logname
     Lookup the remote user's system name.  Might return undef if the
     remote system is not running an RFC 1413 server or if the
     configuration directive *IdentityCheck* is not turned on.

More information about the client can be obtained from the
*Apache::Connection* object, as described below.

$c = $r->connection
     The $r->connection method will return a reference to the request
     connection object (blessed into the *Apache::Connection* package).
     This is really a `conn_rec*' in disguise.  The following methods
     can be used on the connection object:

     $c->remote_host
          If the configuration directive *HostNameLookups* is set to on:
          then the first time `$r->get_remote_host' is called the server
          does a DNS lookup to get the remote client's host name.  The
          result is cached in `$c->remote_host' then returned. If the
          server was unable to resolve the remote client's host name
          this will be set to "". Subsequent calls to
          `$r->get_remote_host' return this cached value.

          If the configuration directive *HostNameLookups* is set to
          off: calls to `$r->get_remote_host' return a string that
          contains the dotted decimal representation of the remote
          client's IP address. However this string is not cached, and
          `$c->remote_host' is undefined. So, it's best to to call
          `$r->get_remote_host' instead of directly accessing this
          variable.

     $c->remote_ip
          The dotted decimal representation of the remote client's IP
          address.  This is set by then server when the connection
          record is created so is always defined.

     $c->local_addr
          A packed SOCKADDR_IN in the same format as returned by
          `pack_sockaddr_in', *Note Socket: Socket,, containing the port
          and address on the local host that the remote client is
          connected to.  This is set by the server when the connection
          record is created so it is always defined.

     $c->remote_addr
          A packed SOCKADDR_IN in the same format as returned by
          `pack_sockaddr_in', *Note Socket: Socket,, containig the port
          and address on the remote host that the server is connected
          to.  This is set by the server when the connection record is
          created so it is always defined.

          Among other things, this can be used, together with
          $c->local_addr, to perform RFC1413 ident lookups on the remote
          client even when the configuration directive *IdentityCheck*
          is turned off.

          Can be used like:

               use Net::Ident qw (lookupFromInAddr);
               ...
               my $remoteuser = lookupFromInAddr ($c->local_addr,
                                                  $c->remote_addr, 2);

          Note that the lookupFromInAddr interface does not currently
          exist in the `Net::Ident' module, but the author is planning
          on adding it soon.

     $c->remote_logname
          If the configuration directive *IdentityCheck* is set to on:
          then the first time `$r->get_remote_logname' is called the
          server does an RFC 1413 (ident) lookup to get the remote
          user's system name. Generally for UNI* systems this is their
          login. The result is cached in `$c-'remote_logname> then
          returned.  Subsequent calls to `$r->get_remote_host' return
          the cached value.

          If the configuration directive *IdentityCheck* is set to off:
          then `$r->get_remote_logname' does nothing and
          `$c->remote_logname' is always undefined.

     $c->user
          If an authentication check was successful, the authentication
          handler caches the user name here.

     $c->auth_type
          Returns the authentication scheme that successfully
          authenticate `$c->user', if any.

     $c->aborted
          Returns true if the client stopped talking to us.


SERVER CONFIGURATION INFORMATION
================================

The following methods are used to obtain information from server
configuration and access control files.

$r->dir_config( $key )
     Returns the value of a per-directory variable specified by the
     `PerlSetVar' directive.

          #<Location /foo/bar>
          #SetPerlVar  Key  Value
          #</Location>

          my $val = $r->dir_config('Key');

$r->requires
     Returns an array reference of hash references, containing
     information related to the require directive.  This is normally
     used for access control, see `Apache::AuthzAge' in this node for an
     example.

$r->auth_type
     Returns a reference to the current value of the per directory
     configuration directive *AuthType*. Normally this would be set to
     Basic to use the basic authentication scheme defined in RFC 1945,
     *Hypertext Transfer Protocol -- HTTP/1.0*. However, you could set to
     something else and implement your own authentication scheme.

$r->auth_name
     Returns a reference to the current value of the per directory
     configuration directive *AuthName*.  The AuthName directive creates
     protection realm within the server's document space. To quote RFC
     1945 "These realms allow the protected resources on a server to be
     partitioned into a set of protection spaces, each with its own
     authentication scheme and/or authorization database." The client
     uses the root URL of the server to determine which authentication
     credentials to send with each HTTP request. These credentials are
     tagged with the name of the authentication realm that created them.
     Then during the authentication stage the server uses the current
     authentication realm, from `$r->auth_name', to determine which set
     of credentials to authenticate.

$r->document_root
     Returns a reference to the current value of the per server
     configuration directive *DocumentRoot*. To quote the Apache server
     documentation, "Unless matched by a directive like Alias, the
     server appends the path from the requested URL to the document root
     to make the path to the document."  This same value is passed to
     CGI scripts in the `DOCUMENT_ROOT' environment variable.

$r->allow_options
     The $r->allow_options method can be used for checking if it is ok
     to run a perl script.  The *Apache::Options* module provides the
     constants to check against.

          if(!($r->allow_options & OPT_EXECCGI)) {
              $r->log_reason("Options ExecCGI is off in this directory", 
          		    $filename);
          }

$s = $r->server
     Return a reference to the server info object (blessed into the
     *Apache::Server* package).  This is really a `server_rec*' in
     disguise.  The following methods can be used on the server object:

$s->server_admin
     Returns the mail address of the person responsible for this server.

$s->server_hostname
     Returns the hostname used by this server.

$s->port
     Returns the port that this servers listens too.

$s->is_virtual
     Returns true if this is a virtual server.

$s->names
     Returns the wildcarded names for HostAlias servers.


SETTING UP THE RESPONSE
=======================

The following methods are used to set up and return the response back to
the client.  This typically involves setting up $r->status(), the
various content attributes and optionally some additional
$r->header_out() calls before calling $r->send_http_header() which will
actually send the headers to the client.  After this a typical
application will call the $r->print() method to send the response
content to the client.

$r->send_http_header
     Send the response line and all headers to the client.

     This method will create headers from the $r->content_xxx() and
     $r->no_cache() attributes (described below) and then append the
     headers defined by $r->header_out (or $r->err_header_out if status
     indicates an error).

$r->get_basic_auth_pw
     If the current request is protected by Basic authentication, this
     method will return 0, otherwise -1.  The second return value will
     be the decoded password sent by the client.

          ($ret, $sent_pw) = $r->get_basic_auth_pw;

$r->note_basic_auth_failure
     Prior to requiring Basic authentication from the client, this
     method will set the outgoing HTTP headers asking the client to
     authenticate for the realm defined by the configuration directive
     `AuthName'.

$r->handler( [$meth] )
     Set the handler for a request.  Normally set by the configuration
     directive `AddHandler'.
  
      $r->handler( "perl-script" );

$r->notes( $key, [$value] )
     Return the value of a named entry in the Apache `notes' table, or
     optionally set the value of a named entry.  This table is used by
     Apache modules to pass messages amongst themselves. Generally if
     you are writing handlers in mod_perl you can use Perl variables for
     this.

          $r->notes("MY_HANDLER", OK);

          $val = $r->notes("MY_HANDLER");

$r->content_type( [$newval] )
     Get or set the content type being sent to the client.  Content
     types are strings like "text/plain", "text/html" or "image/gif".
     This corresponds to the "Content-Type" header in the HTTP protocol.
     Example of usage is:

          $previous_type = $r->content_type;
          $r->content_type("text/plain");

$r->content_encoding( [$newval] )
     Get or set the content encoding.  Content encodings are string like
     "gzip" or "compress".  This correspond to the "Content-Encoding"
     header in the HTTP protocol.

$r->content_language( [$newval] )
     Get or set the content language.  The content language corresponds
     to the "Content-Language" HTTP header and is a string like "en" or
     "no".

$r->status( $integer )
     Get or set the reply status for the client request.  The
     *Apache::Constants* module provide mnemonic names for the status codes.

$r->status_line( $string )
     Get or set the response status line.  The status line is a string
     like "HTTP/1.0 200 OK" and it will take precedence over the value
     specified using the $r->status() described above.

$r->headers_out
     The $r->headers_out method will return a %hash of server response
     headers.  This can be used to initialize a perl hash, or one could
     use the $r->header_out() method (described below) to retrieve or
     set a specific header value directly.

$r->header_out( $header, $value )
     Change the value of a response header, or create a new one.  You
     should not define any "Content-XXX" headers by calling this method,
     because these headers use their own specific methods.  Example of
     use:

          $r->header_out("WWW-Authenticate" => "Basic");

          $val = $r->header_out($key);

$r->err_headers_out
     The $r->err_headers_out method will return a %hash of server
     response headers.  This can be used to initialize a perl hash, or
     one could use the $r->err_header_out() method (described below) to
     retrieve or set a specific header value directly.

     The difference between headers_out and err_headers_out is that the
     latter are printed even on error, and persist across internal
     redirects (so the headers printed for ErrorDocument handlers will
     have them).

$r->err_header_out( $header, [$value] )
     Change the value of an error response header, or create a new one.
     These headers are used if the status indicates an error.

          $r->err_header_out("Warning" => "Bad luck");

          $val = $r->err_header_out($key);

$r->no_cache( $boolean )
     This is a flag that indicates that the data being returned is
     volatile and the client should be told not to cache it.

$r->print( @list )
     This method sends data to the client with `$r->write_client', but
     first sets a timeout before sending with `$r->hard_timeout'.

$r->send_fd( $filehandle )
     Send the contents of a file to the client.  Can for instance be
     used like this:

          open(FILE, $r->filename) || return 404;
          $r->send_fd(FILE);
          close(FILE);

$r->internal_redirect_handler( $newplace )
     Redirect to a location in the server namespace without telling the
     client. For instance:

          $r->internal_redirect_handler("/home/sweet/home.html");


SERVER CORE FUNCTIONS
=====================

$r->soft_timeout($message)
$r->hard_timeout($message)
$r->kill_timeout
$r->reset_timeout
     (Documentation borrowed from http_main.h)

     There are two functions which modules can call to trigger a timeout
     (with the per-virtual-server timeout duration); these are
     hard_timeout and soft_timeout.

     The difference between the two is what happens when the timeout
     expires (or earlier than that, if the client connection aborts) ---
     a soft_timeout just puts the connection to the client in an
     "aborted" state, which will cause http_protocol.c to stop trying to
     talk to the client, but otherwise allows the code to continue
     normally.  hard_timeout(), by contrast, logs the request, and then
     aborts it completely -- longjmp()ing out to the accept() loop in
     http_main.  Any resources tied into the request resource pool will
     be cleaned up; everything that is not will leak.

     soft_timeout() is recommended as a general rule, because it gives
     your code a chance to clean up.  However, hard_timeout() may be the
     most convenient way of dealing with timeouts waiting for some
     external resource other than the client, if you can live with the
     restrictions.

     When a hard timeout is in scope, critical sections can be guarded
     with block_alarms() and unblock_alarms() -- these are declared in
     alloc.c because they are most often used in conjunction with
     routines to allocate something or other, to make sure that the
     cleanup does get registered before any alarm is allowed to happen
     which might require it to be cleaned up; they * are, however,
     implemented in http_main.c.

     kill_timeout() will disarm either variety of timeout.

     reset_timeout() resets the timeout in progress.

$r->register_cleanup($code_ref)
     Register a cleanup function which is called just before $r->pool is
     destroyed.

          $r->register_cleanup(sub {
              my $r = shift;
              warn "registered cleanup called for ", $r->uri, "\n";
          });


CGI SUPPORT
===========

We also provide some methods that make it easier to support the CGI type
of interface.

$r->cgi_env
     Return a %hash that can be used to set up a standard CGI
     environment.  Typical usage would be:

          %ENV = $r->cgi_env

     *NOTE:* The $ENV{GATEWAY_INTERFACE} is set to `'CGI-Perl/1.1'' so
     you can say:

          if($ENV{GATEWAY_INTERFACE} =~ /^CGI-Perl/) {
              #do mod_perl stuff
          }
          else {
             #do normal CGI stuff
          }

     When given a key => value pair, this will set an environment
     variable.

          $r->cgi_env(REMOTE_GROUP => "camels");

$r->cgi_var($key);
     Calls $r->cgi_env($key) in a scalar context to prevent the mistake
     of calling in a list context.

          my $doc_root = $r->cgi_env('DOCUMENT_ROOT');

$r->send_cgi_header()
     Take action on certain headers including *Status:*, *Location:* and
     *Content-type:* just as mod_cgi does, then calls
     $r->send_http_header().  Example of use:

          $r->send_cgi_header("
          Location: /foo/bar
          Content-type: text/html 

          ");


ERROR LOGGING
=============

The following methods can be used to log errors.

$r->log_reason($message, $file)
     The request failed, why??  Write a message to the server errorlog.

          $r->log_reason("Because I felt like it", $r->filename);

$r->log_error($message)
     Uh, oh.  Write a message to the server errorlog.

          $r->log_error("Some text that goes in the error_log");

$r->warn($message)
     An alias for Apache->log_error.


UTILITY FUNCTIONS
=================

Apache::unescape_url($string)
     Handy function for unescapes.  Use this one for filenames/paths.
     Use unescape_url_info for the result of submitted form data.

Apache::unescape_url_info($string)
     Handy function for unescapes submitted form data.  In opposite to
     unescape_url it translates the plus sign to space.

Apache::perl_hook($hook)
     Test to see if a callback hook is enabled

          for (qw(Access Authen Authz ChildInit Cleanup Fixup HeaderParser Init Log Trans Type)) {
             print "$_ hook enabled\n" if Apache::perl_hook($_);
          }  


SEE ALSO
========

perl(1), Apache::Constants(3), Apache::Registry(3), Apache::Debug(3),
Apache::Options(3), CGI::Apache(3),


AUTHORS
=======

Gisle Aas <aas@sn.no> and Doug MacEachern <dougm@osf.org>




File: pm.info, Node: Apache/AuthenDBI, Next: Apache/AuthzDBI, Prev: Apache, Up: Module List

Authentication via Perl's DBI
*****************************



NAME
====

Apache::AuthenDBI - Authentication via Perl's DBI


SYNOPSIS
========

     # Configuration in httpd.conf or srm.conf:

     PerlModule Apache::AuthenDBI

     # Authentication in .htaccess:

     AuthName DBI
     AuthType Basic

     #authenticate via DBI
     PerlAuthenHandler Apache::AuthenDBI

     PerlSetVar Auth_DBI_data_source   dbi:driver:dsn
     PerlSetVar Auth_DBI_username      db_username
     PerlSetVar Auth_DBI_password      db_password
     #DBI->connect($data_source, $username, $password)

     PerlSetVar Auth_DBI_pwd_table     users
     PerlSetVar Auth_DBI_uid_field     username
     PerlSetVar Auth_DBI_pwd_field     password
     #SELECT pwd_field FROM pwd_table WHERE uid_field=$user

     <Limit GET>
     require valid-user
     </Limit>

The AuthType is limited to Basic. The require directive is limited to
'valid-user' and 'user user_1 user_2 ...'. For group support see
AuthzDBI.pm.


DESCRIPTION
===========

This module allows authentication against a database using Perl's DBI.
For supported DBI drivers see:

     http://www.hermetica.com/technologia/DBI/

For the given username the password is looked up in the database.

If the username does not exist and the authoritative directive is set to
'on', the request is rejected. If the authoritative directive is set to
'off', the control is passed on to next module in line.

If the password for the given username is empty and the nopasswd
directive is set to 'off', the request is rejected. If the nopasswd
directive is set to 'on', any password is accepted.

Finally the password retrieved from the database is compared to the
password given. If the encrypted directive is set to 'on', the given
password is encrypted using perl's crypt() function before
comparison. If the encrypted directive is set to 'off' the plain-text
passwords are compared.

If this comparison fails the request is rejected, otherwise the request
is accepted.

This module supports in addition a simple kind of logging
mechanism. Whenever the handler is called and a log_string is
configured, the log_field will be updated with the log_string. As
log_string - depending upon the database - macros like TODAY can be
used.


LIST OF TOKENS
==============

   * Auth_DBI_data_source

     The data_source value should begin with 'dbi:driver_name:'. This
     value (with the 'dbi:...:' prefix removed) is passed to the
     database driver for processing during connect.

   * Auth_DBI_username

     The username argument is passed to the database driver for
     processing during connect.

   * Auth_DBI_password

     The password argument is passed to the database driver for
     processing during connect.

   * Auth_DBI_pwd_table

     Contains at least the fields with the username and the (encrypted)
     password.  The username should be unique.

   * Auth_DBI_uid_field

     Field name containing the username in the Auth_DBI_pwd_table.

   * Auth_DBI_pwd_field

     Field name containing the password in the Auth_DBI_pwd_table.

   * Auth_DBI_log_field

     Field name containing the log string in the Auth_DBI_pwd_table.

   * Auth_DBI_log_string

     String to update the Auth_DBI_log_field in the
     Auth_DBI_pwd_table. Depending upon the database this can be a macro
     like 'TODAY'.

   * Auth_DBI_authoritative  < on / off>

     Default is 'on'. When set 'on', there is no fall-through to other
     authentication methods if the authentication check fails. When this
     directive is set to 'off', control is passed on to any other
     authentication modules. Be sure you know what you are doing when
     you decide to switch it off.

   * Auth_DBI_nopasswd  < on / off >

     Default is 'off'. When set 'on' the password comparison is skipped
     if the Auth_DBI_pwd_field is empty, i.e. allow any password. This
     is 'off' by default to ensure that an empty Auth_DBI_pwd_field does
     not allow people to log in with a random password. Be sure you know
     what you are doing when you decide to switch it on.

   * Auth_DBI_encrypted  < on / off >

     Default is 'on'. When set 'on', the value in the Auth_DBI_pwd_field
     is assumed to be crypted using perl's crypt() function and the
     incoming password is crypted before comparison. When this directive
     is set to 'off', the comparison is done directly with the
     plain-text entered password.


CONFIGURATION
=============

The module should be loaded upon startup of the Apache daemon.  Add the
following line to your httpd.conf or srm.conf:

     PerlModule Apache::AuthenDBI


PREREQUISITES
=============

For AuthenDBI you need to enable the appropriate call-back hook when
making mod_perl:

     perl Makefile.PL PERL_AUTHEN=1. 


SEE ALSO
========

*Note Apache: Apache,, `mod_perl' in this node, *Note DBI: DBI,


AUTHORS
=======

   * mod_perl by Doug MacEachern <dougm@osf.org>
   * DBI by Tim Bunce <Tim.Bunce@ig.co.uk>
   * Apache::AuthenDBI by Edmund Mergl <E.Mergl@bawue.de>

COPYRIGHT
=========


The Apache::AuthenDBI module is free software; you can redistribute it
and/or modify it under the same terms as Perl itself.




File: pm.info, Node: Apache/AuthzDBI, Next: Apache/Constants, Prev: Apache/AuthenDBI, Up: Module List

Authorization via Perl's DBI
****************************



NAME
====

Apache::AuthzDBI - Authorization via Perl's DBI


SYNOPSIS
========

     # Configuration in httpd.conf or srm.conf:

     PerlModule Apache::AuthzDBI

     # Authorization in .htaccess:

     AuthName DBI
     AuthType Basic

     #authorize via DBI
     PerlAuthzHandler Apache::AuthzDBI

     PerlSetVar Auth_DBI_data_source   dbi:driver:dsn
     PerlSetVar Auth_DBI_username      db_username
     PerlSetVar Auth_DBI_password      db_password
     #DBI->connect($data_source, $username, $password)

     PerlSetVar Auth_DBI_grp_table     users
     PerlSetVar Auth_DBI_uid_field     username
     PerlSetVar Auth_DBI_grp_field     groupname
     #SELECT grp_field FROM grp_table WHERE uid_field=$user AND grp_field=$group

     <Limit GET>
     require user   user_1  user_2 ...
     require group group_1 group_2 ...
     </Limit>

The AuthType is limited to Basic. You may use one or more valid require
lines. For a single require line with the tokens valid-user or with
distinct user names it is sufficient to use only the AuthenDBI module.


DESCRIPTION
===========

This module allows authorization against a database using Perl's DBI.
For supported DBI drivers see:

     http://www.hermetica.com/technologia/DBI/

When the authorization handler is called, the authentication has already
been done. This means, that the given username/password has been
validated.

The handler analyzes and processes the requirements line by line. The
request is accepted only if all requirement lines are accepted.

In case of one or more user-names, they are compared with the given
user-name until the first match. If there is no match and the
authoritative directive is set to 'on' the request is rejected.

In case of one or more group-names, for every group the given user is
looked up in the database with the constraint, that the user must be a
member of this group. If there is no match and the authoritative
directive is set to 'on' the request is rejected.

In case of 'valid-user' the request is accepted.


LIST OF TOKENS
==============

   * Auth_DBI_data_source

     The data_source value should begin with 'dbi:driver_name:'. This
     value (with the 'dbi:...:' prefix removed) is passed to the
     database driver for processing during connect.

   * Auth_DBI_username

     The username argument is passed to the database driver for
     processing during connect.

   * Auth_DBI_password

     The password argument is passed to the database driver for
     processing during connect.

   * Auth_DBI_grp_table

     Contains at least the fields with the username and the groupname.

   * Auth_DBI_uid_field

     Field-name containing the username in the Auth_DBI_grp_table.

   * Auth_DBI_grp_field

     Field-name containing the groupname in the Auth_DBI_grp_table.

   * Auth_DBI_authoritative  < on / off>

     Default is 'on'. When set 'on', there is no fall-through to other
     authorization methods if the authorization check fails. When this
     directive is set to 'off', control is passed on to any other
     authorization modules. Be sure you know what you are doing when you
     decide to switch it off.


CONFIGURATION
=============

The module should be loaded upon startup of the Apache daemon.  It needs
the AuthenDBI module for the authentication part.  Add the following
lines to your httpd.conf or srm.conf:

     PerlModule Apache::AuthenDBI
     PerlModule Apache::AuthzDBI


PREREQUISITES
=============

For AuthzDBI you need to enable the appropriate call-back hooks when
making mod_perl:

     perl Makefile.PL PERL_AUTHEN=1 PERL_AUTHZ=1. 


SEE ALSO
========

*Note Apache: Apache,, `mod_perl' in this node, *Note DBI: DBI,


AUTHORS
=======

   * mod_perl by Doug MacEachern <dougm@osf.org>
   * DBI by Tim Bunce <Tim.Bunce@ig.co.uk>
   * Apache::AuthzDBI by Edmund Mergl <E.Mergl@bawue.de>

COPYRIGHT
=========


The Apache::AuthzDBI module is free software; you can redistribute it
and/or modify it under the same terms as Perl itself.




File: pm.info, Node: Apache/Constants, Next: Apache/DBI, Prev: Apache/AuthzDBI, Up: Module List

Constants defined in httpd.h
****************************



NAME
====

Apache::Constants - Constants defined in httpd.h


SYNOPSIS
========

     use Apache::Constants;
     use Apache::Constants ':common'; #OK,DECLINED,etc.


DESCRIPTION
===========

Server constants used by apache modules are defined in
*httpd.h*, this module gives Perl access to those constants.


AUTHORS
=======

Gisle Aas <aas@sn.no>, Doug MacEachern <dougm@osf.org> and h2xs



File: pm.info, Node: Apache/DBI, Next: Apache/DBILogin, Prev: Apache/Constants, Up: Module List

Initiate a persistent database connection
*****************************************



NAME
====

Apache::DBI - Initiate a persistent database connection


SYNOPSIS
========

     # Configuration in httpd.conf or srm.conf:

     PerlModule Apache::DBI  # this comes before all other Apache modules


DESCRIPTION
===========

This module initiates a persistent database connection.

The database access uses Perl's DBI. For supported DBI drivers see:

     http://www.hermetica.com/technologia/DBI/

When loading the DBI module (do not confuse this with the Apache::DBI
module) it looks if the environment variable GATEWAY_INTERFACE starts
with 'CGI-Perl' and if the module Apache::DBI has been loaded. In this
case every connect request will be forwarded to the Apache::DBI
module. This looks if a database handle from a previous connect request
is already stored and if this handle is still valid using the ping
method. If these two conditions are fulfilled it just returns the
database handle. If there is no appropriate database handle or if the
ping method fails, a new connection is established and the handle is
stored for later re-use. There is no need to delete the disconnect
statements from your code. They won't do anything because the
Apache::DBI module overloads the disconnect method with a NOP.

The Apache::DBI module still has a limitation: it keeps database
connections persistent on a per process basis. The problem is, if a user
accesses several times a database, the http requests will be handled
very likely by different httpd children. Every child process needs to do
its own connect. It would be nice, if all httpd children could share the
database handles. One possible solution might be a threaded Apache
version.

With this limitation in mind, there are scenarios, where the usage of
Apache::DBI.pm is depreciated. Think about a heavy loaded Web-site where
every user connects to the database with a unique userid. Every httpd
child would create many database handles each of which spawning a new
backend process.  In a short time this would kill the web server.

Another problem are timeouts: some databases disconnect the client after
a certain time of inactivity. The module tries to validate the database
handle using the new ping-method of the DBI-module. This method returns
true as default. If the database handle is not valid and the driver
module has no implementation for the ping method, you will get an error
when accessing the database. As a work-around you can try to replace the
ping method by any database command, which is cheap and safe.

This module plugs in a menu item for Apache::Status. The menu lists the
current database connections. It should be considered incomplete because
of the limitations explained above. It shows the current database
connections for one specific httpd process, the one which happens to
serve the current request. Other httpd children might have other
database connections.


CONFIGURATION
=============

The module should be loaded upon startup of the Apache daemon.  Add the
following line to your httpd.conf or srm.conf:

     PerlModule Apache::DBI

It is important, to load this module before any other Apache module !


SEE ALSO
========

*Note Apache: Apache,, `mod_perl' in this node, *Note DBI: DBI,


AUTHORS
=======

   * mod_perl by Doug MacEachern <dougm@osf.org>
   * DBI by Tim Bunce <Tim.Bunce@ig.co.uk>
   * Apache::AuthenDBI by Edmund Mergl <E.Mergl@bawue.de>

COPYRIGHT
=========


The Apache::DBI module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.




File: pm.info, Node: Apache/DBILogin, Next: Apache/Debug, Prev: Apache/DBI, Up: Module List

authenticates via a DBI connection
**********************************



NAME
====

Apache::DBILogin - authenticates via a DBI connection


SYNOPSIS
========

See the access.conf file and the documentation for Apache::AuthenDBI


DESCRIPTION
===========

<Directory /opt/www/root>

AuthName MyAuth

AuthType Basic

PerlHandler Apache::Registry::handler

PerlAuthenHandler Apache::DBILogin::handler

SetHandler perl-script
 
PerlSetVar AuthDBIDB SQLNetAlias

PerlSetVar AuthDBIDriver Oracle

Options Indexes FollowSymLinks ExecCGI

AllowOverride All
 
<Limit GET POST>

allow from all

require valid-user

satisfy all

</Limit>

</Directory>


AUTHOR
======

John Groenveld <groenvel@cse.psu.edu>




File: pm.info, Node: Apache/Debug, Next: Apache/DebugDBI, Prev: Apache/DBILogin, Up: Module List

Utilities for debugging embedded perl code
******************************************



NAME
====

Apache::Debug - Utilities for debugging embedded perl code


SYNOPSIS
========

     use Apache::Debug ();

     Apache::Debug::dump($r, SERVER_ERROR, "Uh Oh!");


DESCRIPTION
===========

This module sends what may be helpful debugging info to the client
rather that the error log.




File: pm.info, Node: Apache/DebugDBI, Next: Apache/Include, Prev: Apache/Debug, Up: Module List

Debug Apache::DBI modules
*************************



NAME
====

Apache::DebugDBI - Debug Apache::DBI modules


SYNOPSIS
========

     # Configuration in httpd.conf or srm.conf:

     PerlModule Apache::DebugDBI # this comes after all other Apache modules


DESCRIPTION
===========

This module turns on debugging output in the Apache::DBI modules.


AUTHORS
=======

Apache::DebugDBI by Edmund Mergl <E.Mergl@bawue.de>


COPYRIGHT
=========

The Apache::DebugDBI module is free software; you can redistribute it
and/or modify it under the same terms as Perl itself.




File: pm.info, Node: Apache/Include, Next: Apache/MakeCapital, Prev: Apache/DebugDBI, Up: Module List

Utilities for mod_perl/mod_include integration
**********************************************



NAME
====

Apache::Include - Utilities for mod_perl/mod_include integration


SYNOPSIS
========

     <!--#perl sub="Apache::Include" arg="/perl/ssi.pl" -->


DESCRIPTION
===========

The *Apache::Include* module provides a handler, making it simple to
include Apache::Registry scripts with the mod_include perl directive.

Apache::Registry scripts can also be used in mod_include parsed
documents using 'virtual include', however, Apache::Include is faster.


SEE ALSO
========

perl(1), mod_perl(3), mod_include


AUTHOR
======

Doug MacEachern <dougm@osf.org>




File: pm.info, Node: Apache/MakeCapital, Next: Apache/Mysql, Prev: Apache/Include, Up: Module List

convert to uppercase
********************



NAME
====

Apache::MakeCapital - convert to uppercase


SYNOPSIS
========

In the conf/access.conf file of your Apache installation add lines

     <Files *.html>
     SetHandler perl-script
     PerlHandler Apache::OutputChain Apache::MakeCapital Apache::PassHtml
     </Files>


DESCRIPTION
===========

This is a module to show the use of module *Apache::OutputChain*.
The function handler simply inserts this module into the chain.
The second parameter must be a name of this class, so that
*Apache::OutputChain* would know, whom to put into the chain.
(Currently I do not know about any better way, if you know, write me.)

The package also defines function PRINT, that will be called in the
chain. In this example, it capitalized all output being sent. This will
mess up the links (A HREF's) so is really just for illustration.


AUTHOR
======

(c) 1997 Jan Pazdziora, adelton@fi.muni.cz

at Faculty of Informatics, Masaryk University, Brno




File: pm.info, Node: Apache/Mysql, Next: Apache/Options, Prev: Apache/MakeCapital, Up: Module List

Initiate a persistent database connection to Mysql  =head1 SYNOPSIS
*******************************************************************



NAME
====

Apache::ApacheMYSQL - Initiate a persistent database connection to Mysql 
=head1 SYNOPSIS

     use Apache::Mysql;

     $dbh = Apache::Mysql->connect(...);


DESCRIPTION
===========

This module supplies a persistent database connection to Mysql. You will
need to have mysqlperl installed on your system.

This is the first version of the first module I have ever written, so
expect errors! Any feedback or suggestions are gratefully received.

All you really need is to replace Mysql with Apache::Mysql.  When
connecting to a database the module looks if a database handle from a
previous connect request is already stored. If not, a new connection is
established and the handle is stored for later re-use. The destroy
method has been intentionally left empty.


SEE ALSO
========

Apache(3), Mysql(3)


AUTHORS    MySQL and mysqlperl by Michael (Monty) Widenius <month@tcx.se>   mod_perl by Doug MacEachern <dougm@osf.org>  Apache::Mysql by Neil Jensen <njensen@habaneros.com>
=============================================================================================================================================================================




File: pm.info, Node: Apache/Options, Next: Apache/OutputChain, Prev: Apache/Mysql, Up: Module List

OPT_* defines from httpd_core.h
*******************************



NAME
====

Apache::Options - OPT_* defines from httpd_core.h


SYNOPSIS
========

     use Apache::Options;


DESCRIPTION
===========

The *Apache::Options* module will export the following bitmask
constants:

     OPT_NONE
     OPT_INDEXES
     OPT_INCLUDES 
     OPT_SYMLINKS
     OPT_EXECCGI
     OPT_UNSET
     OPT_INCNOEXEC
     OPT_SYM_OWNER
     OPT_MULTI
     OPT_ALL

These constants can be used to check the return value from
Apache->request->allow_options() method.

This module is simply a stub which imports from *Note Apache/Constants:
Apache/Constants,, just as if you had said `use Apache::Constants
':options';'.


SEE ALSO
========

*Note Apache: Apache,, *Note Apache/Constants: Apache/Constants,




File: pm.info, Node: Apache/OutputChain, Next: Apache/PassHtml, Prev: Apache/Options, Up: Module List

chain stacked PERL handlers
***************************



NAME
====

Apache::OutputChain - chain stacked PERL handlers


SYNOPSIS
========

Inherit from this module to put a new one into the chain.


DESCRIPTION
===========

This module allows chaining perl handlers in Apache, which enables to
make filter modules that take output from previous handlers, make some
modifications, and pass the output to the next handler.

I will try to explain how this module works, because I hope you could
help me to make it better and mature.

When the handler function is called, it checks if it gets a reference to
a class. If this is true, the this function was called from some other
handler that wants to be put into the chain. If not, it's probably an
initialization (first call) of this package and we will supply name of
this package.

Now we check, where is STDOUT tied. If it is Apache, we are the first
one trying to be put into the chain. If it is not, there is somebody in
the chain already. We call tie on the STDOUT, steal it from anybody who
had it before -- either Apache or the other class.

When later anybody prints into STDOUT, it will call function PRINT of
the first class in the chain (the last one that registered). If there is
not other class behind, the print method of Apache will be called. If
this is not the last user defined handler in the chain, we will call
PRINT method of the next class.


AUTHOR
======

(c) 1997 Jan Pazdziora, adelton@fi.muni.cz

at Faculty of Informatics, Masaryk University, Brno




File: pm.info, Node: Apache/PassHtml, Next: Apache/Registry, Prev: Apache/OutputChain, Up: Module List

print out the html file
***********************



NAME
====

Apache::PassHtml - print out the html file


SYNOPSIS
========

In the conf/access.conf file of your Apache installation add lines

     <Files *.html>
     SetHandler perl-script
     PerlHandler Apache::OutputChain Apache::MakeCapital Apache::PassHtml
     </Files>


DESCRIPTION
===========

This is simple script to show the use of module *Apache::OutputChain*.
If will pick up a html file and send it to the output, STDOUT. We assume
that the output is tied either to Apache (by default), or some user
defined perl handler. We need to read and write to STDOUT in perl since
Apache will not pass its output into perl handlers.


AUTHOR
======

(c) 1997 Jan Pazdziora, adelton@fi.muni.cz

at Faculty of Informatics, Masaryk University, Brno




File: pm.info, Node: Apache/Registry, Next: Apache/Status, Prev: Apache/PassHtml, Up: Module List

Run unaltered CGI scrips under mod_perl
***************************************



NAME
====

Apache::Registry - Run unaltered CGI scrips under mod_perl


SYNOPSIS
========

     #in httpd.conf

     Alias /perl/ /perl/apache/scripts/ #optional
     PerlModule Apache::Registry

     <Location /perl>
     SetHandler perl-script
     PerlHandler Apache::Registry
     Options ExecCGI 
     ...
     </Directory>


DESCRIPTION
===========

URIs in the form of `http://www.host.com/perl/file.pl' will be compiled
as the body of a perl subroutine and executed.  Each server process or
'child' will compile the subroutine once and store it in memory. It will
recompile it whenever the file is updated on disk.  Think of it as an
object oriented server with each script implementing a class loaded at
runtime.

The file looks much like a "normal" script, but it is compiled or
'evaled' into a subroutine.

Here's an example:

     my $r = Apache->request;
     $r->content_type("text/html");
     $r->send_http_header;
     $r->print("Hi There!");

This module emulates the CGI environment, allowing programmers to write
scripts that run under CGI or mod_perl without change.  Existing CGI
scripts may require some changes, simply because a CGI script has a very
short lifetime of one HTTP request, allowing you to get away with "quick
and dirty" scripting.  Using mod_perl and Apache::Registry requires you
to be more careful, but it also gives new meaning to the word "quick"!

Be sure to read all mod_perl related documentation for more details,
including instructions for setting up an environment that looks exactly
like CGI:

     print "Content-type: text/html\n\n";
     print "Hi There!";

Note that each httpd process or "child" must compile each script once,
so the first request to one server may seem slow, but each request there
after will be faster.  If your scripts are large and/or make use of many
Perl modules, this difference should be noticeable to the human eye.


SECURITY
========

Apache::Registry::handler will preform the same checks as mod_cgi before
running the script.


ENVIRONMENT
===========

The Apache function `exit' overrides the Perl core built-in function.

The environment variable *GATEWAY_INTERFACE* is set to `CGI-Perl/1.1'.


COMMANDLINE SWITCHES IN FIRST LINE
==================================

Normally when a Perl script is run from the command line or under CGI,
arguments on the `#!' line are passed to the perl interpreter for
processing.

Apache::Registry currently only honors the -w switch and will turn on
warnings using the $^W global variable.  Another common switch used with
CGI scripts is -T to turn on taint checking.  This can only be enabled
when the server starts with the configuration directive:

     PerlTaintCheck On

However, if taint checking is not enabled, but the -T switch is seen,
Apache::Registry will write a warning to the error_log.


DEBUGGING
=========

You may set the debug level with the $Apache::Registry::Debug bitmask

     1 => log recompile in errorlog
     2 => Apache::Debug::dump in case of $@
     4 => trace pedantically


CAVEATS
=======

Apache::Registry makes things look just the CGI environment, however,
you must understand that this *is not CGI*.  Each httpd child will
compile your script into memory and keep it there, whereas CGI will run
it once, cleaning out the entire process space.  Many times you have
heard "always use -w, always use -w and 'use strict'".  This is more
important here than anywhere else!

Your scripts cannot contain the __END__ or __DATA__ token to terminate
compilation.


SEE ALSO
========

perl(1), mod_perl(3), Apache(3), Apache::Debug(3)


AUTHORS
=======

Andreas Koenig <andreas.koenig@franz.ww.tu-berlin.de> and Doug
MacEachern <dougm@osf.org>




