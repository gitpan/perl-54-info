Info file: pm.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `bigpm.texi'
using `texinfmt.el' version 2.32 of 19 November 1993.





File: pm.info, Node: ExtUtils/Manifest, Next: ExtUtils/Miniperl, Prev: ExtUtils/MakeMaker, Up: Module List

utilities to write and check a MANIFEST file
********************************************



NAME
====

ExtUtils::Manifest - utilities to write and check a MANIFEST file


SYNOPSIS
========

`require ExtUtils::Manifest;'

`ExtUtils::Manifest::mkmanifest;'

`ExtUtils::Manifest::manicheck;'

`ExtUtils::Manifest::filecheck;'

`ExtUtils::Manifest::fullcheck;'

`ExtUtils::Manifest::skipcheck;'

`ExtUtild::Manifest::manifind();'

`ExtUtils::Manifest::maniread($file);'

`ExtUtils::Manifest::manicopy($read,$target,$how);'


DESCRIPTION
===========

Mkmanifest() writes all files in and below the current directory to a
file named in the global variable $ExtUtils::Manifest::MANIFEST (which
defaults to MANIFEST) in the current directory. It works similar to

     find . -print

but in doing so checks each line in an existing MANIFEST file and
includes any comments that are found in the existing MANIFEST file in
the new one. Anything between white space and an end of line within a
MANIFEST file is considered to be a comment. Filenames and comments are
seperated by one or more TAB characters in the output. All files that
match any regular expression in a file MANIFEST.SKIP (if such a file
exists) are ignored.

Manicheck() checks if all the files within a MANIFEST in the current
directory really do exist. It only reports discrepancies and exits
silently if MANIFEST and the tree below the current directory are in
sync.

Filecheck() finds files below the current directory that are not
mentioned in the MANIFEST file. An optional file MANIFEST.SKIP will be
consulted. Any file matching a regular expression in such a file will
not be reported as missing in the MANIFEST file.

Fullcheck() does both a manicheck() and a filecheck().

Skipcheck() lists all the files that are skipped due to your
MANIFEST.SKIP file.

Manifind() retruns a hash reference. The keys of the hash are the files
found below the current directory.

Maniread($file) reads a named MANIFEST file (defaults to MANIFEST in the
current directory) and returns a HASH reference with files being the
keys and comments being the values of the HASH.  Blank lines and lines
which start with `#' in the MANIFEST file are discarded.

*Manicopy($read,$target,$how)* copies the files that are the keys in
the HASH *%$read* to the named target directory. The HASH reference
*$read* is typically returned by the maniread() function. This
function is useful for producing a directory tree identical to the
intended distribution tree. The third parameter $how can be used to
specify a different methods of "copying". Valid values are cp, which
actually copies the files, `ln' which creates hard links, and `best'
which mostly links the files but copies any symbolic link to make a tree
without any symbolic link. Best is the default.


MANIFEST.SKIP
=============

The file MANIFEST.SKIP may contain regular expressions of files that
should be ignored by mkmanifest() and filecheck(). The regular
expressions should appear one on each line. Blank lines and lines which
start with `#' are skipped.  Use `\#' if you need a regular expression
to start with a sharp character. A typical example:

     \bRCS\b
     ^MANIFEST\.
     ^Makefile$
     ~$
     \.html$
     \.old$
     ^blib/
     ^MakeMaker-\d


EXPORT_OK
=========

`&mkmanifest', `&manicheck', `&filecheck', `&fullcheck', `&maniread',
and `&manicopy' are exportable.


GLOBAL VARIABLES
================

`$ExtUtils::Manifest::MANIFEST' defaults to MANIFEST. Changing it
results in both a different MANIFEST and a different MANIFEST.SKIP
file. This is useful if you want to maintain different distributions for
different audiences (say a user version and a developer version
including RCS).

`$ExtUtils::Manifest::Quiet' defaults to 0. If set to a true value, all
functions act silently.


DIAGNOSTICS
===========

All diagnostic output is sent to `STDERR'.

`Not in MANIFEST:' *file*
     is reported if a file is found, that is missing in the MANIFEST
     file which is excluded by a regular expression in the file
     MANIFEST.SKIP.

`No such file:' *file*
     is reported if a file mentioned in a MANIFEST file does not exist.

`MANIFEST:' $!
     is reported if MANIFEST could not be opened.

`Added to MANIFEST:' *file*
     is reported by mkmanifest() if $Verbose is set and a file is added
     to MANIFEST. $Verbose is set to 1 by default.


SEE ALSO
========

*Note ExtUtils/MakeMaker: ExtUtils/MakeMaker, which has handy targets for most of the functionality.


AUTHOR
======

Andreas Koenig <`koenig@franz.ww.TU-Berlin.DE'>




File: pm.info, Node: ExtUtils/Miniperl, Next: ExtUtils/Mkbootstrap, Prev: ExtUtils/Manifest, Up: Module List

write the C code for perlmain.c
*******************************



NAME
====

ExtUtils::Miniperl, writemain - write the C code for perlmain.c


SYNOPSIS
========

`use ExtUtils::Miniperl;'

`writemain(@directories);'


DESCRIPTION
===========

This whole module is written when perl itself is built from a script
called minimod.PL. In case you want to patch it, please patch minimod.PL
in the perl distribution instead.

writemain() takes an argument list of directories containing archive
libraries that relate to perl modules and should be linked into a new
perl binary. It writes to STDOUT a corresponding perlmain.c file that is
a plain C file containing all the bootstrap code to make the modules
associated with the libraries available from within perl.

The typical usage is from within a Makefile generated by
ExtUtils::MakeMaker. So under normal circumstances you won't have to
deal with this module directly.


SEE ALSO
========

*Note ExtUtils/MakeMaker: ExtUtils/MakeMaker,




File: pm.info, Node: ExtUtils/Mkbootstrap, Next: ExtUtils/Mksymlists, Prev: ExtUtils/Miniperl, Up: Module List

make a bootstrap file for use by DynaLoader
*******************************************



NAME
====

ExtUtils::Mkbootstrap - make a bootstrap file for use by DynaLoader


SYNOPSIS
========

`mkbootstrap'


DESCRIPTION
===========

Mkbootstrap typically gets called from an extension Makefile.

There is no `*.bs' file supplied with the extension. Instead a `*_BS'
file which has code for the special cases, like posix for berkeley db on
the NeXT.

This file will get parsed, and produce a maybe empty
`@DynaLoader::dl_resolve_using' array for the current architecture.
That will be extended by $BSLOADLIBS, which was computed by
ExtUtils::Liblist::ext(). If this array still is empty, we do nothing,
else we write a .bs file with an `@DynaLoader::dl_resolve_using' array.

The `*_BS' file can put some code into the generated `*.bs' file by
placing it in `$bscode'. This is a handy 'escape' mechanism that may
prove useful in complex situations.

If @DynaLoader::dl_resolve_using contains `-L*' or `-l*' entries then
Mkbootstrap will automatically add a dl_findfile() call to the generated
`*.bs' file.




File: pm.info, Node: ExtUtils/Mksymlists, Next: ExtUtils/testlib, Prev: ExtUtils/Mkbootstrap, Up: Module List

write linker options files for dynamic extension
************************************************



NAME
====

ExtUtils::Mksymlists - write linker options files for dynamic extension


SYNOPSIS
========

     use ExtUtils::Mksymlists;
     Mksymlists({ NAME     => $name ,
                  DL_VARS  => [ $var1, $var2, $var3 ],
                  DL_FUNCS => { $pkg1 => [ $func1, $func2 ],
                                $pkg2 => [ $func3 ] });


DESCRIPTION
===========

ExtUtils::Mksymlists produces files used by the linker under some OSs
during the creation of shared libraries for dynamic extensions.  It is
normally called from a MakeMaker-generated Makefile when the extension
is built.  The linker option file is generated by calling the function
`Mksymlists', which is exported by default from ExtUtils::Mksymlists.
It takes one argument, a list of key-value pairs, in which the following
keys are recognized:

NAME
     This gives the name of the extension (*e.g.* Tk::Canvas) for which
     the linker option file will be produced.

DL_FUNCS
     This is identical to the DL_FUNCS attribute available via
     MakeMaker, from which it is usually taken.  Its value is a
     reference to an associative array, in which each key is the name of
     a package, and each value is an a reference to an array of function
     names which should be exported by the extension.  For instance, one
     might say `DL_FUNCS => { Homer::Iliad => [ qw(trojans greeks) ],
     Homer::Odyssey => [ qw(travellers family suitors) ] }'.  The
     function names should be identical to those in the XSUB code;
     `Mksymlists' will alter the names written to the linker option file
     to match the changes made by xsubpp.  In addition, if none of the
     functions in a list begin with the string *boot_*, `Mksymlists'
     will add a bootstrap function for that package, just as xsubpp
     does.  (If a *boot_<pkg>* function is present in the list, it is
     passed through unchanged.)  If DL_FUNCS is not specified, it
     defaults to the bootstrap function for the extension specified in
     NAME.

DL_VARS
     This is identical to the DL_VARS attribute available via MakeMaker,
     and, like DL_FUNCS, it is usually specified via MakeMaker.  Its
     value is a reference to an array of variable names which should be
     exported by the extension.

FILE
     This key can be used to specify the name of the linker option file
     (minus the OS-specific extension), if for some reason you do not
     want to use the default value, which is the last word of the NAME
     attribute (*e.g.* for Tk::Canvas, FILE defaults to 'Canvas').

FUNCLIST
     This provides an alternate means to specify function names to be
     exported from the extension.  Its value is a reference to an array
     of function names to be exported by the extension.  These names are
     passed through unaltered to the linker options file.

DLBASE
     This item specifies the name by which the linker knows the
     extension, which may be different from the name of the extension
     itself (for instance, some linkers add an '_' to the name of the
     extension).  If it is not specified, it is derived from the NAME
     attribute.  It is presently used only by OS2.

When calling `Mksymlists', one should always specify the NAME attribute.
In most cases, this is all that's necessary.  In the case of unusual
extensions, however, the other attributes can be used to provide
additional information to the linker.


AUTHOR
======

Charles Bailey *<bailey@genetics.upenn.edu>*


REVISION
========

Last revised 14-Feb-1996, for Perl 5.002.



File: pm.info, Node: ExtUtils/testlib, Next: Fcntl, Prev: ExtUtils/Mksymlists, Up: Module List

add blib/* directories to @INC
******************************



NAME
====

ExtUtils::testlib - add blib/* directories to @INC


SYNOPSIS
========

`use ExtUtils::testlib;'


DESCRIPTION
===========

After an extension has been built and before it is installed it may be
desirable to test it bypassing make test. By adding

     use ExtUtils::testlib;

to a test program the intermediate directories used by make are added to
@INC.




File: pm.info, Node: Fcntl, Next: File/Basename, Prev: ExtUtils/testlib, Up: Module List

load the C Fcntl.h defines
**************************



NAME
====

Fcntl - load the C Fcntl.h defines


SYNOPSIS
========

     use Fcntl;
     use Fcntl qw(:DEFAULT :flock);


DESCRIPTION
===========

This module is just a translation of the C `fnctl.h' file.  Unlike the
old mechanism of requiring a translated `fnctl.ph' file, this uses the
h2xs program (see the Perl source distribution) and your native C
compiler.  This means that it has a far more likely chance of getting
the numbers right.


NOTE
====

Only `#define' symbols get translated; you must still correctly pack up
your own arguments to pass as args for locking functions, etc.


EXPORTED SYMBOLS
================

By default your system's F_* and O_* constants (eg, F_DUPFD and O_CREAT)
and the FD_CLOEXEC constant are exported into your namespace.

You can request that the flock() constants (LOCK_SH, LOCK_EX, LOCK_NB
and LOCK_UN) be provided by using the tag `:flock'.  See *Note Exporter:
Exporter,.

You can request that the old constants (FAPPEND, FASYNC, FCREAT, FDEFER,
FEXCL, FNDELAY, FNONBLOCK, FSYNC, FTRUNC) be provided for compatibility
reasons by using the tag `:Fcompat'.  For new applications the newer
versions of these constants are suggested (O_APPEND, O_ASYNC, O_CREAT,
O_DEFER, O_EXCL, O_NDELAY, O_NONBLOCK, O_SYNC, O_TRUNC).

Please refer to your native fcntl() and open() documentation to see what
constants are implemented in your system.




File: pm.info, Node: File/Basename, Next: File/BasicFlock, Prev: Fcntl, Up: Module List

split a pathname into pieces
****************************



NAME
====

fileparse - split a pathname into pieces

basename - extract just the filename from a path

dirname - extract just the directory from a path


SYNOPSIS
========

     use File::Basename;

     ($name,$path,$suffix) = fileparse($fullname,@suffixlist)
     fileparse_set_fstype($os_string);
     $basename = basename($fullname,@suffixlist);
     $dirname = dirname($fullname);

     ($name,$path,$suffix) = fileparse("lib/File/Basename.pm","\.pm");
     fileparse_set_fstype("VMS");
     $basename = basename("lib/File/Basename.pm",".pm");
     $dirname = dirname("lib/File/Basename.pm");


DESCRIPTION
===========

These routines allow you to parse file specifications into useful pieces
using the syntax of different operating systems.

fileparse_set_fstype
     You select the syntax via the routine fileparse_set_fstype().

     If the argument passed to it contains one of the substrings "VMS",
     "MSDOS", "MacOS", "AmigaOS" or "MSWin32", the file specification
     syntax of that operating system is used in future calls to
     fileparse(), basename(), and dirname().  If it contains none of
     these substrings, UNIX syntax is used.  This pattern matching is
     case-insensitive.  If you've selected VMS syntax, and the file
     specification you pass to one of these routines contains a "/",
     they assume you are using UNIX emulation and apply the UNIX syntax
     rules instead, for that function call only.

     If the argument passed to it contains one of the substrings "VMS",
     "MSDOS", "MacOS", "AmigaOS", "os2", "MSWin32" or "RISCOS", then the
     pattern matching for suffix removal is performed without regard for
     case, since those systems are not case-sensitive when opening
     existing files (though some of them preserve case on file
     creation).

     If you haven't called fileparse_set_fstype(), the syntax is chosen
     by examining the builtin variable $^O according to these rules.

fileparse
     The fileparse() routine divides a file specification into three
     parts: a leading path, a file name, and a *suffix*.  The path
     contains everything up to and including the last directory
     separator in the input file specification.  The remainder of the
     input file specification is then divided into name and *suffix*
     based on the optional patterns you specify in `@suffixlist'.  Each
     element of this list is interpreted as a regular expression, and is
     matched against the end of name.  If this succeeds, the matching
     portion of name is removed and prepended to *suffix*.  By proper
     use of `@suffixlist', you can remove file types or versions for
     examination.

     You are guaranteed that if you concatenate path, name, and
     *suffix* together in that order, the result will denote the same
     file as the input file specification.


EXAMPLES
========

Using UNIX file syntax:

     ($base,$path,$type) = fileparse('/virgil/aeneid/draft.book7',
     				    '\.book\d+');

would yield

     $base eq 'draft'
     $path eq '/virgil/aeneid/',
     $type eq '.book7'

Similarly, using VMS syntax:

     ($name,$dir,$type) = fileparse('Doc_Root:[Help]Rhetoric.Rnh',
     				   '\..*');

would yield

     $name eq 'Rhetoric'
     $dir  eq 'Doc_Root:[Help]'
     $type eq '.Rnh'

`basename'
     The basename() routine returns the first element of the list
     produced by calling fileparse() with the same arguments, except
     that it always quotes metacharacters in the given suffixes.  It is
     provided for programmer compatibility with the UNIX shell command
     basename(1).

`dirname'
     The dirname() routine returns the directory portion of the input
     file specification.  When using VMS or MacOS syntax, this is
     identical to the second element of the list produced by calling
     fileparse() with the same input file specification.  (Under VMS, if
     there is no directory information in the input file specification,
     then the current default device and directory are returned.)  When
     using UNIX or MSDOS syntax, the return value conforms to the
     behavior of the UNIX shell command dirname(1).  This is usually the
     same as the behavior of fileparse(), but differs in some cases.
     For example, for the input file specification `lib/', fileparse()
     considers the directory name to be `lib/', while dirname()
     considers the directory name to be .).




File: pm.info, Node: File/BasicFlock, Next: File/CheckTree, Prev: File/Basename, Up: Module List

file locking with flock
***********************



NAME
====

     File::BasicFlock - file locking with flock


SYNOPSIS
========

     use File::BasicFlock;

     lock($filename);

     lock($filename, 'shared');

     lock($filename, undef, 'nonblocking');

     lock($filename, 'shared', 'nonblocking');

     unlock($filename);


DESCRIPTION
===========

Lock files using the flock() call.  The file to be locked must already
exist.


AUTHOR
======

David Muir Sharnoff, <muir@idiom.com>




File: pm.info, Node: File/CheckTree, Next: File/Cmp, Prev: File/BasicFlock, Up: Module List

run many filetest checks on a tree
**********************************



NAME
====

validate - run many filetest checks on a tree


SYNOPSIS
========

     use File::CheckTree;

     $warnings += validate( q{
     	/vmunix                 -e || die
     	/boot                   -e || die
     	/bin                    cd
     	    csh                 -ex
     	    csh                 !-ug
     	    sh                  -ex
     	    sh                  !-ug
     	/usr                    -d || warn "What happened to $file?\n"
     });


DESCRIPTION
===========

The validate() routine takes a single multiline string consisting of
lines containing a filename plus a file test to try on it.  (The file
test may also be a "cd", causing subsequent relative filenames to be
interpreted relative to that directory.)  After the file test you may
put `|| die' to make it a fatal error if the file test fails.  The
default is `|| warn'.  The file test may optionally have a "!' prepended
to test for the opposite condition.  If you do a cd and then list some
relative filenames, you may want to indent them slightly for
readability.  If you supply your own die() or warn() message, you can
use $file to interpolate the filename.

Filetests may be bunched: "-rwx" tests for all of -r, -w, and -x.  Only
the first failed test of the bunch will produce a warning.

The routine returns the number of warnings issued.




File: pm.info, Node: File/Cmp, Next: File/Compare, Prev: File/CheckTree, Up: Module List

compare files
*************



NAME
====

File::Cmp - compare files


SYNOPSIS
========

     use File::Cmp;

     $status = cmp_file "filename1", "filename2";


DESCRIPTION
===========

cmp_file() compares the contents of two files.  If they are identical
cmp_file() return a value of 0.  Otherwise it returns a positive nonzero
value.

If one of the two files cannot be opened, cmp_file() returns -1.


BUGS
====

cmp_file() checks to see if files have identical filenames, but maybe it
should also check inode numbers?

It might be nice to have a version that would return the location of the
first difference found.


AUTHOR
======

Joseph N. Hall, joseph@5sigma.com




File: pm.info, Node: File/Compare, Next: File/Copy, Prev: File/Cmp, Up: Module List

Compare files or filehandles
****************************



NAME
====

File::Compare - Compare files or filehandles


SYNOPSIS
========

     use File::Compare;

     if (compare("file1","file2") == 0) {
         print "They're equal\n";
     }


DESCRIPTION
===========

The File::Compare::compare function compares the contents of two
sources, each of which can be a file or a file handle.  It is exported
from File::Compare by default.

File::Compare::cmp is a synonym for File::Compare::compare.  It is
exported from File::Compare only by request.


RETURN
======

File::Compare::compare return 0 if the files are equal, 1 if the files
are unequal, or -1 if an error was encountered.


AUTHOR
======

File::Compare was written by Nick Ing-Simmons.  Its original
documentation was written by Chip Salzenberg.




File: pm.info, Node: File/Copy, Next: File/CounterFile, Prev: File/Compare, Up: Module List

Copy files or filehandles
*************************



NAME
====

File::Copy - Copy files or filehandles


SYNOPSIS
========

     use File::Copy;

     copy("file1","file2");
       	copy("Copy.pm",\*STDOUT);'
     move("/dev1/fileA","/dev2/fileB");

     use POSIX;
     	use File::Copy cp;

     $n=FileHandle->new("/dev/null","r");
     cp($n,"x");'


DESCRIPTION
===========

The File::Copy module provides two basic functions, copy and `move',
which are useful for getting the contents of a file from one place to
another.

   * The copy function takes two parameters: a file to copy from and a
     file to copy to. Either argument may be a string, a FileHandle
     reference or a FileHandle glob. Obviously, if the first argument is
     a filehandle of some sort, it will be read from, and if it is a
     file name it will be opened for reading. Likewise, the second
     argument will be written to (and created if need be).

     *Note that passing in
     files as handles instead of names may lead to loss of information
     on some operating systems; it is recommended that you use file
     names whenever possible.* Files are opened in binary mode where
     applicable.  To get a consistent behavour when copying from a
     filehandle to a file, use binmode on the filehandle.

     An optional third parameter can be used to specify the buffer size
     used for copying. This is the number of bytes from the first file,
     that wil be held in memory at any given time, before being written
     to the second file. The default buffer size depends upon the file,
     but will generally be the whole file (up to 2Mb), or 1k for
     filehandles that do not reference files (eg. sockets).

     You may use the syntax `use File::Copy "cp"' to get at the "cp"
     alias for this function. The syntax is *exactly* the same.

   * The `move' function also takes two parameters: the current name and
     the intended name of the file to be moved.  If the destination
     already exists and is a directory, and the source is not a
     directory, then the source file will be renamed into the directory
     specified by the destination.

     If possible, move() will simply rename the file.  Otherwise, it
     copies the file to the new location and deletes the original.  If
     an error occurs during this copy-and-delete process, you may be
     left with a (possibly partial) copy of the file under the
     destination name.

     You may use the "mv" alias for this function in the same way that
     you may use the "cp" alias for copy.

File::Copy also provides the `syscopy' routine, which copies the file
specified in the first parameter to the file specified in the second
parameter, preserving OS-specific attributes and file structure.  For
Unix systems, this is equivalent to the simple copy routine.  For VMS
systems, this calls the `rmscopy' routine (see below).  For OS/2
systems, this calls the `syscopy' XSUB directly.


Special behavior if `syscopy' is defined (VMS and OS/2)
-------------------------------------------------------

If both arguments to copy are not file handles, then copy will perform a
"system copy" of the input file to a new output file, in order to
preserve file attributes, indexed file structure, *etc.* The buffer size
parameter is ignored.  If either argument to copy is a handle to an
opened file, then data is copied using Perl operators, and no effort is
made to preserve file attributes or record structure.

The system copy routine may also be called directly under VMS and OS/2
as `File::Copy::syscopy' (or under VMS as `File::Copy::rmscopy', which
is the routine that does the actual work for syscopy).

rmscopy($from,$to[,$date_flag])
     The first and second arguments may be strings, typeglobs, typeglob
     references, or objects inheriting from IO::Handle;
     they are used in all cases to obtain the
     *filespec* of the input and output files, respectively.  The
     name and type of the input file are used as defaults for the output
     file, if necessary.

     A new version of the output file is always created, which inherits
     the structure and RMS attributes of the input file, except for
     owner and protections (and possibly timestamps; see below).  All
     data from the input file is copied to the output file; if either of
     the first two parameters to `rmscopy' is a file handle, its
     position is unchanged.  (Note that this means a file handle
     pointing to the output file will be associated with an old version
     of that file after `rmscopy' returns, not the newly created
     version.)

     The third parameter is an integer flag, which tells `rmscopy' how
     to handle timestamps.  If it is < 0, none of the input file's
     timestamps are propagated to the output file.  If it is > 0, then
     it is interpreted as a bitmask: if bit 0 (the LSB) is set, then
     timestamps other than the revision date are propagated; if bit 1 is
     set, the revision date is propagated.  If the third parameter to
     `rmscopy' is 0, then it behaves much like the DCL COPY command: if
     the name or type of the output file was explicitly specified, then
     no timestamps are propagated, but if they were taken implicitly
     from the input filespec, then all timestamps other than the
     revision date are propagated.  If this parameter is not supplied,
     it defaults to 0.

     Like copy, `rmscopy' returns 1 on success.  If an error occurs, it
     sets $!, deletes the output file, and returns 0.


RETURN
======

All functions return 1 on success, 0 on failure.  $! will be set if an
error was encountered.


AUTHOR
======

File::Copy was written by Aaron Sherman *<ajs@ajs.com>* in 1995, and
updated by Charles Bailey *<bailey@genetics.upenn.edu>* in 1996.




File: pm.info, Node: File/CounterFile, Next: File/Df, Prev: File/Copy, Up: Module List

Persistent counter class
************************



NAME
====

File::CounterFile - Persistent counter class


SYNOPSIS
========

     use File::CounterFile;
     $c = new File::CounterFile "COUNTER", "aa00";

     $id = $c->inc;
     open(F, ">F$id");


DESCRIPTION
===========

This module implements a persistent counter class.  Each counter is
represented by a separate file in the file system.  File locking is
applied, so multiple processes might try to access the same counters at
the same time without risk of counter destruction.

You give the file name as the first parameter to the object constructor
(new).  The file is created if it does not exist.

If the file name does not start with "/" or ".", then it is interpreted
as a file relative to `$File::CounterFile::DEFAULT_DIR'.  The default
value for this variable is initialized from the environment variable
TMPDIR, or `/usr/tmp' is no environment variable is defined.  You may
want to assign a different value to this variable before creating
counters.

If you pass a second parameter to the constructor, that sets the initial
value for a new counter.  This parameter only takes effect when the file
is created (i.e. it does not exist before the call).

When you call the `inc()' method, you increment the counter value by
one. When you call `dec()' the counter value is decrementd.  In both
cases the new value is returned.  The `dec()' method only works for
numerical counters (digits only).

You can peek at the value of the counter (without incrementing it) by
using the `value()' method.

The counter can be locked and unlocked with the `lock()' and `unlock()'
methods.  Incrementing and value retrieval is faster when the counter is
locked, because we do not have to update the counter file all the time.
You can query whether the counter is locked with the `locked()' method.

There is also an operator overloading interface to the File::CounterFile
object.  This means that you might use the `++' operator for
incrementing the counter, `--' operator for decrementing and you can
interpolate counters diretly into strings.


BUGS
====

It uses flock(2) to lock the counter file.  This does not work on all
systems.  Perhaps we should use the File::Lock module?


INSTALLATION
============

Copy this file to the File subdirectory of your Perl 5 library directory
(often `/usr/local/lib/perl5').


COPYRIGHT
=========

Copyright (c) 1995-1996 Gisle Aas. All rights reserved.

This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


AUTHOR
======

Gisle Aas <aas@sn.no>




File: pm.info, Node: File/Df, Next: File/DosGlob, Prev: File/CounterFile, Up: Module List

Perl df
*******



NAME
====

File::Df - Perl df


SYNOPSYS
========

     use File::Df;
     ($fs_type, $fs_desc, $used, $avail, $fused, $favail) = df ($dir);


DESCRIPTION
===========

This routine displays information on a file system such as its type, the
amount of disk space occupied, the total disk space and the number of
inodes.  It Tries `syscall(SYS_statfs)' and `syscall(SYS_statvfs)' in
several way.  If all fails, it croaks.


OPTIONS
=======

$fs_type
     [number] type of the filesystem.

$fs_desc
     [string] description of this fs.

$used
     [number] size used (in Kb).

$avail
     [number] size available (in Kb).

$ffree
     [number] free inodes.

$fused
     [number] inodes used.


Installation
============

See the INSTALL file.


COPYRIGHT
=========

This module is copyright 1996, 1997 by Fabien TASSIN.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.


AUTHOR
======

Fabien TASSIN <tassin@eerie.fr>


NOTES
=====

Tested with Perl 5.003 under these systems :

     - Solaris 2.[4/5]
     - SunOS 4.1.[2/3/4]
     - HP-UX 9.05, 10.[1/20] (see below)
     - OSF1 3.2, 4.0
     - Linux 2.0.*

Note for HP-UX users :

     if you got this message :
     "Undefined subroutine &main::SYS_statfs called at File/Df.pm line XXX"
     and if you are using a hp9000s700, then edit the syscall.ph file
     (in the Perl lib tree) and copy the line containing "SYS_statfs {196;}"
     outside the "if (defined &__hp9000s800)" block (around line 356).




File: pm.info, Node: File/DosGlob, Next: File/Find, Prev: File/Df, Up: Module List

DOS like globbing and then some
*******************************



NAME
====

File::DosGlob - DOS like globbing and then some

perlglob.bat - a more capable perlglob.exe replacement


SYNOPSIS
========

     require 5.004;
     use File::DosGlob 'glob';  # override CORE::glob
     @perlfiles = glob  "..\\pe?l/*.p?";
     print <..\\pe?l/*.p?>;

     # from the command line
     > perl -MFile::DosGlob=glob -e "print <../pe*/*p?>"

     > perlglob ../pe*/*p?


DESCRIPTION
===========

A module that implements DOS-like globbing with a few enhancements.
This file is also a portable replacement for perlglob.exe.  It is
largely compatible with perlglob.exe (the M$ setargv.obj version) in all
but one respect--it understands wildcards in directory components.

For example, C<<..\\l*b\\file/*glob.p?>> will work as expected (in that
it will find something like '..\lib\File/DosGlob.pm' alright).  Note
that all path components are case-insensitive, and that backslashes and
forward slashes are both accepted, and preserved.  You may have to
double the backslashes if you are putting them in literally, due to
double-quotish parsing of the pattern by perl.

When invoked as a program, it will print null-separated filenames to
standard output.

While one may replace perlglob.exe with this, usage by overriding
CORE::glob via importation should be much more efficient, because it
avoids launching a separate process, and is therefore strongly
recommended.

Extending it to csh patterns is left as an exercise to the reader.


EXPORTS (by request only)
=========================

glob()


BUGS
====

Should probably be built into the core, and needs to stop pandering to
DOS habits.  Needs a dose of optimizium too.


AUTHOR
======

Gurusamy Sarathy <gsar@umich.edu>


HISTORY
=======

   * A few dir-vs-file optimizations result in glob importation being 10
     times faster than using perlglob.exe, and using perlglob.bat is
     only twice as slow as perlglob.exe (GSAR 28-MAY-97)

   * Several cleanups prompted by lack of compatible perlglob.exe under
     Borland (GSAR 27-MAY-97)

   * Initial version (GSAR 20-FEB-97)


SEE ALSO
========

perl




File: pm.info, Node: File/Find, Next: File/Flock, Prev: File/DosGlob, Up: Module List

traverse a file tree
********************



NAME
====

find - traverse a file tree

finddepth - traverse a directory structure depth-first


SYNOPSIS
========

     use File::Find;
     find(\&wanted, '/foo','/bar');
     sub wanted { ... }

     use File::Find;
     finddepth(\&wanted, '/foo','/bar');
     sub wanted { ... }


DESCRIPTION
===========

The wanted() function does whatever verifications you want.
$File::Find::dir contains the current directory name, and $_ the current
filename within that directory.  $File::Find::name contains
`"$File::Find::dir/$_"'.  You are chdir()'d to $File::Find::dir when the
function is called.  The function may set $File::Find::prune to prune
the tree.

File::Find assumes that you don't alter the $_ variable.  If you do then
make sure you return it to its original value before exiting your
function.

This library is primarily for the find2perl tool, which when fed,

     find2perl / -name .nfs\* -mtime +7 \
     	-exec rm -f {} \; -o -fstype nfs -prune

produces something like:

     sub wanted {
         /^\.nfs.*$/ &&
         (($dev,$ino,$mode,$nlink,$uid,$gid) = lstat($_)) &&
         int(-M _) > 7 &&
         unlink($_)
         ||
         ($nlink || (($dev,$ino,$mode,$nlink,$uid,$gid) = lstat($_))) &&
         $dev < 0 &&
         ($File::Find::prune = 1);
     }

Set the variable $File::Find::dont_use_nlink if you're using AFS, since
AFS cheats.

`finddepth' is just like `find', except that it does a depth-first
search.

Here's another interesting wanted function.  It will find all symlinks
that don't resolve:

     sub wanted {
     	-l && !-e && print "bogus link: $File::Find::name\n";
     } 




File: pm.info, Node: File/Flock, Next: File/Listing, Prev: File/Find, Up: Module List

file locking with flock
***********************



NAME
====

     File::Flock - file locking with flock


SYNOPSIS
========

     use File::Flock;

     lock($filename);

     lock($filename, 'shared');

     lock($filename, undef, 'nonblocking');

     lock($filename, 'shared', 'nonblocking');

     unlock($filename);


DESCRIPTION
===========

Lock files using the flock() call.  If the file to be locked does not
exist, then the file is created.  If the file was created then it will
be removed when it is unlocked assuming it's still an empty file.


AUTHOR
======

David Muir Sharnoff, <muir@idiom.com>




File: pm.info, Node: File/Listing, Next: File/Path, Prev: File/Flock, Up: Module List

parse directory listing
***********************



NAME
====

parse_dir - parse directory listing


SYNOPSIS
========

     use File::Listing;
     for (parse_dir(`ls -l`)) {
         ($name, $type, $size, $mtime, $mode) = @$_;
         next if $type ne 'f'; # plain file
         #...
     }

     # directory listing can also be read from a file
     open(LISTING, "zcat ls-lR.gz|");
     $dir = parse_dir(\*LISTING, '+0000');


DESCRIPTION
===========

The parse_dir() routine can be used to parse directory
listings. Currently it only understand Unix `'ls -l'' and `'ls -lR''
format.  It should eventually be able to most things you might get back
from a ftp server file listing (LIST command), i.e. VMS listings, NT
listings, DOS listings,...

The first parameter to parse_dir() is the directory listing to parse.
It can be a scalar, a reference to an array of directory lines or a glob
representing a filehandle to read the directory listing from.

The second parameter is the time zone to use when parsing time stamps in
the listing. If this value is undefined, then the local time zone is
assumed.

The third parameter is the type of listing to assume.  The values will
be strings like 'unix', 'vms', 'dos'.  Currently only 'unix' is
implemented and this is also the default value.  Ideally, the listing
type should be determined automatically.

The fourth parameter specify how unparseable lines should be treated.
Values can be 'ignore', 'warn' or a code reference.  Warn means that the
perl warn() function will be called.  If a code reference is passed,
then this routine will be called and the return value from it will be
incorporated in the listing.  The default is 'ignore'.

Only the first parameter is mandatory.  The parse_dir() prototype is
($;$$$).

The return value from parse_dir() is a list of directory entries.  In
scalar context the return value is a reference to the list.  The
directory entries are represented by an array consisting of [ $filename,
$filetype, $filesize, $filetime, $filemode ].  The $filetype value is
one of the letters 'f', 'd', 'l' or '?'.  The $filetime value is
converted to seconds since Jan 1, 1970.  The $filemode is a bitmask like
the mode returned by stat().


CREDITS
=======

Based on lsparse.pl (from Lee McLoughlin's ftp mirror package) and
Net::FTP's parse_dir (Graham Barr).




File: pm.info, Node: File/Path, Next: File/PathConvert, Prev: File/Listing, Up: Module List

create or remove a series of directories
****************************************



NAME
====

File::Path - create or remove a series of directories


SYNOPSIS
========

`use File::Path'

`mkpath(['/foo/bar/baz', 'blurfl/quux'], 1, 0711);'

`rmtree(['foo/bar/baz', 'blurfl/quux'], 1, 1);'


DESCRIPTION
===========

The mkpath function provides a convenient way to create directories,
even if your mkdir kernel call won't create more than one level of
directory at a time.  mkpath takes three arguments:

   * the name of the path to create, or a reference to a list of paths
     to create,

   * a boolean value, which if TRUE will cause mkpath to print the name
     of each directory as it is created (defaults to FALSE), and

   * the numeric mode to use when creating the directories (defaults to
     0777)

It returns a list of all directories (including intermediates,
determined using the Unix '/' separator) created.

Similarly, the `rmtree' function provides a convenient way to delete a
subtree from the directory structure, much like the Unix command `rm
-r'.  `rmtree' takes three arguments:

   * the root of the subtree to delete, or a reference to a list of
     roots.  All of the files and directories below each root, as well
     as the roots themselves, will be deleted.

   * a boolean value, which if TRUE will cause `rmtree' to print a
     message each time it examines a file, giving the name of the file,
     and indicating whether it's using rmdir or unlink to remove it, or
     that it's skipping it.  (defaults to FALSE)

   * a boolean value, which if TRUE will cause `rmtree' to skip any
     files to which you do not have delete access (if running under VMS)
     or write access (if running under another OS).  This will change in
     the future when a criterion for 'delete permission' under OSs other
     than VMS is settled.  (defaults to FALSE)

It returns the number of files successfully deleted.  Symlinks are
treated as ordinary files.

*NOTE:* If the third parameter is not TRUE, `rmtree' is *unsecure*
in the face of failure or interruption.  Files and directories which
were not deleted may be left with permissions reset to allow world read
and write access.  Note also that the occurrence of errors in rmtree can
be determined *only* by trapping diagnostic messages using
`$SIG{__WARN__}'; it is not apparent from the return value.  Therefore,
you must be extremely careful about using `rmtree($foo,$bar,0' in
situations where security is an issue.


AUTHORS
=======

Tim Bunce <`Tim.Bunce@ig.co.uk'> and Charles Bailey
<`bailey@genetics.upenn.edu'>


REVISION
========

Current $VERSION is 1.04.




File: pm.info, Node: File/PathConvert, Next: File/Recurse, Prev: File/Path, Up: Module List

make an canonicalized absolute path name
****************************************



NAME
====

realpath - make an canonicalized absolute path name

abs2rel - make a relative path from an absolute path

rel2abs - make an absolute path from a relative path


SYNOPSIS
========

`use File::PathConvert;'

`$path = realpath($path);'

`$path = abs2rel($path);'
.br
`$path = abs2rel($path, $base);'

`$path = rel2abs($path);'
.br
`$path = rel2abs($path, $base);'


DESCRIPTION
===========

The PathConvert module provides three functions.

realpath
     realpath make a canonicalized absolute pathname.  The realpath
     resolves all symbolic links, extra ``/'' characters and references
     to /./ and /../ in the path.  The realpath will resolve both
     absolute and relative paths.  realpath return resolved name on
     success else undef and set valiable $resolved to pathname which
     caused the problem.

     All but the last component of the path must exist.

     This implementation based on 4.4BSD realpath(3).

abs2rel
     abs2rel make a relative path from an absolute path.  By default,
     the base is current directory.  If you specify second parameter,
     it's assumed the base.

     Returned path may include symbolic links.  abs2rel doesn't check
     whether any path exist or not.

rel2abs
     rel2abs make a absolute path from an relative path.  By default,
     the base directory is current directory.  If you specify second
     parameter, it's assumed the base.

     Returned path may include symbolic links.  abs2rel doesn't check
     whether any path exist or not.


EXAMPLES
========

realpath
          If '/sys' is symbolic link to '/usr/src/sys',

          chdir('/usr');
          $path = realpath('../sys/kern');

     or in anywhere ...

          $path = realpath('/sys/kern');

     would yield

          $path eq '/usr/src/sys/kern'

abs2rel
          chdir('/usr/local/lib');
          $path = abs2rel('/usr/src/sys');

     or in anywhere ...

          $path = abs2rel('/usr/src/sys', '/usr/local/lib');

     would yield

          $path eq '../../src/sys'

     Similarly,

          $path1 = abs2rel('/usr/src/sys', '/usr');
          $path2 = abs2rel('/usr/src/sys', '/usr/src/sys');

     would yield

          $path1 eq 'src/sys'
          $path2 eq '.'

     If the base directory includes symbolic links, abs2rel produce
     wrong path.  For example, '/sys' is a symbolic link to
     '/usr/src/sys',

          $path = abs2rel('/usr/local/lib', '/sys');

     would yield

          $path eq '../usr/local/lib'		# It's wrong!!

     You should convert the base directory into a real path in advance.

          $path = abs2rel('/sys/kern', realpath('/sys'));

     would yield

          $path eq '../../../sys/kern'	# It's correct but ...

     It's correct but a little redundant. If you wish get a simple
     answer 'kern', do the following.

          $path = abs2rel(realpath('/sys/kern'), realpath('/sys'));

     realpath() make the result correct but don't forget realpath
     require that all but the last component of the path exist.

rel2abs
          chdir('/usr/local/lib');
          $path = rel2abs('../../src/sys');

     or in anywhere ...

          $path = rel2abs('../../src/sys', '/usr/local/lib');

     would yield

          $path eq '/usr/src/sys'

     Similarly,

          $path = rel2abs('src/sys', '/usr');
          $path = rel2abs('.', '/usr/src/sys');

     would yield

          $path eq '/usr/src/sys'


AUTHOR
======

Shigio Yamaguchi <shigio@ca2.so-net.or.jp>




File: pm.info, Node: File/Recurse, Next: File/Slurp, Prev: File/PathConvert, Up: Module List

Recurse over files, performing some function.
*********************************************



NAME
====

File::Recurse - Recurse over files, performing some function.


SYNOPSIS
========

     use File::Recurse;
     use File::Copy;

     recurse { print } "/tmp";
     recurse {copy($_,"elsewhere") if -f $_} "dir";
     recurse(\&func, "/");


DESCRIPTION
===========

The `File::Recurse' module is designed for performing an operation on a
tree of directories and files. The basic usage is simmilar to the
`find.pl' library. Once one uses the File::Recurse module, you need only
call the recurse function in order to perform recursive directory
operations.

The function takes two parameters a function reference and a
directory. The function referenced by the first parameter should expect
to take one parameter: the full path to the file currently being
operated on. This function is called once for every file and directory
under the directory named by the second parameter.

For example:

     recurse(\&func, "/");

would start at the top level of the filesystem and call "func" for every
file and directory found (not including "/").

Perl allows a second form of calling this function which can be useful
for situations where you want to do something simple in the function. In
these cases, you can define an anonymous function by using braces like
so:

     recurse {print $_[0]} "/";

This would print every file and directory in the filesystem. However, as
an added convenience you can access the pathname in the variable $_. So
the above could be rewritten as:

     recurse { print } "/";


Context
-------

There is an optional third parameter which can be any scalar value
(including a reference). This value is ignored by recurse, but will be
passed as the second parameter to the user-defined function. This can be
useful for building library routines that use recurse, so that they do
not have to pass state to the function as global variables.


Controling Recursion
--------------------

If you want to control how recursion happens, you have several
options. First, there are some global variables that affect the overall
operation of the recurse routine:

`$MAX_DEPTH'
     This variable controls how far down a tree of directories recurse
     will go before it assumes that something bad has happened. Default:
     100.

`$FOLLOW_SYMLINKS'
     This variable tells recurse if it should descend into directories
     that are symbolic links. Default: 0.

Normally, the return value of the function called is not used, but if it
is -1 or -2, there is a special action taken.

If the function returns -1 and the current filename refers to a
directory, recurse will *not* descend into that directory. This can be
used to prune searches and focus only on those directories which should
be followed.

If the function returns -2, the search is terminated, and recurse will
return. This can be used to bail when a problem occurs, and you don't
want to exit the program, or to end the search for some file once it is
found.


SEE ALSO
========

*Note File/Tools: File/Tools,


AUTHOR
======

Written in 1996 by Aaron Sherman, ajs@ajs.com



File: pm.info, Node: File/Slurp, Next: File/Sync, Prev: File/Recurse, Up: Module List

single call read & write file routines; read directories
********************************************************



NAME
====

     File::Slurp -- single call read & write file routines; read directories


SYNOPSIS
========

     use File::Slurp;

     $all_of_it = read_file($filename);
     @all_lines = read_file($filename);

     write_file($filename, @contents)

     overwrite_file($filename, @new_contnts);

     append_file($filename, @additional_contents);

     @files = read_dir($directory);


DESCRIPTION
===========

These are quickie routines that are meant to save a couple of lines of
code over and over again.  They do not do anything fancy.
 
read_file() does what you would expect.  If you are using its output in
array context, then it returns an array of lines.  If you are calling it
from scalar context, then returns the entire file in a single string.

It croaks()s if it can't open the file.

write_file() creates or overwrites files.

append_file() appends to a file.

overwrite_file() does an in-place update of an existing file or creates
a new file if it didn't already exist.  Write_file will also replace a
file.  The difference is that the first that that write_file() does is
to trucate the file whereas the last thing that overwrite_file() is to
trucate the file.  Overwrite_file() should be used in situations where
you have a file that always needs to have contents, even in the middle
of an update.

read_dir() returns all of the entries in a directory except for "."  and
"..".  It croaks if it cannot open the directory.


AUTHOR
======

David Muir Sharnoff <muir@idiom.com>




File: pm.info, Node: File/Sync, Next: File/Tools, Prev: File/Slurp, Up: Module List

Perl access to fsync() and sync() function calls
************************************************



NAME
====

File::Sync - Perl access to fsync() and sync() function calls


SYNOPSIS
========

     use File::Sync qw(fsync sync);
     fsync(FILEHANDLE) or die "fsync: $!";
     sync();

     use IO::File;
     $fh = IO::File->new("> /tmp/foo") 
         or die "new IO::File: $!";
     ...
     $fh->fsync() or die "fsync: $!";


DESCRIPTION
===========

The fsync() function takes a Perl file handle as its only argument, and
passes its fileno() to the C function fsync().  It returns undef on
failure, or *true* on success.

The fsync_fd() function is used internally by fsync(); it takes a file
descriptor as its only argument.

The sync() function is identical to the C function sync().

This module does *not* export any methods by default, but fsync() is
made available as a method of the FileHandle and IO::Handle classes.


NOTES
=====

Doing fsync() if the stdio buffers aren't flushed (with $| or the
autoflush method) is probably pointless.

Calling sync() too often on a multi-user system is slightly antisocial.


AUTHOR
======

Carey Evans <*c.evans@clear.net.nz*>


SEE ALSO
========

perl(1), fsync(2), sync(2), perlvar(1)




