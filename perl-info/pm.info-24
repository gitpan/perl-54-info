Info file: pm.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `bigpm.texi'
using `texinfmt.el' version 2.32 of 19 November 1993.





File: pm.info, Node: Graph/Kruskal, Next: Graph/Node, Prev: Graph/Element, Up: Module List

Kruskal's Algorithm for Minimal Spanning Trees in Graphs
********************************************************



NAME
====

Graph::Kruskal - Kruskal's Algorithm for Minimal Spanning Trees in
Graphs

Computes the Minimal Spanning Tree of a given graph according to some
cost function defined on the edges of the graph.


SYNOPSIS
========

   * `use Graph::Kruskal qw(define_vortices define_edges' `heapify
     makeheap heapsort find union kruskal example);'

   * `use Graph::Kruskal qw(:all);'

   * `&define_vortices(2,3,5,7,11,13,17,19,23,29,31);'

     Define a list of vortices (integers > 0)

   * `&define_edges( 2,13,3, 3,13,2, 5,13,1, 3,5,2, 3,29,21 );'

     Define (non-directed) edges on the vortices previously defined
     (always in triplets: "from" vortice, "to" vortice and cost of that
     edge)

   * `&heapify($i,$n);'

     Main subroutine for sorting the edges according to their costs

   * `&makeheap($n);'

     Routine to initialize sorting of the edges

   * `&heapsort($n);'

     The famous heapsort algorithm (not needed for Kruskal's algorithm
     as a whole but included here for the sake of completeness) for
     sorting the edges according to their costs

   * `&find($i);'

   * `&union($i,$j);'

     Disjoint (!) sets are stored as trees in an array in this
     algorithm. Each element of some set (a cell in the array) contains
     a pointer to (the number of) another element, up to the root
     element that does not point anywhere, but contains the (negative)
     number of elements the set contains. The number of the root element
     is also used as an identifier for the set.

     Example:

          i  : |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |
              -------------+-----+-----+-----+-----+-----+-----+-----+-----+
               parent[i] : | -4  | -3  |  1  |  2  |  1  | -1  |  3  |  4  |

     This array contains the three sets S1, S2 and S6:

          1           2           6
                             / \          |
                            3   5         4
                           /              |
                          7               8

     "find" returns the number of the root element (= the identifier of
     the set) of the tree in which the given element is contained:

          find(a) := i  so that  a in Si

     It also reduces the height of that tree by changing all the
     pointers from the given element up to the root element to point
     DIRECTLY to the root element.

     Example:

          find(7) returns "1" and modifies the array as follows:

          i  : |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |
              -------------+-----+-----+-----+-----+-----+-----+-----+-----+
               parent[i] : | -4  | -3  |  1  |  2  |  1  | -1  |  1  |  4  |

          1           2           6
                             /|\          |
                            3 5 7         4
                      |
                      8

     "union" takes the identifiers of two sets (= the numbers of their
     respective root elements) and merges the two sets by appending one
     of the two trees to the other. It always appends the SMALLER set to
     the LARGER one (to keep the height of the resulting tree as small
     as possible) and updates the number of elements contained in the
     resulting set which is stored in the root element's cell of the
     array.

     Example:

          union(2,6) does the following:

          i  : |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |
              -------------+-----+-----+-----+-----+-----+-----+-----+-----+
               parent[i] : | -4  | -4  |  1  |  2  |  1  |  2  |  1  |  4  |

          1           2
                             /|\         / \
                            3 5 7       4   6
                    |
                    8

          complexity for O(n) "find" operations: O( G(n) n )

          complexity for one "union" operation: O(1)

          complexity for O(n) ( "find" + "union" ) operations: O( G(n) n )

          where  G(n) := min{ j | F(j) >= n }

          and    F(j) := 1            for j = 0
                 F(j) := 2 ^ F(j-1)   for j > 0

          also,  G(n) <= ld n         for all n

   * `&kruskal();'

     This routine carries out the computations associated with Kruskal's
     algorithm.

     Returns an array of hashes (each hash containing the keys "from",
     "to" and "cost" and the corresponding values) representing the
     minimal spanning tree of the graph previously defined by calls to
     "define_vortices" and "define_edges".

     The result can also be found in @Graph::Kruskal::T.

     See the implementation of the subroutine "example" to see how to
     access this array directly (remember to fully qualify the name of
     this array in your program, i.e., use "@Graph::Kruskal::T" instead
     of just "@T", since this array is not exported - or your program
     will not work!)

   * `&example();'

     Demonstrates how to use the various subroutines in this module.

     Computes the minimal spanning tree of a sample graph.

     Just say "use Graph::Kruskal qw(example);" and "&example();" in a
     little Perl script to see it "in action".


DESCRIPTION
===========

This algorithm computes the Minimal Spanning Tree of a given graph
according to some cost function defined on the edges of that graph.

Input: A set of vortices which constitute a graph (some cities on a map,
for example), a set of edges (i.e., roads) between the vortices of the
(non-directed and connected) graph (i.e., the edges can be traveled in
either direction, and a path must exist between any two vortices), and
the cost of each edge (for instance, the geographical distance).

Output: A set of edges forming a spanning tree (i.e., a set of edges
linking all vortices, so that a path exists between any two vortices)
which is free of circles (because it's a tree) and which is minimal in
terms of the cost function defined on the set of edges.

See Aho, Hopcroft, Ullman, "The Design and Analysis of Computer
Algorithms" for more details on the algorithm.


SEE ALSO
========

Math::MatrixBool(3), Math::MatrixReal(3), DFA::Kleene(3),
Set::IntegerRange(3), Set::IntegerFast(3), Bit::Vector(3).


VERSION
=======

This man page documents "Graph::Kruskal" version 2.0.


AUTHOR
======

Steffen Beyer <sb@sdm.de>.


COPYRIGHT
=========

Copyright (c) 1995, 1996, 1997 by Steffen Beyer. All rights reserved.


LICENSE
=======

This package is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.




File: pm.info, Node: Graph/Node, Next: HTML/AsSubs, Prev: Graph/Kruskal, Up: Module List

object class for a node in a directed graph
*******************************************



NAME
====

Graph::Node - object class for a node in a directed graph


SYNOPSIS
========

     use Graph::Node;
     use Graph::Edge;

     $parent = new Graph::Node('LABEL' => 'Parent Node');
     $child  = new Graph::Node('LABEL' => 'Child Node');
     $edge   = new Graph::Edge('FROM' => $parent,
     			     'TO'   => $child);

     $parent->save('simple.daVinci', 'daVinci');


DESCRIPTION
===========

The Graph::Node module implements a *node* in a *directed graph*.  A
graph is constructed using Node and Edge objects; edges are defined with
the Graph::Edge class.


CONSTRUCTOR
===========

Create a new Node object.  Returns a reference to a Graph::Node object:

     $node = new Graph::Node('ID'    => 'identifier',
     			   'LABEL' => 'text string'
     			  );

The `ID' attribute is optional, and must be a unique string identifying
the edge. If you do not specify the `ID' attribute, the edge will be
assigned a unique identifier automatically.

The `LABEL' attribute is also optional, and specifies a text string
which should be associated with the node.  This should be used when
drawing the Node, for example.


METHODS
=======

This class implements the following methods:

The save method is described below.  The setAttribute and getAttribute
methods are described in the documentation for the base class
Graph::Element, where they are defined.


save - save directed graph to a file
------------------------------------

$filename
     The name or fullpath of the file to save the directed graph into.

$format
     An optional string which specifies the format which the graph
     should be saved as.  At the moment the only format supported is
     *daVinci*, which generates the file format used by the *daVinci*
     graph visualisation system.

The `save()' method is used to save a directed graph into a file.  At
the moment the graph is saved in the format used by the daVinci graph
visualization system (daVinci v2.0).

The filename extension should be *.daVinci*, otherwise daVinci will
complain.


SEE ALSO
========

Graph::Node
     for a description of the Node class.

Graph::Element
     for a description of the base class, including the attribute
     methods.


AUTHOR
======

Neil Bowers <neilb@cre.canon.co.uk>


COPYRIGHT
=========

Copyright (c) 1997 Canon Research Centre Europe. All rights reserved.
This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.




File: pm.info, Node: HTML/AsSubs, Next: HTML/Element, Prev: Graph/Node, Up: Module List

functions that construct a HTML syntax tree
*******************************************



NAME
====

HTML::AsSubs - functions that construct a HTML syntax tree


SYNOPSIS
========

     use HTML::AsSubs;
     $h = body(
     	   h1("This is the heading"),
     	   p("This is the first paragraph which contains a ",
     	     a({href=>'link.html'}, "link"),
     	     " and an ",
     	     img({src=>'img.gif', alt=>'image'}),
     	     "."
     	    ),
     	  );
     print $h->as_HTML;


DESCRIPTION
===========

This module exports functions that can be used to construct various HTML
elements. The functions are named after the tags of the correponding
HTML element and are all written in lower case. If the first argument is
a hash then it will be used to initialize the attributes of this
element. The remaining arguments are regarded as content.


ACKNOWLEDGEMENT
===============

This module was inspired by the following message:

     Date: Tue, 4 Oct 1994 16:11:30 +0100
     Subject: Wow! I have a large lightbulb above my head!

     Take a moment to consider these lines:

     %OVERLOAD=( '""' => sub { join("", @{$_[0]}) } );

     sub html { my($type)=shift; bless ["<$type>", @_, "</$type>"]; }

     :-)  I *love* Perl 5!  Thankyou Larry and Ilya.

     Regards,
     Tim Bunce.

     p.s. If you didn't get it, think about recursive data types: html(html())
     p.p.s. I'll turn this into a much more practical example in a day or two.
     p.p.p.s. It's a pity that overloads are not inherited. Is this a bug?


BUGS
====

The exported link() function overrides the builtin link() function.  The
exported tr() function must be called using &tr(...) syntax because it
clashes with the builtin tr/../../ operator.


SEE ALSO
========

*Note HTML/Element: HTML/Element,




File: pm.info, Node: HTML/Element, Next: HTML/Embperl, Prev: HTML/AsSubs, Up: Module List

Class for objects that represent HTML elements
**********************************************



NAME
====

HTML::Element - Class for objects that represent HTML elements


SYNOPSIS
========

     require HTML::Element;
     $a = new HTML::Element 'a', href => 'http://www.oslonett.no/';
     $a->push_content("Oslonett AS");

     $tag = $a->tag;
     $tag = $a->starttag;
     $tag = $a->endtag;
     $ref = $a->attr('href');

     $links = $a->extract_links();

     print $a->as_HTML;


DESCRIPTION
===========

Objects of the HTML::Element class can be used to represent elements of
HTML.  These objects have attributes and content.  The content is an
array of text segments and other HTML::Element objects.  Thus a tree of
HTML::Element objects as nodes can represent the syntax tree for a HTML
document.

The following methods are available:


$h = HTML::Element->new('tag', 'attrname' => 'value',...)
---------------------------------------------------------

The object constructor.  Takes a tag name as argument. Optionally,
allows you to specify initial attributes at object creation time.


$h->tag()
---------

Returns (optionally sets) the tag name for the element.  The tag is
always converted to lower case.


$h->starttag()
--------------

Returns the complete start tag for the element.  Including leading "<",
trailing ">" and attributes.


$h->endtag()
------------

Returns the complete end tag.  Includes leading "</" and the trailing
">".


$h->parent([$newparent])
------------------------

Returns (optionally sets) the parent for this element.


$h->implicit([$bool])
---------------------

Returns (optionally sets) the implicit attribute.  This attribute is
used to indicate that the element was not originally present in the
source, but was inserted in order to conform to HTML strucure.


$h->is_inside('tag',...)
------------------------

Returns true if this tag is contained inside one of the specified tags.


$h->pos()
---------

Returns (and optionally sets) the current position.  The position is a
reference to a HTML::Element object that is part of the tree that has
the current object as root.  This restriction is not enforced when
setting pos(), but unpredictable things will happen if this is not true.


$h->attr('attr', [$value])
--------------------------

Returns (and optionally sets) the value of some attribute.


$h->content()
-------------

Returns the content of this element.  The content is represented as a
reference to an array of text segments and references to other
HTML::Element objects.


$h->is_empty()
--------------

Returns true if there is no content.


$h->insert_element($element, $implicit)
---------------------------------------

Inserts a new element at current position and updates pos() to point to
the inserted element.  Returns $element.


$h->push_content($element_or_text,...)
--------------------------------------

Adds to the content of the element.  The content should be a text
segment (scalar) or a reference to a HTML::Element object.


$h->delete_content()
--------------------

Clears the content.


$h->delete()
------------

Frees memory associated with the element and all children.  This is
needed because perl's reference counting does not work since we use
circular references.


$h->traverse(\&callback, [$ignoretext])
---------------------------------------

Traverse the element and all of its children.  For each node visited,
the callback routine is called with the node, a startflag and the depth
as arguments.  If the $ignoretext parameter is true, then the callback
will not be called for text content.  The flag is 1 when we enter a node
and 0 when we leave the node.

If the returned value from the callback is false then we will not
traverse the children.


$h->extract_links([@wantedTypes])
---------------------------------

Returns links found by traversing the element and all of its children.
The return value is a reference to an array.  Each element of the array
is an array with 2 values; the link value and a reference to the
corresponding element.

You might specify that you just want to extract some types of links.
For instance if you only want to extract <a href="..."> and <img
src="..."> links you might code it like this:

     for (@{ $e->extract_links(qw(a img)) }) {
         ($link, $linkelem) = @$_;
         ...
     }


$h->dump()
----------

Prints the element and all its children to STDOUT.  Mainly useful for
debugging.  The structure of the document is shown by indentation (no
end tags).


$h->as_HTML()
-------------

Returns a string (the HTML document) that represents the element and its
children.


BUGS
====

If you want to free the memory assosiated with a tree built of
HTML::Element nodes then you will have to delete it explicitly.  The
reason for this is that perl currently has no proper garbage collector,
but depends on reference counts in the objects.  This scheme fails
because the parse tree contains circular references (parents have
references to their children and children have a reference to their
parent).


SEE ALSO
========

*Note HTML/AsSubs: HTML/AsSubs,


COPYRIGHT
=========

Copyright 1995,1996 Gisle Aas.  All rights reserved.

This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


AUTHOR
======

Gisle Aas <aas@sn.no>




File: pm.info, Node: HTML/Embperl, Next: HTML/Entities, Prev: HTML/Element, Up: Module List

Perl extension for embedding perl code in HTML documents
********************************************************



NAME
====

HTML::Embperl - Perl extension for embedding perl code in HTML documents


DESCRIPTION
===========

Embperl is a perl extension module which gives you the ability to embed
perl code in HTML documents (much like Server Side Includes for shell
commands).

Embperl can operate in one of four modes:

Offline
     converts a HTML file with embedded perl statements into a standard
     HTML file.

     *embpexec.pl [-o outputfile][-l logfile][-d debugflags] htmlfile [query_string]*

     htmlfile
          is the full pathname of the html file which should be
          processed by Embperl

     query_string
          is optional and has same meaning as the environment variable
          QUERY_STRING when invoked as CGI-Script, i.e. everything
          following the first "?" in an URL. <query_string> should be
          url-encoded. Default is no query_string.

     *-o outputfile*
          gives the filename to which the output is written. Default is
          stdout.

     *-l logfile*
          is optional and give the filename of the logfile. Default is
          /tmp/embperl.log.

     *-d debugflags*
          specifies the level of debugging (What is written to the
          logfile). Default is nothing. See below for excat values.

*As CGI-Script*
     instead of directly retrieving the document from the web-server, it
     is processed by the CGI-Script and the result is send to the
     client.

     *embpexec.pl*

     If `embpexec.pl' is invoked without any parameters and the
     environment variable PATH_TRANSLATED is set, it invoke it self as
     CGI-Script. That means form data is taken either from the
     environment variable QUERY_STRING or from stdin depending on
     CONTENT_LENGTH (this will be set by httpd depending on the method
     GET or POST). Input is taken from the file pointed to by
     PATH_TRANSLATED and output is send to stdout. The logfile is
     generated at it's default location (this is configurable via the
     environment variable EMBPERL_LOG).

     To use this mode you have to copy *embpexec.pl* to your cgi-bin
     directory. You can invoke it with the URL
     http://www.domain.xyz/cgi- bin/embpexec.pl/url/of/your/document.

     The /url/of/your/document will be passed to Embperl by the web
     server.  Normal processing i.e. aliasing etc. takes place before it
     is made to the filename contained in PATH_TRANSLATED.

     If you are running apache httpd you can also define *embpexec.pl*
     as a handler for a specific file extention or directory.

     Example of Apache `srm.conf':

          <Directory /path/to/your/html/docs>
          Action text/html /cgi-bin/embperl/embpexec.pl
          </Directory>

*From mod_perl*
     (Apache httpd), this works like the CGI-Script, but with the
     advantage that the script is compiled only once at server startup,
     where also other one time action (such as opening files and
     databases ) can take place.  This will drastically reduce response
     times for the request.  To use this you have to compile `Apache
     httpd' with `mod_perl' and add `HTML::Embperl' as `PerlHandler'.

     Example of Apache `srm.conf':

          SetEnv EMBPERL_DEBUG 237

          Alias /embperl /path/to/embperl/eg

          <Location /embperl/x>
          SetHandler perl-script
          PerlHandler HTML::Embperl
          </Location>

*As standalone process*
     At the moment this is only for debugging because it can only handle
     one request at a time, no serialization takes place if more than
     one client is accessing an embperl-document. This mode has the same
     advantage as mod_perl, because the process is once started and
     running (hopefully) until the web server goes down. Data from the
     web-server is transferred via two named pipes. The first gives the
     data of the request and is feeded by a small c-program which is
     invoked as a CGI-Script and the second transfers the output back to
     the CGI-Program, which sends it to the client. This mode should
     work in conjunction with every web server, but to really use it a
     serialization (and maybe a management for multiple processes must
     be done)

     *embpexec.pl -D*

     or

     *embpexec.pl* if PATH_TRANSLATED is not defined as a environment variable

     This start Embperl as a Daemon. You have also to copy the file
     embcgi to your cgi-bin directory. This program is invoked as
     CGI-Script by the web server. The names of the named pipe which
     will be used must be changed in epmain.c and embpcgi.c before
     compiling it and the pipes must be created by hand (i.e. mkfifo)
     with read and write access for both processes, before starting the
     processes.  Input- and Formdata is the same as for the
     CGI-Script. Logfile outut is going to stdout.

     *WARNING:* Everybody who has write access to the named pipe can do thinks as 
     user which runs Embperl daemon. So be carefully not to run Embperl
     as root unless you are sure nobody else can access it.


Runtime configuration
=====================

At the moment there are a few things which could be configured at
runtime.  This is done by setting environment variables, either on the
command line (when working offline) or in your web servers configuration
file. Most http daemons understand

SetEnv <var> <value>

EMBPERL_LOG
     gives the pathname of the log file. This will contain more or less
     infos about what Embperl is doing depending on the debug settings
     (see below).  The log-output is specially intended to see what your
     embedded perl code is doing and to debug it.  Default is
     */tmp/embperl.log*

EMBEPRL_VIRTLOG
     gives a virtual location, where you can access the embperl logfile
     with a browser.  This feature is disabled (default) if
     EMBPERL_VIRTLOG is not specified. See also dbgLogLink.

EMBPERL_DEBUG
     This is a bitmask which specifies what should be written to the log
     The following values are defined:

     dbgStd = 1, Minimum Infos dbgMem = 2, Memory and Scalar Value
     allocation dbgEval = 4, Arguments and result of evals dbgCmd = 8,
     Metacommands and HTML tags which are processed dbgEnv = 16, List
     environement variables (In this release only in daemon mode)
     dbgForm = 32, List form data dbgTab = 64, Log processing of dynamic
     tables dbgInput = 128, Log processing of html input tags
     dbgFlushOutput = 256, Flush output after every write (Should
     normaly not set. Only for debugging when Embperl crashs)
     dbgFlushLog = 512, Flush logfile after every line (Should normaly
     not set. Only for debugging when Embperl crashs, log is automatily
     flushed after each html file) dbgAllCmds = 1024, Logs all commands
     and HTML tags, regardless if they are really excuted or
     not. (Showing a + or - to tell you if they are executed).
     dbgSource = 2048, Logs the next piece of the HTML-source which is
     processed. (Gives a lot of output!)  dbgFunc = 4096, Only
     anvailable when compiled with -DEPDEBUGALL. Normaly only used for
     debugging Embperl itself. Logs all functionentrys to the logfile
     (lot of data!)  dbgLogLink = 8192, Inserts a link on the top of
     each page, which can be used to view the log for current html
     file. See also EMBEPRL_VIRTLOG under configuration.  A good value
     to start is `237'. If Embperl crashs (you get a Segmentation fault)
     add `512' so the logfile is flushed and you can see where Embperl
     crashs.

EMBPERL_NAMESPACE
     gives the name of the namesspace within the code should be
     executed. If not defined executes in namespace *HTML::Embperl::*
     with no operator restrictions. (with a normal eval statement).

     NOTE at the moment if you use a namespace it is added automatiliy
     with all operators allowed. This will change in furthrer releases.


SYNTAX
======

Embperl understands four categories of commands. The first three are
special Embperl command, the last category are some HTML-Tags which can
trigger a special processing. Before the special Embperl-commands are
processed and for the VALUE attribute of the input tag (see below), all
HTML-Tags are removed and special HTML characters are translated to
their ascii values (e.g. &lt; is translated to "<" ). Embperl-commands
can spawn multiple lines and not necessarily starts or ends at line
boundary. You can escape from this behavior by preceding the special
character or HTML tag with a backslash. This is done, so you can create
your embperl-html- file with your favorite (WYSIWYG) HTML-Editor, no
matter if it inserts tags like line breaks or formatting into your
Embperl-commands where you don't want them.  All Embperl-commands starts
with a "[" and ends with a "]". To get a real "[" you must enter "[[".

I am not using sgml comments (i.e. <! ... !> or similar things) because
some HTML-Editors can't create them or it's much more
complicated. Sinces every HTML-Editor takes [ and ] as normal text,
there should be no problem.

*[+ perl-code +]*
     Replace the command with the result of the perl code (The value
     returned by eval "perl-code").  As `perl-code' you can use
     everything which can be an argument to the perl eval statement (see
     Security below for restrictions).  Examples:

          [+$a+]          replaces the [+$a+] with the content of the variable $a
          [+$a+1+]        every expression can be used
          [+ $x[$i] +]    also array and hashes or more complex expressions works

     `NOTE:' White space are ignored The output will automaticly HTML
     escaped (e.g. "<" is translated to &lt;).  You do have to care
     about it.

*[- perl-code -]*
     Executes the perl-code, but delete the whole command from the HTML
     output.

     Examples:

          [-$a=1-]        set the variable $a to one, no output will be generated
          [-use somemodule-] you can use other modules
          [-$i=0; while ($i<5) {$i++} -] even more complex statements or multiple 
                                         statements are possible.

     NOTE: Statements like if, while, for, etc. must be included in one
     embperl command. You can not have the if in one command block and
     the terminating "}" or else in another.

*[$cmd arg$]*
     Execute a Embperl metacommand <cmd> can be one of the following
     (<arg> varies depending on <cmd>):

     *if, elsif, else, endif*
          everything following the if metacommand until the else, elsif
          or endif is only outputted if the perl expression given in
          <arg> is true. else and elsif works analog.

          Examples:

               [$if $ENV{REQUEST_METHOD} eq 'GET' $]
               Method was GET<BR>
               [$else$]
               Method other than GET used<BR>
               [$endif$]

          This will send one of the two sentence to the client,
          depending on the request method used to call the document.

     *while, endwhile*
          Executes a loop until the <arg> given to while is false

          Example: (see eg/x/while.htm)

               [- $i = 0; @k = keys %ENV -]
               [$ while ($i &lt; $#k) $]
               [+ $k[$i] +] = [+ $ENV{$k[$i]} +]<BR>
               [- $i++ -]
               [$ endwhile $]

          This will send a list of all environment variables to the
          client.

          NOTE: The '&lt;' is translated to '<' before call the perl
          eval.

     hidden
          <arg> consists of zero, one or two names of hashs (without the
          leading %).  The hidden metacommand will generated hidden
          fields for all data contained in first hash and not in second
          hash. Default for first hash is %fdat and for second hash
          %idat. This is intended for situations where you want to pass
          data from one forms to the next, e.g. two forms which should
          be filled one after each other (e.g. an input form and a
          second form to review and accept the input). Here you can
          transport the data from previous forms within hidden
          fields. (See eg/x/neu.htm for an example).

          NOTE: This should only be used for small amount of data, since
          the hidden fields are sent to the browser, which sends it back
          at next request. If you have large data, store it within a
          file with a unique name and send only the filename within the
          hidden field. But be aware of the fact, that the data could be
          change by the browser if the user didn't behave exactly as you
          except. Your program should handle such situations properly.

*HTML Tags*
     Embperl recognizes the following HTML Tags (all other are simply
     passed through, as long as they not part of a Embperl command).

     *table, /table, tr, /tr*
          Embperl can generate dynamic tables (one or two
          dimensional). You only have to specify one row/column.
          Embperl generates as much rows/columns as nessecary. This is
          done by using the magic variables $row, $col and $cnt. If you
          don't use $row/$cnt/$cnt within a table, Embperl does nothing
          and simply pass the table through.  Embperl checks if the
          varibale $row/$col/$cnt is used.  Embperl repeats all text
          between <table> and </table>, as long the expressions in which
          $row or $cnt occurs is/are defined.  Embperl repeats all text
          between <tr> and </tr>, as long the expressions in which $col
          or $cnt occurs is/are defined.

          See also $tabmode (below) for end of table criteria.

          Examples: (see eg/x/table.htm for more examples)

               [- @k = keys %ENV -]
               <table>
                   <tr>
                       <td>[+ $i=$row +] </td>
                       <td>[+ $k[$row] +] </td>
                       <td>[+ $ENV{$k[$i]} +] </td>
                   </tr> 
               </table>

          This will show all entries in array @k (which contains the
          keys from %ENV), so the whole environment is displayed (like
          in the while example), with the first column containing the
          index (from 0) and the second containing the content of the
          array and the third the environment variable.

          This could be used to display the result of database query if
          you have the result in an array. You make as much columns as
          you need. It is also possible to call a fetch subroutine in
          each table row.

     *dir, menu, ol, ul, dl, /dir, /menu, /ol, /ul, /dl*
          Lists are treated excatly as one dimensional tables. Only
          $row, $maxrow, $cnt, $maxcnt and $tabmode are honoured. $col
          and $maxcol are ignored.

     input
          The input tag interacts with the hashs %idat und %fdat. If the
          input tag has no value and a key exists with the same text as
          the NAME attribute of the input tag, Embperl generates a VALUE
          attribute which the corresponding value to the hashkey.  All
          values of <input> tags are stored in the hash %idat, which
          NAME as hashkey and VALUE as hashvalue.  Special processing is
          made for TYPE=RADIO and TYPE=CHECKBOX. If the VALUE attribute
          contains the same text as the value of the hash the CHECKED
          attribute is inserted else it is removed.  So if you specify
          as action url the file which contains the form itself, the
          form will be redisplayed with same values as entered in the
          first form. (See eg/x/neu.htm for an example)

     *textarea, /textarea*
          The textarea tags treated excatly like other input fields (see
          above)


Predefined variables
====================

Embperl has some special variables which has a predefined meaning.

%ENV
     contains the environment as seen from a CGI-Script.

%fdat
     contains all the formdata send to the script by the calling
     form. The NAME attribute build the key and the VALUE attribute is
     used as hashvalue.  Embperl doesn't matter if it's called with GET
     or POST method. (but there may be restrictions on the length of
     parameters using GET, so it's more save to use POST)

*@ffld*
     contains all the field names in the order they where send by the
     browser (normally as they appear in your form)

%idat
     contains all the values from all input tags processed so far.

$row
     row count for use in dynamic tables (see html tag table)

$maxrow
     maxium number of rows displayed in a table. This is set to 100 by
     default to prevent endless loops. (see html tag table)

$col
     column count for use in dynamic tables (see html tag table)

$maxcol
     maxium number of columns displayed in a table. This is set to 10 by
     default to prevent endless loops. (see html tag table)

$cnt
     contains the number of tables cells displayed so far (see html tag
     table)

$tabmode
     determintas how the end of a dynamic table is detected:

     end of table

          1	end when a expression with $row gets undefined (The row containing the undefined is not displayed)
          2	end when a expression with $row gets undefined (The row containing the undefined is displayed)
          3	end when $maxrow rows displayed

     end of row

          16	end when a expression with $col gets undefined (The column containing the undefined is not displayed)
          32	end when a expression with $col gets undefined (The column containing the undefined is displayed)
          63	end when $maxcol column displayed

     default is 17 which is correct for all sort of arrays. You rarely
     should have to change it.  The two values can be added together

$req_rec
     This variable is only available when running under control of
     mod_perl.  It contains the request record needed to access the
     apache server api.  See *perldoc Apache* for more information.

LOG
     is the filehandle of the embperl logfile, by writing print LOG
     "something" you can add lines to the logfile. NOTE: The logfileline
     should always start with the pid of the currect process and
     continue with a four character signature delimited by a ':', which
     specifies the log reason.

     Example: print LOG "[$$]ABCD: your text\n" ;

     NOTE 2: You must set the dbgFlushLog (= 512) to get the right order
     in the logfile.  This will not be necessary any more in one of the
     next releases.


Namespaces and operator restrictions
====================================

Since most web servers will contain more than one document, it is
necessary to protected them against each other. Embperl does this by
using perl-namespaces. You can assign different names spaces to
different directories (or even files within apache 1.2). If an Embperl
document is scaned in a namespace all execution takes place within this
namesspace and the code is not allowed to access another namespace as
his own. This is done by the perl module Safe.pm.  This gives also the
ability to restrict the usage of perl operators, which can be defined
with a operator mask.  At the moment these features are at experimental
state and can't be fully configured. Also there seems to be a memory
leak.


UTILITY FUNCTIONS
=================

*MailFormTo ($MailTo, $Subject)*
     Sends the content of the hash %fdat in the order specified by @ffld
     to the given *$MailTo* adresse, with the subject of *$Subject*.

     If you specifiy the following example code as action in your form

          <form action="x/feedback.htm" method="POST"
           enctype="application/x-www-form-urlencoded">

     The content of the form will be mailed to the given email adress.

     Example:

          <html>
          <head>
          <title>Feedback</title>
          </head>
          <body>
                 Your data has been sccesfully send!
                 [- MailFormTo ('webmaster@domain.xy', 'Mail from WWW Form') -]
          </body>
          </html>

     *NOTE:* You must have Net::SMTP (from libnet package) installed to use this function.


BUGS
====

At the moment Namespaces are at experimental state and can't be fully
configured. Also there seems to be a memory leak.

Tainting doesn't work correct under perl5.004.


FEEDBACK and BUGREPORTS
=======================

Please give me a feedback if you use/test this module. Bugs, questions,
thinks you would find useful etc. are discussed on the mod_perl mailling
list.

>From mod_perl README:
 
>For comments, questions, bug-reports, announcements, etc., join the
>Apache/Perl mailing list by sending mail to
>listserv@listproc.itribe.net with the string "subscribe modperl" in
>the body.

>There is a hypermail archive for this list available from:
>http://outside.organic.com/mail-archives/modperl/


SUPPORT
=======

You can get free support on the mod_perl mailing list (see above).  If
you need commercial support (with a garantie for response time/a
solution) for Embperl or want a web site where you can run your
Embperl/mod_perl scripts without setting up your own internet
www-server, please send an email to info@ecos.de.


WWW-LINKS
=========

mod_perl http://www.osf.org/~dougm/apache/ mod_perl FAQ
http://www.ping.de/~fdc/mod_perl/ Embperl
http://www.osf.org/~dougm/apache/embperl.html apache web server
http://www.apache.org/ see also
http://www.perl.com/CPAN/modules/by-module/Apache/apache-modlist.html


AUTHOR
======

G.Richter <richter@dev.ecos.de>


SEE ALSO
========

perl(1), mod_perl, apache httpd.




File: pm.info, Node: HTML/Entities, Next: HTML/FormatPS, Prev: HTML/Embperl, Up: Module List

Expand HTML entities in a string
********************************



NAME
====

decode - Expand HTML entities in a string

encode - Encode chars in a string using HTML entities


SYNOPSIS
========

     use HTML::Entities;

     $a = "V&aring;re norske tegn b&oslash;r &#230res";
     decode_entities($a);
     encode_entities($a, "\200-\377");


DESCRIPTION
===========

The decode_entities() routine replaces valid HTML entities found in the
string with the corresponding ISO-8859/1 character.

The encode_entities() routine replaces the characters specified by the
second argument with their entity representation.  The default set of
characters to expand are control chars, high-bit chars and the '<', '&',
'>' and '"' character.

Both routines modify the string passed in as the first argument and
return it.

If you prefer not to import these routines into your namespace you can
call them as:

     use HTML::Entities ();
     $encoded = HTML::Entities::encode($a);
     $decoded = HTML::Entities::decode($a);

The module can also export the %char2entity and the %entity2char hashes
which contains the mapping from all characters to the corresponding
entities.


COPYRIGHT
=========

Copyright 1995-1997 Gisle Aas. All rights reserved.

This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.




File: pm.info, Node: HTML/FormatPS, Next: HTML/FormatText, Prev: HTML/Entities, Up: Module List

Format HTML as postscript
*************************



NAME
====

HTML::FormatPS - Format HTML as postscript


SYNOPSIS
========

     require HTML::FormatPS;
     $html = parse_htmlfile("test.html");
     $formatter = new HTML::FormatPS
     		   FontFamily => 'Helvetica',
     		   PaperSize  => 'Letter';
     print $formatter->format($html);


DESCRIPTION
===========

The HTML::FormatPS is a formatter that outputs PostScript code.
Formatting of HTML tables and forms is not implemented.

You might specify the following parameters when constructing the
formatter:

PaperSize
     What kind of paper should we format for.  The value can be one of
     these: A3, A4, A5, B4, B5, Letter, Legal, Executive, Tabloid,
     Statement, Folio, 10x14, Quarto.

     The default is "A4".

PaperWidth
     The width of the paper in points.  Setting PaperSize also defines
     this value.

PaperHeight
     The height of the paper in points.  Setting PaperSize also defines
     this value.

LeftMargin
     The left margin in points.

RightMargin
     The right margin in points.

HorizontalMargin
     Both left and right margin at the same time.  The default value is
     4 cm.

TopMargin
     The top margin in points.

BottomMargin
     The bottom margin in points.

VerticalMargin
     Both top and bottom margin at the same time.  The default value is
     2 cm.

PageNo
     The parameter determines if we should put page numbers on the
     pages.  The default is yes, so you have to set this value to 0 in
     order to suppress page numbers.

FontFamily
     The parameter specifies which family of fonts to use for the
     formatting.  Legal values are "Courier", "Helvetica" and "Times".
     The default is "Times".

FontScale
     All fontsizes might be scaled by this factor.

Leading
     How much space between lines.  This is a factor of the fontsize
     used for that line.  Default is 0.1.


SEE ALSO
========

*Note HTML/Formatter: HTML/Formatter,


COPYRIGHT
=========

Copyright (c) 1995 Gisle Aas. All rights reserved.

This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


AUTHOR
======

Gisle Aas <aas@oslonett.no>




File: pm.info, Node: HTML/FormatText, Next: HTML/Formatter, Prev: HTML/FormatPS, Up: Module List

Format HTML as text
*******************



NAME
====

HTML::FormatText - Format HTML as text


SYNOPSIS
========

     require HTML::FormatText;
     $html = parse_htmlfile("test.html");
     $formatter = new HTML::FormatText;
     print $formatter->format($html);


DESCRIPTION
===========

The HTML::FormatText is a formatter that outputs plain latin1 text.  All
character attributes (bold/italic/underline) are ignored.  Formatting of
HTML tables and forms is not implemented.


SEE ALSO
========

*Note HTML/Formatter: HTML/Formatter,


COPYRIGHT
=========

Copyright (c) 1995 Gisle Aas. All rights reserved.

This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


AUTHOR
======

Gisle Aas <aas@oslonett.no>




File: pm.info, Node: HTML/Formatter, Next: HTML/HeadParser, Prev: HTML/FormatText, Up: Module List

Base class for HTML formatters
******************************



NAME
====

HTML::Formatter - Base class for HTML formatters


SYNOPSIS
========

     package HTML::FormatXX;
     require HTML::Formatter;
     @ISA=qw(HTML::Formatter);


DESCRIPTION
===========

HTML formatters are able to format a HTML syntax tree into various
printable formats.  Different formatters produce output for different
output media.  Common for all formatters are that they will return the
formatted output when the format() method is called.  Format() takes a
HTML::Element as parameter.


SEE ALSO
========

*Note HTML/FormatText: HTML/FormatText,, *Note HTML/FormatPS: HTML/FormatPS,, *Note HTML/Element: HTML/Element,


COPYRIGHT
=========

Copyright (c) 1995 Gisle Aas. All rights reserved.

This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


AUTHOR
======

Gisle Aas <aas@oslonett.no>




File: pm.info, Node: HTML/HeadParser, Next: HTML/LinkExtor, Prev: HTML/Formatter, Up: Module List

Parse <HEAD> section of a HTML document
***************************************



NAME
====

HTML::HeadParser - Parse <HEAD> section of a HTML document


SYNOPSIS
========

     require HTML::HeadParser;
     $p = HTML::HeadParser->new;
     $p->parse($text) and  print "not finished";

     $p->header('Title')          # to access <title>....</title>
     $p->header('Content-Base')   # to access <base href="http://...">
     $p->header('Foo')            # to access <meta http-equiv="Foo" content="...">


DESCRIPTION
===========

The *HTML::HeadParser* is a specialized (and lightweight)
*HTML::Parser* that will only parse the <HEAD>...</HEAD> section of a
HTML document.  The parse() and parse_file() methods will return a FALSE
value as soon as a <BODY> element is found, and should not be called
again after this.

The *HTML::HeadParser* constructor takes an optional *HTTP::Headers*
object reference as argument.  The parser will update this header object
as the various <HEAD> elements are recognized.  If no header is given we
will create an internal (and initially empty) header object.  This
header object can be accessed with the header() method.

The following header fields are initialized from elements found in the
<HEAD> section of the HTML document:

Content-Base:
     The *Content-Base* header is initialized from the <base href="...">
     element.

Title:
     The *Title* header is initialized from the <title>...</title>
     element.

Isindex:
     The *Isindex* header will be added if there is a <isindex>
     element in the <head>.  The header value is initialized from the
     *prompt* attribute if it is present.  If not *prompt* attribute is
     given it will have '?' as the value.

X-Meta-Foo
     All <meta> elements will initialize headers with the prefix
     "X-Meta-".  If the element contains a *http-equiv* attribute, then
     it will be honored as the header name.


METHODS
=======

The following methods (in addition to those provided by the superclass)
are available:

$hp = HTML::HeadParser->new( [$header] )
$hp->parse( $text )
     Parses some HTML text (see HTML::Parser->parse()) but will return
     FALSE as soon as parsing should end.

$hp->header;
     Returns a reference to the HTML::Header object.

$hp->header( $key )
     Returns a header value.

$hp->as_string;
     Same as $hp->header->as_string


EXAMPLES
========

     $h = HTTP::Headers->new;
     $p = HTML::HeadParser->new($h);
     $p->parse(<<EOT);
     <title>Stupid example</title>
     <base href="http://www.sn.no/libwww-perl/">
     Normal text starts here.
     EOT
     undef $p;
     print $h->title;   # should print "Stupid example"


SEE ALSO
========

*Note HTML/Parser: HTML/Parser,, *Note HTTP/Headers: HTTP/Headers,


COPYRIGHT
=========

Copyright 1996-1997 Gisle Aas. All rights reserved.

This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


AUTHOR
======

Gisle Aas <aas@sn.no>




File: pm.info, Node: HTML/LinkExtor, Next: HTML/Parse, Prev: HTML/HeadParser, Up: Module List

Extract links from an HTML document
***********************************



NAME
====

HTML::LinkExtor - Extract links from an HTML document


SYNOPSIS
========

     require HTML::LinkExtor;
     $p = HTML::LinkExtor->new(\&cb, "http://www.sn.no/");
     sub cb {
         my($tag, %links) = @_;
         print "$tag @{[%links]}\n";
     }
     $p->parse_file("index.html");


DESCRIPTION
===========

The *HTML::LinkExtor* (link extractor) is an HTML parser that takes a
callback routine as parameter.  This routine is then called as the
various link attributes are recognized.

The *HTML::LinkExtor* is a subclass of *HTML::Parser*. This means that
the document should be given to the parser by calling the $p->parse() or
$p->parse_file() methods.


$p = HTML::LinkExtor->new([$callback[, $base]])
-----------------------------------------------

The constructor takes two optional argument. The first is a reference to
a callback routine. It will be called as links are found. If a callback
is not provided, then links are just accumulated internally and can be
retrieved by calling the $p->links() method. The $base is an optional
base URL used to absolutize all URLs found.

The callback is called with the lowercase tag name as first argument,
and then all link attributes as separate key/value pairs.  All non-link
attributes are removed.


$p->links
---------

Returns a list of all links found in the document.  The returned values
will be anonymous arrays with the follwing elements:

     [$tag, $attr => $url1, $attr2 => $url2,...]

The $p->links method will also truncate the internal link list.  This
means that if the method is called twice without any parsing in between
then the second call will return an empty list.

Also note that $p->links will always be empty if a callback routine was
provided when the *Note HTML/LinkExtor: HTML/LinkExtor, was created.


EXAMPLE
=======

This is an example showing how you can extract links as a document is
received using LWP:

     use LWP::UserAgent;
     use HTML::LinkExtor;
     use URI::URL;

     $url = "http://www.sn.no/";  # for instance
     $ua = new LWP::UserAgent;

     # Set up a callback that collect image links
     my @imgs = ();
     sub callback {
        my($tag, %attr) = @_;
        return if $tag ne 'img';  # we only look closer at <img ...>
        push(@imgs, values %attr);
     }

     # Make the parser.  Unfortunately, we don't know the base yet (it might
     # be diffent from $url)
     $p = HTML::LinkExtor->new(\&callback);

     # Request document and parse it as it arrives
     $res = $ua->request(HTTP::Request->new(GET => $url), sub {$p->parse($_[0])});

     # Expand all image URLs to absolute ones
     my $base = $res->base;
     @imgs = map { $_ = url($_, $base)->abs; } @imgs;

     # Print them out
     print join("\n", @imgs), "\n";


SEE ALSO
========

*Note HTML/Parser: HTML/Parser,


AUTHOR
======

Gisle Aas <aas@sn.no>




