Info file: pm.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `bigpm.texi'
using `texinfmt.el' version 2.32 of 19 November 1993.





File: pm.info, Node: PDL, Next: PDL-FAQ, Prev: Oraperl, Up: Module List

Perl Data Language extension module
***********************************



NAME
====


PDL - Perl Data Language extension module
-----------------------------------------

Version 1.11 release

"Why is it that we entertain the belief that for every purpose odd
numbers are the most effectual?" - Pliny the Elder.

*Karl Glazebrook, AAO, 24/Feb/1997. [kgb@aaoepp.aao.gov.au]*


DESCRIPTION
===========

The perlDL concept is to give standard perl5 the ability to COMPACTLY
store and SPEEDILY manipulate the large N-dimensional data sets which
are the bread and butter of scientific computing. e.g. `$a=$b+$c' can
add two 2048x2048 images in only a fraction of a second.

It is hoped to eventually provide tons of useful functionality for
scientific and numeric analysis.

The Perl Data Language project has a home page at
http://www.aao.gov.au/local/www/kgb/perldl. Here can be found, a
Frequently Asked Questions Lists, contact information for the `perldl'
mailing list, information about on-going development and many other
things.


Introduction
------------

The fundamental perl data structures are scalar variables, e.g. `$x',
which can hold numbers or strings, lists or arrays of scalars,
e.g. `@x', and associative arrays/hashes of scalars, e.g. `%x'.

perl v5 introduces to perl data structures and objects. A simple scalar
variable `$x' now be a user-defined data type or full blown object*.

The fundamental idea behind perlDL is to allow $x to hold a whole 1D
spectrum, or a 2D image, a 3D data cube, and so on up to large
N-dimensional data sets. These can be manipulated all at once, e.g.  `$a
= $b + 2' does a vector operation on each value in the
spectrum/image/etc.

You may well ask: "Why not just store a spectrum as a simple perl `@x'
style list with each pixel being a list item?"  The two key answers to
this are MEMORY and SPEED.  Because we know our spectrum consists of
pure numbers we can compactly store them in a single block of memory
corresponding to a C style numeric array. This takes up a LOT less
memory than the equivalent perl list. It is then easy to pass this block
of memory to a fast addition routine, or to any other C function which
deals with arrays.  As a result perlDL is very fast -- for example one
can mulitiply a 2048*2048 image in exactly the same time as it would
take in C or FORTRAN (0.1 sec on my SPARC). A further advantage of this
is that for simple operations (e.g. `$x += 2') one can manipulate the
whole array without caring about its dimensionality.

I find when using perlDL it is most useful to think of standard perl
`@x' variables as "lists" of generic "things" and PDL variables like
`$x' as "arrays" which can be contained in lists or hashes. Quite often
in my perlDL scripts I have `@x' contain a list of spectra, or a list of
images (or even a mix!). Or perhaps one could have a hash (e.g.  `%x')
of images... the only limit is memory!

perlDL variables support a range of data types - arrays can be bytes,
short intgers (signed or unsigned), long integers, floats or double
precision floats.

* It actually holds a reference (a smart "pointer") to this 
but that is not relevant for ordinary use of perlDL.


Usage
-----

perlDL is loaded into your perl script using these commands:

     use PDL;  # use the standard perlDL modules (Core Examples Io Graphics::PG)

     use PDL::Examples; # use only the Examples module (this will load 
                        # internally whatever other modules it needs).

     % perldl  # Invoke interactive shell from system command line.

The default is to import all the function names from a module. If you
only want certain names imported just say:

     use PDL::Io qw(rfits rgrep) # Get only rfits() and rgrep from PDL::Io

Also see below on "Object-Orientation".


To create a new PDL variable
----------------------------

Here are some ways of creating a PDL variable:

     $a = pdl [1..10];             # 1D array
     $a = pdl (1,2,3,4);           # Ditto
     $b = pdl [[1,2,3],[4,5,6]];   # 2D 3x2 array
     $b = pdl 42                   # 0-dimensional scalar
     $c = pdl $a;                  # Make a new copy

     $d = byte [1..10];            # See "Type conversion"
     $e = zeroes(3,2,4);           # 3x2x4 zero-filled array

     $c = rfits $file;             # Read FITS file 

     @x = ( pdl(42), zeroes(3,2,4), rfits($file) ); # Is a LIST of PDL variables!

The `pdl()' function is used to initialise a PDL variable from a scalar,
list, list reference or another PDL variable.

In addition all PDL functions automatically convert normal perl scalars
to PDL variables on-the-fly.

(also see "Type Conversion" and "Input/Output" sections below)


Arithmetic
----------

     $a = $b + 2; $a++; $a = $b / $c; # Etc.

     $c=sqrt($a); $d = log10($b+100); # Etc

     $e = $a>42; # Vector condtional (like MATLAB) - 
                 # note I think this is much nicer than IDLs WHERE(), e.g.:

     $e = 42*($a>42) + $a*($a<=42); # Cap top

     $a = $a / ( max($a) - min($a) );

     print $a; # $a in string context prints it in a N-dimensional format

(and other perl operators/functions)


Matrix functions
----------------

`'x'' is hijacked as the matrix multiplication operator. e.g.  `$c = $a
x $b';

perlDL is row-major not column major so this is actually `c(i,j) = sum_k
a(k,j) b(i,k)' - but when matrices are printed the results will look
right. Just remember the indices are reversed.  e.g.:

     $a = [                   $b = [
           [ 1  2  3  0]            [1 1]
           [ 1 -1  2  7]            [0 2]
           [ 1  0  0  1]            [0 2]
          ]                         [1 1]
                                   ]

     gives $c = [
                 [ 1 11]
                 [ 8 10]
                 [ 2  2]
                ]

Note: transpose() does what it says and is a convenient way to turn row
vectors into column vectors. It is bound to the unary operator `'~'' for
convenience.


How to write a simple function
------------------------------

     sub dotproduct { 
         my ($a,$b) = @_;
         return sum($a*$b) ;
     }
     1;

If put in file dotproduct.pdl would be autoloaded (see below).
 


Type Conversion
---------------

Default for pdl() is double. Conversions are:

     $a = float($b); 
     $c = long($d);   # "long" is 4 byte int
     $d = byte($a);

Also double(), short(), ushort().

These routines also automatically convert perl lists to allow the
convenient shorthand:

     $a = byte [[1..10],[1..10]];  # Create 2D byte array
     $a = float [1..1000];         # Create 1D float array

etc.

Rules for automatic conversion during arithmetic:

     If INT = any of byte/short/ushort/int and X is generic op

     For VECTOR x SCALAR these rules avoid overpromotion of vector types:

     VECTOR INT   X SCALAR INT            Return is same type as VECTOR
     VECTOR INT   X SCALAR float/double   Return float
     VECTOR float X SCALAR float/double   Return float

     For other VECTORxSCALAR and VECTORxVECTOR returns "highest" of
     two data types. i.e. VECTOR double x float returns float etc.


Printing
--------

Automatically expands array in N-dimensional format:

     print $a;  
 
     $b = "Answer is = $a ";


Sections
--------

perlDL betrays its perl/C heritage in that arrays are zero-offset.  Thus
a 100x100 image has indices `0..99,0..99'.

Further I adopt the convention that the center of the pixel (0,0) IS at
coordinate (0.0,0.0). Thus the above image ranges from `-0.5..99.5,
-0.5..99.5' in real space. All perlDL graphics functions conform to this
defintion and hide away the unit-offsetness of, for example, the PGPLOT
FORTRAN library.

Again following the usual convention coordinate (0,0) is displayed at
the bottom left when displaying an image. It appears at the top right
when using "`print $a'" etc.

     $b  = sec($a,  $x1, $x2, $y1, $y2, $z1, $z2, ... ) # Take subsection
     $newimage = ins($bigimage,$smallimage,$x,$y,$z...) # Insert at x,y,z

     $c  = nelem ($a); # Number of pixels

     $val = at($object, $x,$y,$z...)    # Pixel value at position
     set($myimage, $x, $y, ... $value)  # Set value in image 

     $b = xvals($a); # Fill array with X-coord values (also yvals(), zvals(),
                     # axisvals($x,$axis) and rvals() for radial distance 
                     # from centre).

*** Note: Experimental neat virtual slicing syntax is being worked upon for PDL 2.0 ***


Input/Output
------------

The PDL::Io module currently implements the following useful I/O
functions:

     $a  = rfits($file)  # Read a FITS file into a PDL variable
                         # (only IEEE float machines as yet)

     wfits ($a, $file)  # Write FITS file 

     ([$xaxis],$data) = rdsa($file)   # Read a STARLINK/FIGARO file using
                                      # perl DSA module (available seperately)

     Read ASCII columns into $x, $y, etc.:

     ($x,$y,...) = rcols($file,[[$pattern],[$col1, $col2,] ...)  

Read $1, $2, etc. pattern matches into $x, $y, etc.

     ($x,$y,...) = rgrep($file, $pattern)    

     e.g.:

     ($x,$y) = rcols $file, '/Mumble/', 2,3;
     ($a,$b) = rgrep $file, '/Foo (.*) Bar (.*) Mumble/';



Graphics
--------

The philosophy behind perlDL is to make it work with a variety of
existing graphics libraries since no single package will satisfy all
needs and all people and this allows one to work with packages one
already knows and likes.  Obviously there will be some overlaps in
functionality and some lack of consistency and uniformity. This also
saves the author from too much work in time he doesn't have!

  1. PGPLOT

     PGPLOT provdes a simple library for line graphics and image
     display.

     There is an easy interface to this in the internal module
     PDL::Graphics::PG. (This calls routines in the separately available
     PGPLOT top-level perl module - version 2.0 or higher.)

     Current display commands:

          imag         -  Display an image (uses pgimag()/pggray() as appropriate)
          ctab         -  Load an image colour table
          line         -  Plot vector as connected points
          points       -  Plot vector as points
          errb         -  Plot error bars
          cont         -  Display image as contour map
          bin          -  Plot vector as histogram ( e.g. bin(hist($data)) )
          hi2d         -  Plot image as 2d histogram (not very good IMHO...)
          poly         -  Draw a polygon
          vect         -  Display 2 images as a vector field

     Device manipulation commands:

          hold         -  Hold current plot window range - allows overlays etc.
          release      -  Release back to autoscaling of new plot window for each command
          rel          -  short alias for 'release'
          env          -  Define a plot window, put on 'hold'
          dev          -  Explicitly set a new PGPLOT graphics device

     The actual PGPLOT module is loaded only when the first of these
     commands is executed.
   
     e.g:

          perldl> $a = pdl [1..100]
          perldl> $b = sqrt($a)
          perldl> line $b      
          perldl> hold
          Graphics on HOLD
          perldl> $c = sin($a/10)*2 + 4
          perldl> line $c     

     Notes: $transform for image/cont etc. is used in the same way as
     the TR() array in the underlying PGPLOT FORTRAN routine but is,
     fortunately, zero-offset.

     It is also hoped to use other graphic libraries to enable more
     sophisticated plots then is possible with PGPLOT. Some ideas:

  2. IIS

     Many astronomers like to use SAOimage and Ximtool (or there
     derivations/clones). These are useful free widgets for inspection
     and visualisation of images. (They are not provided with perlDL but
     can easily be obtained from their official sites off the Net.)

     The PDL::Graphics::IIS package provides allows one to display
     images in these ("IIS" is the name of an ancient item of image
     display hardware whose protocols these tools conform to.)

     Commands are:

          iis         - display image
          iiscur      - return a cursor position
          iiscirc     - draw circles on image display
          saoimage    - start SAOimage 
          ximtool     - start Ximtool

     Variables are:

          $stdimage  - frame buffer configuration
          $iisframe  - frame buffer number to display in

     The frame buffer configuration is set by the variable $stdimage
     (analagous to iraf) whose default is "imt1024". System and user
     imtoolrc files are parsed so if you know about these you can do the
     same tricks as you can in with IRAF.

  3. Karma

     To come?


Autoloading
-----------

If a PDL function, e.g. `foo()', is currently undefined a file "foo.pdl"
is searched for in the current directory, and any directories in
$PDLLIB, $PERL5LIB and $PERLLIB enviroment variables.  (These are ":"
seperated lists of directories.)

If you want to change the path within perldl simply change the lists
 @PDLLIB and @INC.

Note: "foo.pdl" is require'd so it must return a true value (see
"require" perl documentation).


Call External
-------------

This provides a simple way to pass the data arrays from pdl variables to
external C routines. It uses perl's built-in dynamic loader to load
compiled C code.

The syntax is:

     callext($file,$symbol, @pdl_list) 

@pdl_list is a list of pdl variables. Numbers get converted
automatically. The file must be dynamically loadable object code - how
the C compiler generates this will be different from system to system so
see your man pages.

The C routine takes args `(int nargs, pdl *args)'. The C type `"pdl"' is
a simple data structure representing the perl pdl variable. It is
defined in file "pdl.h" which is included in the perlDL distribution and
has no perl dependencies.  It is trivial to cast the data array
(pdl.data) to (float), (double) etc. and pass to any other C routine.

This is all demonstrated in the files "demos/callext.*" in the perlDL
distribution.

Note: This is only intended as a quick and dirty prototyping interface
for the scientist/hacker. perlDL developers should write a module along
the lines of the example PDL::Examples. (Or better: join the pdl-porters
mailling list and find out about how to take advantage of the cool
features coming up in PDL 2.0)


perldl shell
------------

The program '`perldl'' (written in perl) provides a simple command line
for interactive use of PDL. See `perldl' in this node for further
information about it's features.

You can also use PDL from the standard perl debugger (e.g. by typing
`perl -MPDL -d -e 1') if you want.


Overload operators
------------------

I have overloaded the following builtin perl operators and functions in
order that they work on PDL variables:

     + - * / > < >= <= << >> & | ^ == != <=> ** % ! ~
     sin log abs atan2 sqrt cos exp 

[All the unary functions (sin etc.) may be used with inplace() - see
"Memory" below.]


Object-Orientation and perlDL
-----------------------------

[Astronomers can ignore this bit! :-)]

pdl variables such as $x are implemented via Perl objects. However I
have chosen to use an all-functional approach to perlDL syntax yo be
more astronomer friendly.

However you can use perlDL in an OO fashion. In fact if you say:

     use PDL::OO;

It will load PDL functions as OO methods in the PDL class. This means
you can say things like:

     $a = PDL->rfits('m51.fits');
     $b = PDL->new([1,2,2,1],[1,2,2,1],[1,2,2,1],[1,2,2,1]);
     $smooth = $a->convolve($b);
     $smooth->iis;

You can start the perldl shell in this mode with "perldl -oo".

Note: as you can see from the above all functions which create pdl
variables are used with construct syntax in the OO mode. Finally you can
even use both forms by simply saying "use PDL; use PDL::OO".

You can inherit from PDL methods (e.g. to a class Foo) by simply saying:

     @Foo::ISA = ('PDL');               # Method path
     %Foo::OVERLOAD = %PDL::OVERLOAD;   # Copy overload

Then PDL methods will work on Foo objects as long as you simply build on
the existing PDL data structure (see below) components.

So it would be possible to provide USER written modules to do really
cool stuff for specific application areas, e.g. PDL::Spectrum might
provide a $a which understands X-axes and error bars and +-/+ etc.
might be overriden to do the Right Thing (tm). And writing the module
would not be rocket science - just some cool perl hacking.

And you would not have to even use method syntax - if $a came out of my
hypothetical PDL::Spectrum all the standard pdl functions (like hist()
to give a concreate example) would work on it in the standard way
provided they simply built on the existing PDL data structure (which
means simply containing a $$a{Data} etc. PDL::Spectrum could even export
it's own hist() function to override the built-in which might do
something more sophisticated using the X-axis for example.

If you were feeling really ambitious you might do PDL::Ir::Spectrum
which understood about the gaps between the J H and K bands!

***IMPORTANT: THIS IS AN EXPERIMENTAL FEATURE****

i.e. it may go away in PDL v2.0. It is not yet clear whether it is neat
or a crock. :-) Comments welcome.


Memory usage and references
---------------------------

A PDL variable such as $x is implemented as a 'perl reference'. You can
think of it as pointer to a big block of memory holding the data and
housekeeping information. Saying $y=$x makes $y point to the same thing
as $x, i.e. IT DOES NOT COPY THE data. Rather you now have two names ($x
and $y) for the same piece of data. To force an explicit data copy say:

     $b = pdl $a; # Real copy

though this is rarely needed in practice.

Messing around with really huge data arrays may require some care.  PDL
provides some facilities to let you perform operations on big arrays
without generating extra copies though this does require a bit more
thought are care from the programmer.

NOTE: On some most systems it is better to configure perl (during the
build options) to use the system malloc() function rather than perl's
built-in one. This is because perl's one is optimised for speed rather
than consumption of virtual memory - this can result in a factor of two
improvement in the amount of memory storage you can use.

  1. Simple arithmetic

     If $a is a big image (e.g. occupying 10MB) and I say:

          $a = $a + 1;

     then the total malloc()'d memory usage grows to 20MB. This is
     because the expression "$a+1" creates a temporary copy of $a to
     hold the result, then $a is assigned a reference to that. It is
     obviously done this way so "$c=$a+1" works as expected. (Note the
     old memory is reclaimed for further use but one feature of UNIX
     dynamic memory allocation via malloc() is that the memory malloced
     by a process can never get smaller.)

     Now if one says:

          $b = $a;     # $b and $a now point to same data
          $a = $a + 1;

     Then $b and $a end up being different, as one naively expects,
     because a new reference is created to the result and $a is assigned
     to it.

     However if $a was a huge memory hog (e.g. a 3D volume) creating a
     copy of it may not be a good thing. One can avoid this memory
     overhead in the above example by saying:

          $a++;

     The operations `++,+=,--,-=', etc. all call a special "in-place"
     version of the arithmetic subroutine. This means no more memory is
     needed - the downside of this is that if $b=$a then $b is also
     incremented.

  2. Functions

     Most functions, e.g. log(), return a result which is a
     transformation of their argument. This makes for good programming
     practice. However many operations can be done "in-place" and this
     may be required when large arrays are in use and memory is at a
     premium. For these circumstances the operator inplace() is provided
     which prevents the extra copy and allows the argument to be
     modified. e.g.:

          $x = log($array);          # $array unaffected
          log( inplace($bigarray) ); # $bigarray changed in situ

WARNINGS:

  1. The usual caveats about duplicate references apply.

  2. Obviously when used with some functions which can not be applied in
     situ (e.g. convolve()) unexpected effects may occur! I try to
     indicate inplace() safe functions below.

  3. Type conversions [e.g. float()] may cause hidden copying.


Data Structure Guts
-------------------

(For born fiddlers only.)

The data structure for $a is implemented by a hash (associative array)
which $a is a (blessed) reference too.

PDL reserves for it's own use:

     $$a{Data} ; # The DATA (byte list) - can be passed directly to F77/C
                 # subroutine as long as type matches. e.g. line() does a
                 # float() and then calls PGPLOT::pgline_r (bypassing packing)

     $$a{Datatype}; # Holds numeric data type, $PDL_F, $PDL_D, etc...

     $$a{Dims} ; # List reference holding dimensions. 
                 # E.g. @mydims = @{ $$a{Dims} };

     $$a{Hdr}  ; # Optional extra hash reference holding header, e.g.
                 # $airmass = $$a{Hdr}{'AIRMASS'}; %myhdr = %{ $$a{Hdr} };
                 # rfits() populates this from the FITS header.

     $$a{Inplace}; # Flag - inplace() sets this. Next time a copy is attempted
                   # it does not occur and the flag is unset.

     $$a{PDL};  # Pointer to cached C values of above. This allows
                # C routines to get at the data FAST.

Anything else stored in the structure will be copied to new objects
(e.g. by $b = $a + 1) automatically as long as PDL knows how to copy it.
[If it is a reference to another object PDL tries the ->copy method.]

If your perl routine manipulates the data structure guts directly, you
don't want it to blow up in your face if you pass it a simple number
rather than a PDL variable. Simply call the function topdl() first to
make it safe. e.g.:

     sub myfiddle { my $pdl = topdl(shift); $$pdl{Data} = ... }

topdl() does NOT perform a copy if a pdl variable is passed - it just
falls through - which is obviosuly the desired behaviour. The routine is
not of course necessary in normal user defined functions which do not
care about internals.

If you have changed the guts you ********MUST******** call the method
`$pdl-'flush()> to update the C cache from the new perl values otherwise
PDL will get very confused (Mnemonic: 'flush the piddle after a
fiddle').

Finally there is no reason why the data structure should not contain
another PDL variable!

***IMPORTANT*** This structure was experimental, and has already
gone away in the latest development version of PDL2.0. You have been
warned. :-)


Complete List of Exported Functions
-----------------------------------

Defined in PDL::Core
 

     byte short ushort long float double convert   - Type Conversions

     pdl          - Create/copy a pdl 
     topdl        - Coerce to pdl if scalar
     howbig       - Size of pdl datatype in bytes
     nelem        - Number of elements 
     dims         - Return list of dimensions, e.g. @mydims = dims($x);
     list         - Convert pdl to list - e.g. for (list $x) {..}
     listindices  - Return list of index values (1D) - e.g. for $i 
                    (listindices $x) {..}
     log10*       - Take log base 10
     min max sum  - Min/max/sum of pdl array
     zeroes/ones  - Create zero/one-filled pdl array
     sequence     - Create sequence-filled pdl array
     reshape      - reshape the dimensions of a pdl array
     sec          - subsection
     ins* / set   - insertion / setting
     at           - return pixel value at (x,y,z...)

     axisvals* xvals* yvals* zvals* - Fill pdl with axis values

     rvals        - Fill pdl with distance from it's center
     callext      - Call external C routine in dynamically loadable object
     convolve     - convolve image with kernel (real space)
     inplace      - Flag for inplace operation
     hist         - histogram of data 
     stats        - return mean + standard deviation
     transpose    - matrix transpose
     qsort*       - Quick sort piddle
     median       - median of piddle
     oddmedian    - lower odd median of piddle

Defined in PDL::Examples

This contains examples of how to add C functiions via XS including use
of the generic preprocessor (.g files are automatically converted to .c
files with code automatically generated for each datatype).

     fibonacci*    - Compute Fibonacci series (simple 1D example)
     cc8compt*     - Connected 8-component labelling (2D example)

Defined in PDL::Io

[See "Io" section above]

Defined in PDL::Graphics::*

[See "Graphics" section above]

Footnotes:

* = indicates `inplace()' safe & useful with this function


Complete List of PDL methods
----------------------------

For convenience (the ->meth syntax looks more appropriate) some pdl
routines are defined as methods:

$pdl->flush - Update C cache from perl values $pdl->copy - Copy a PDL
PDL->new - Make a new PDL




File: pm.info, Node: PDL-FAQ, Next: PGP/Sign, Prev: PDL, Up: Module List

Frequently asked questions about PDL
************************************



NAME
====

PDL::FAQ - Frequently asked questions about PDL


DESCRIPTION
===========

This is version 0.2 of the PDL FAQ, a collection of frequently asked
questions about PDL - the Perl Data Language.

This FAQ was generated on 22.2.97.

Current maintainer: Christian Soeller (csoelle@sghms.ac.uk).

You can find the latest version of this document at
http://www.aao.gov.au/local/www/kgb/perldl/faq.html.  This FAQ will be
monthly posted to the PDL mailing list perldl@jach.hawaii.edu.

This is the first released version of the PDL FAQ. As such it is almost
certainly incomplete and maybe unclear in parts. You are explicitly
encouraged to let us know about questions which you think should be
answered in this document but currently aren't. Similarly, if you think
parts of this document are unclear, please let us know. Send your
comments to the PDL mailing list at perldl@jach.hawaii.edu (preferably)
or to the FAQ maintainer Christian Soeller (csoelle@sghms.ac.uk).

Some questions and answers in this document are related to features of
the current beta/alpha versions of PDL. To point this out these sections
are marked with the strings '[!beta!]' or '[!alpha!]'.


General questions
=================


What is PDL ?
-------------

PDL stands for Perl Data Language. To say it with the words of Karl
Glazebrook, initiator of the PDL project:

     The PDL concept is to give standard perl5 the ability to COMPACTLY
     store and SPEEDILY manipulate the large N-dimensional data sets which
     are the bread and butter of scientific computing. e.g. $a=$b+$c can
     add two 2048x2048 images in only a fraction of a second.

     It is hoped to eventually provide tons of useful functionality for
     scientific and numeric analysis.

For readers familiar with other scientific data evaluation packages it
may be helpful to add that PDL is in many respects similar to IDL,
MATLAB and similar packages. However, it tries to improve on a number of
issues which were perceived (by the authors of PDL) as shortcomings of
those existing packages.


Why yet another Data Language ?
-------------------------------

There are actually several reasons and everyone should decide for
himself which are the most important ones:

   * PDL is "free software". The authors of PDL think that this concept
     has several advantages: everyone has access to the sources ->
     better debugging, easily adaptable to your own needs, extensible
     for your purposes, etc...

   * PDL is based on a powerful and well designed scripting language:
     Perl. In contrast to other scientific/numeric data analysis
     languages it has been designed using the language features of a
     proven language instead of having grown into existence from scratch
     defining the control structures while features were added during
     development (leading to languages that often appear clumsy and
     badly planned for most existing packages with similar scope as
     PDL).

   * Using Perl as the basis a PDL programmer has all the powerful
     features of Perl at his hand, right from the start. This includes
     regular expressions, associative arrays (hashes), well designed
     interfaces to the operating system, network, etc. Experience has
     shown that even in mainly numerically oriented programming it is
     often extremely handy if you have easy access to powerful
     semi-numerical or completely non-numerical functionality as
     well. For example, you might want to offer the results of a
     complicated computation as a server process to other processes on
     the network, perhaps directly accepting input from other processes
     on the network. Using Perl and existing Perl extension packages
     things like this are no problem at all (and it all will fit into
     your "PDL script").

   * Extremely easy extensibility and interoperability as PDL is a Perl
     extension; development support for Perl extensions is an integral
     part of the Perl and there are already numerous extensions to
     standard Perl freely available on the network.

   * Integral language features of Perl (regular expressions, hashes,
     object modules) immensely facilitated development and
     implementation of key concepts of PDL. One of the most striking
     examples for this point is probably PDL::PP (see below), a code
     generator/parser/pre-processor that generates PDL functions from
     concise descriptions.

   * None of the existing DLs follow the Perl language rules, which the
     authors firmly believe in:

        * TIMTOWTDI: There is more than one way to do it.  Minimalist
          languages are interesting for computer scientists, but for
          users, a little bit of redundancy makes things wildly easier
          to cope with and allows individual programming styles - just
          as people speak in different ways. For many people this will
          undoubtedly be a reason to avoid PDL ;)

        * Simple things are simple, complicated things possible:
          Things that are often done should be easy to do in the language,
          whereas seldom done things shouldn't be too cumbersome.
          =back

          All existing languages violate at least one of these rules.

        * As a project for the future PDL should be able to use super
          computer features, e.g. vector capabilities/parallel
          processing. This will probably be achieved by having PDL::PP
          ([!alpha!], see below) generate appropriate code on such
          architectures to exploit these features.

        * [ fill in your personal 111 favourite reasons here...]


What is PDL good for ?
----------------------

Just in case you do not yet know what the main features of PDL are and
what one could do with them, here is a (necessarily selective) list of
key features:

PDL is well suited for matrix computations, general handling of
multidimensional data, image processing, general scientific computation,
numerical applications. It supports I/O for many popular image and data
formats, 1D (line plots), 2D (images) and 3D (volume visualisation,
surface plots via OpenGL/MesaGL) graphics display capabilities and
implements lots of numerical and semi-numerical algorithms.

[!alpha!] Some of these features (image I/O, 3D graphics (via
OpenGL/MesaGL), matrix library) are currently in alpha testing.


What is the connection between PDL and Perl ?
---------------------------------------------

PDL is a Perl5 extension package. As such it needs an existing Perl5
installation (see below) to run. Furthermore, much of PDL is written in
perl (+ some core functionality that is written in C). PDL programs are
(syntactically) just perl scripts that happen to use some of the
functionality implemented by the package "PDL";


What do I need to run PDL on my machine ?
-----------------------------------------

Since PDL is just a Perl package you need first of all an installation
of Perl on your machine. As of this writing PDL requires version 5 of
Perl, version 5.003_11 or higher is recommended. More information on
where and how to get a Perl installation can be found at the Perl home
page http://www.perl.com and at many CPAN sites (if you do not know what
CPAN is check the answer to the next question).

Furthermore, you need the PDL package which will be installed as an
extension within your PERL installation. See below for directions how
and where to get the latest PDL distribution.


Where do I get it?
------------------

PDL is available as source distribution in the *Comprehensive Perl
Archive Network*, or CPAN. This archive contains not only the PDL
distribution but also just about everything else that is
Perl-related. CPAN is mirrored by dozens of sites all over the
world. The main site is ftp://ftp.funet.fi. You can find a more local
CPAN site by getting the file /pub/languages/perl/CPAN/MIRRORS from
ftp://ftp.funet.fi. Alternatively, you can point your Web browser at
http://www.perl.com and use its CPAN multiplex service. Within CPAN you
find the latest released version of PDL in the directory
CPAN/modules/by-module/PDL/. Another site that has the latest PDL
distribution and the latest beta versions is
http://www.aao.gov.au/local/www/kgb/perldl. There are currently no other
mirror sites in other parts of the world.
     This will hopefully change soon.


What machines does PDL run on, then ?
-------------------------------------

Ideally, PDL should run on about every machine for which a port of Perl5
is available that supports Xsubs and the package Extutils::MakeMaker. In
practice, you might run into problems if you would try to compile PDL on
some exotic platform it has never been tested on before. A list of
platforms on which PDL has been successfully tested is available at
http://www.aao.gov.au/local/www/kgb/perldl/ports.html. If you don't have
a compiler you can check if a binary distribution for your platform is
available (we haven't yet got round to making binary versions/bundles
available but is definitely on the TODO list) at the PDL home site
located at http://www.aao.gov.au/local/www/kgb/perldl.

If you can (or cannot) get PDL working on a new (previously unsupported)
platform we would like to hear about it. Please, report your
success/failure to the PDL mailing list at perldl@jach.hawaii.edu. We
will do our best to assist you in porting PDL to a new system.


What do I have to pay to get PDL?
---------------------------------

We are delighted to be able to give you the nicest possible answer on a
question like this: PDL is *free software* and all sources are publicly
available. But still, there are some copyrights to comply with. So
please, try to be as nice as we (the PDL authors) are and try to comply
with them.

Oh, before you think it is *completely* free: you have to invest some
time to pull the distribution from the net, compile and install it and
(maybe) read the manuals.

In the future, we hope to be able to supply bundles/binaries for a
number of popular architectures. However, as of this writing you will
have to find some means of how and where to compile the package
yourself.


Are there other PDL information sources on the internet?
--------------------------------------------------------

First of all, for all purely Perl-related question (see above why we
often talk about Perl in the PDL FAQ) there are tons of sources on the
net. A good point to start is http://www.perl.com.

The PDL home site can be accessed by pointing your web browser to
http://www.aao.gov.au/local/www/kgb/perldl. It has tons of goodies for
anyone interested in PDL:

   * Online documentation
   * Pointers to an HTML archive of the PDL mailing lists
   * A list of platforms on which PDL has been successfully tested.
   * News about recently added features, ported libraries, etc.
   * Name of the current pumpkin holders for the different PDL modules (if you want to know what that means you better had a look at the web pages).

If you are interested in PDL in general you can join the PDL mailing
list perldl@jach.hawaii.edu. This is a forum to discuss programming
issues in PDL, report bugs, seek assistance with PDL related problems,
etc. To subscribe, send a message to perldl-request@jach.hawaii.edu
containing a string in the following format:

     subscribe me@my.email.address

where you should replace the string *me@my.email.address* with your
email address. Past messages can be retrieved in digest format by
anonymous ftp from ftp://ftp.jach.hawaii.edu/pub/ukirt/frossie/pdlp/.  A
searchable archive and a hypertext version of the traffic on this list
can be found at
http://www.rosat.mpe-garching.mpg.de/mailing-lists/perldl/.

If you are interested in all the technical details of the ongoing PDL
development you can join the PDL developers mailing list
pdl-porters@jach.hawaii.edu. To subscribe, send a message to
pdl-porters-request@jach.hawaii.edu containing a string in the following
format:

     subscribe me@my.email.address

where you should replace the string *me@my.email.address* with your
email address. Past messages can be retrieved in digest format by
anonymous ftp from ftp://ftp.jach.hawaii.edu/pub/ukirt/frossie/pdlp/.  A
searchable archive and a hypertext version of the traffic on this list
can be found at
http://www.rosat.mpe-garching.mpg.de/mailing-lists/pdl-porters/.

Crossposting between these lists should be avoided unless there is a
*very* good reason for doing that.


What is the current version of PDL ?
------------------------------------

As of this writing (FAQ version 0.2 of 22.2.97) the latest released
version is 1.11. Currently in alpha test is 1.9_02. For those of you who
are really audacious (and like to run into bugs) directions on how to
get the current alpha versions of the latest "hot" PDL modules can be
found at http://www.aao.gov.au/local/www/kgb/perldl/alpha.html.


I am looking for a package to do XXX in PDL. Where shall I look for it?
-----------------------------------------------------------------------

A good place to start is again
http://www.aao.gov.au/local/www/kgb/perldl. We hope to get round to
compiling a list of packages that have already been/are in the process
of being interfaced to PDL RSN (you know what that means...). This
information will be accessible through the PDL home site.


Where can I get help with PDL related problems (addiction...)?
--------------------------------------------------------------

Currently, the main PDL related information source is the PDL mailing
list at perldl@jach.hawaii.edu (But see also the question on
*information sources*).  It is devoted to information exchange about all
general issues related to PDL. If you want to ask a development related
question there is the PDL development mailing list
pdl-porters@jach.hawaii.edu.  Check the question about *information
sources* for subscription directions and locations of archives of
past/recent messages.

Before you post your questions to the list(s) make sure
=over 3
=item *
that your problem has not already been dealt with in another section of
this FAQ.

   * that you have read the manual(s) (RTFM!!).
   * that your problem is not a general perl programming question in which case you better check the perl FAQ (available at http://www.perl.com/perl/faq) and/or ask the question in the relevant perl newsgroups/mailing lists. =back

[!alpha!] There is this great XXX package on the net. Has it already been interfaced to PDL or how can I do it?
---------------------------------------------------------------------------------------------------------------


Check on PDL's home site http://www.aao.gov.au/local/www/kgb/perldl if
the package in question has already been ported/interfaced to PDL.  The
question on how to do the interfacing will probably be dealt with in the
next version of the PDL::PP manpage (see below). Note that people
willing to write interfaces for new packages should target them toward
the upcoming beta versions since the internals of PDL have changed *a
lot* since the latest released version (1.11).


I want to contribute to the further development of PDL. How can I help?
-----------------------------------------------------------------------

If you have a certain project in mind you should check if somebody else
is already working on it or if you could benefit from existing
modules. Do so by posting your planned project to the PDL developers
mailing list at pdl-porters@jach.hawaii.edu. To subscribe, send a
message to pdl-porters-request@jach.hawaii.edu containing a string in
the following format:

     subscribe me@my.email.address

where you should replace the string *me@my.email.address* with your
email address.  You can also read past and current mails in the
searchable hypertext version of the mailing list at
http://www.rosat.mpe-garching.mpg.de/mailing-lists/pdl-porters/. We are
always looking for people to write code and/or documentation ;).


I think I have found a bug in the current version of PDL. What shall I do?
--------------------------------------------------------------------------

First, make sure that the bug/problem you came across has not already
been dealt with somewhere else in this FAQ. Secondly, you can check the
searchable archive of the PDL mailing list at whether this bug has
already been discussed. If you still haven't found any explanations you
can post a bug report to perldl@jach.hawaii.edu.


Technical questions
===================


What is perldl?
---------------

Sometimes perldl is used as a synonym for PDL. Strictly speaking,
however, the name perldl is reserved for the little shell that comes
with the PDL distribution and is supposed to be used for the interactive
prototyping of PDL scripts. For details check the perldl man page.


[!alpha!] How do I get online help for PDL?
-------------------------------------------

This is currently a subject of ongoing development. We hope to be able
to come up with an online help feature soon. A refcard and searchable
index are planned as well. Support for these features will be built into
the `perldl' shell.


[!alpha!] Oops, what is threading (is PDL a newsreader) ?
---------------------------------------------------------

In the context of PDL threading has a different meaning from what you
would probably normally associate with the term. Here, it denotes a
feature of PDL that can be loosely defined as an implicit looping
facility. For details check the *PDL::threading* manpage.


[!alpha!] What on earth is this dataflow stuff ?
------------------------------------------------

Dataflow is an experimental project that you don't need to concern
yourself with (it should not interfere with your usual programming).
However, if you want to know, look at the PDL::Dataflow file in the
distribution. There are applications which will benefit from this
feature.


[!alpha!] There is this strange pre-processor package (PDL::PP). Do I have to know about it?
--------------------------------------------------------------------------------------------

PDL::PP is used to compile very concise definitions into XSUB routines
implemented in C that can easily be called from PDL and which
automatically support threading, dataflow and other things without you
having to worry about it.

For further details see the PDL::PP documentation that is going to be in
the distribution soon.


Sometimes I am getting these strange results when using inplace operations ?
----------------------------------------------------------------------------

This question is related to the `inplace' function. From the
documentation (PDL.pod):

     Most functions, e.g. log(), return a result which is a transformation
     of their argument. This makes for good programming practice. However many 
     operations can be done "in-place" and this may be required when large
     arrays are in use and memory is at a premium. For these circumstances
     the operator inplace() is provided which prevents the extra copy and
     allows the argument to be modified. e.g.:

     $x = log($array);          # $array unaffected
     log( inplace($bigarray) ); # $bigarray changed in situ

And also from the doc !!:

     Obviously when used with some functions which can not be applied
     in situ (e.g. convolve()) unexpected effects may occur!

Check the list of PDL functions at the end of PDL.pod which points out
`inplace'-safe functions.


[!alpha!] What is this strange usage of the string concatenation operator `.=' in PDL scripts ?
-----------------------------------------------------------------------------------------------

See next question on assignment in PDL.


[!alpha!] Why are there two different kinds of assignment in PDL ?
------------------------------------------------------------------

This is caused by the fact that currently the assignment operator =
allows only restricted overloading. For some purposes of PDL (new
indexing features, dataflow) it turned out to be necessary to have more
control over the overloading of an assignment operator. Therefore,
current alpha versions of PDL peruse the operator `.=' for certain types
of assignments. For details see the documentation about
indexing/threading and dataflow that come with those versions of PDL.


What happens when I have several references to the same PDL object in different variables (cloning, etc?) ?
-----------------------------------------------------------------------------------------------------------

[not clear yet]


BUGS
====

If you find any inaccuracies in this document (or disfunctional URLs)
please report to the perldl mailing list perldl@jach.hawaii.edu or to
the current FAQ maintainer Christian Soeller (csoelle@sghms.ac.uk).


AUTHOR & COPYRIGHT
==================

This document emerged from a joint effort of several PDL developers to
compile a list of the most frequently asked questions about PDL with
answers.  Permission is granted for verbatim copying (and formatting) of
this material as part of PDL. Permission is explicitly not granted for
distribution in book or any corresponding form. Email the current FAQ
maintainer Christian Soeller (csoelle@sghms.ac.uk) or ask on the PDL
mailing list perldl@jach.hawaii.edu if you are unclear.




File: pm.info, Node: PGP/Sign, Next: POSIX, Prev: PDL-FAQ, Up: Module List

Create detached PGP signatures for data, securely
*************************************************



NAME
====

PGP::Sign - Create detached PGP signatures for data, securely


SYNOPSIS
========

     use PGP::Sign;
     ($signature, $version) = pgp_sign ($keyid, $passphrase, @data);
     $signer = pgp_verify ($signature, $version, @data);
     @errors = PGP::Sign::pgp_error;


DESCRIPTION
===========

This module is designed to do one and only one thing securely and well;
namely, generate and check detached PGP signatures for some arbitrary
data.  It doesn't do encryption, it doesn't manage keyrings, it doesn't
verify signatures, it just signs things.  This is ideal for applications
like PGPMoose or control message generation that just need a fast
signing mechanism.

The interface is very simple; just call pgp_sign() with a key ID, a pass
phrase, and some data, or call pgp_verify() with a signature (in the
form generated by pgp_sign()), a version number (which can be undef if
you don't want to give a version), and some data.  The data can be
specified in pretty much any form you can possibly consider data and a
few you might not.  Scalars and arrays are passed along to PGP;
references to arrays are walked and passed one element at a time (to
avoid making a copy of the array); file handles, globs, or references to
globs are read a line at a time and passed to PGP; and references to
code are even supported (see below).  About the only thing that we don't
handle are references to references (which are just printed to PGP,
which probably isn't what you wanted) and hashes (which are treated like
arrays, which doesn't make a lot of sense).

If you give either function a reference to a sub, it will repeatedly
call that sub, sending the results to PGP to be signed, until the sub
returns undef.  What this lets you do is pass the function an anonymous
sub that walks your internal data and performs some manipulations on it
a line at a time, thus allowing you to sign a slightly modified form of
your data (with initial dashes escaped, for example) without having to
use up memory to make an internal copy of it.

In a scalar context, pgp_sign() returns the signature as an ASCII
armored block with embedded newlines (but no trailing newline).  In a
list context, it returns a two-element list consisting of the signature
as above and the PGP version that signed it.  pgp_sign() will return
undef in the event of any sort of error.

pgp_verify() returns the signer of the message in the case of a good
signature, the empty string in the case of a bad signature, and undef in
the event of some error.

pgp_error() (which isn't exported by default) returns the error
encountered by the last pgp_sign() or pgp_verify(), or undef if there
was no error.  In a list context, a list of lines is returned; in a
scalar context, a long string with embedded newlines is returned.

Two global variables can be modified:

$PGP::Sign::PGP
     The path to PGP.  This defaults to `/usr/local/bin/pgp', but may
     have been fixed to point at the right place by the module installer
     during installation.

$PGP::Sign::TMPDIR
     The directory in which temporary files are created.  Defaults to
     TMPDIR if set, and `/tmp' if not.

$PGP::Sign::MUNGE
     If this variable is set to a true value, PGP::Sign will
     automatically strip trailing spaces when signing or verifying
     signatures.  This will make the resulting signatures and
     verification compatible with programs that generate attached
     signatures (since PGP ignores trailing spaces when generating or
     checking attached signatures).


ENVIRONMENT
===========

TMPDIR
     The directory in which to create temporary files.  Can be
     overridden by changing $PGP::Sign::TMPDIR.  If not set, defaults to
     `/tmp'.


DIAGNOSTICS
===========

Mostly the contents of @PGP::Sign::ERROR (returned by pgp_error()) are
completely determined by PGP.  The only thing that this module may stick
in there is "Execution of PGP failed" if we couldn't fork off a PGP
process and "PGP returned exit status %d" in the event of a non-zero
exit status from PGP.


BUGS
====

The implementation of pgp_verify() uses temporary files.  Unfortunately,
given the current implementation of PGP, there isn't any way to avoid
this, since we want to generate detached signatures.  It would be
possible to do everything through pipes if we generated attached
signatures, but then we would have to deal with PGP data munging, which
is ugly and underdocumented.  We also wouldn't be able to work with
applications that want detached signatures, and since we are returning a
signature that's logically detached from the signed data, it doesn't
make any sense to have the signature be of the form used for attached
signatures.


CAVEATS
=======

This module uses a pipe and the environment variable PGPPASSFD to give
the pass phrase to PGP, since this is the only secure method (both
command line switches and environment variables can potentially be read
by other users on the same machine using ps).  This requires a version
of PGP that supports that feature, however.  I know for certain that PGP
2.6.2 does, but I can't be sure about other versions.

This module forks, uses a pipe, and relies on the ability to pass an
open pipe to an exec()ed subprocess.  This may cause portability
problems to certain substandard operating systems.

The signature generated is a detached signature.  If you intend to pass
it to an application that will attempt to verify it by creating a signed
document (the way pgpverify does), you'll need to set $PGP::Sign::MUNGE
before creating the signature.


AUTHOR
======

Russ Allbery <rra@stanford.edu>


HISTORY
=======

Based heavily on work by Andrew Gierth <andrew@erlenstar.demon.co.uk>
and benefitting greatly from input, comments, suggestions, and help from
him, this module came about in the process of implementing PGPMoose
signatures and control message signatures for Usenet.  PGPMoose is the
idea of Greg Rose <ggr@usenix.org>, and signcontrol and pgpverify are
the idea of David Lawrence <tale@isc.org>.




