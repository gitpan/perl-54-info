Info file: pm.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `bigpm.texi'
using `texinfmt.el' version 2.32 of 19 November 1993.





File: pm.info, Node: Text/CSV, Next: Text/English, Prev: Text/Bib, Up: Module List

comma-separated values manipulation routines
********************************************



NAME
====

Text::CSV - comma-separated values manipulation routines


SYNOPSIS
========

     use Text::CSV;

     $version = Text::CSV->version();      # get the module version

     $csv = Text::CSV->new();              # create a new object

     $status = $csv->combine(@columns);    # combine columns into a string
     $line = $csv->string();               # get the combined string

     $status = $csv->parse($line);         # parse a CSV string into fields
     @columns = $csv->fields();            # get the parsed fields

     $status = $csv->status();             # get the most recent status
     $bad_argument = $csv->error_input();  # get the most recent bad argument


DESCRIPTION
===========

Text::CSV provides facilities for the composition and decomposition of
comma-separated values.  An instance of the Text::CSV class can combine
fields into a CSV string and parse a CSV string into fields.


FUNCTIONS
=========

version
          $version = Text::CSV->version();

     This function may be called as a class or an object method.  It
     returns the current module version.

new
          $csv = Text::CSV->new();

     This function may be called as a class or an object method.  It
     returns a reference to a newly created Text::CSV object.

combine
          $status = $csv->combine(@columns);

     This object function constructs a CSV string from the arguments,
     returning success or failure.  Failure can result from lack of
     arguments or an argument containing an invalid character.  Upon
     success, `string()' can be called to retrieve the resultant CSV
     string.  Upon failure, the value returned by `string()' is
     undefined and `error_input()' can be called to retrieve an invalid
     argument.

string
          $line = $csv->string();

     This object function returns the input to `parse()' or the
     resultant CSV string of `combine()', whichever was called more
     recently.

parse
          $status = $csv->parse($line);

     This object function decomposes a CSV string into fields, returning
     success or failure.  Failure can result from a lack of argument or
     the given CSV string is improperly formatted.  Upon success,
     `fields()' can be called to retrieve the decomposed fields .  Upon
     failure, the value returned by `fields()' is undefined and
     `error_input()' can be called to retrieve the invalid argument.

fields
          @columns = $csv->fields();

     This object function returns the input to `combine()' or the
     resultant decomposed fields of `parse()', whichever was called more
     recently.

status
          $status = $csv->status();

     This object function returns success (or failure) of `combine()' or
     `parse()', whichever was called more recently.

error_input
          $bad_argument = $csv->error_input();

     This object function returns the erroneous argument (if it exists)
     of `combine()' or `parse()', whichever was called more recently.


EXAMPLE
=======

     require Text::CSV;

     my $csv = Text::CSV->new;

     my $column = '';
     my $sample_input_string = '"I said, ""Hi!""",Yes,"",2.34,,"1.09"';
     if ($csv->parse($sample_input_string)) {
       my @field = $csv->fields;
       my $count = 0;
       for $column (@field) {
         print ++$count, " => ", $column, "\n";
       }
       print "\n";
     } else {
       my $err = $csv->error_input;
       print "parse() failed on argument: ", $err, "\n";
     }

     my @sample_input_fields = ('You said, "Hello!"',
     			     5.67,
     			     'Surely',
     			     '',
     			     '3.14159');
     if ($csv->combine(@sample_input_fields)) {
       my $string = $csv->string;
       print $string, "\n";
     } else {
       my $err = $csv->error_input;
       print "combine() failed on argument: ", $err, "\n";
     }


CAVEATS
=======

This module is based upon a working definition of CSV format which may
not be the most general.

  1. Allowable characters within a CSV field include 0x09 (tab) and the
     inclusive range of 0x20 (space) through 0x7E (tilde).

  2. A field within CSV may be surrounded by double-quotes.

  3. A field within CSV must be surrounded by double-quotes to contain a
     comma.

  4. A field within CSV must be surrounded by double-quotes to contain
     an embedded double-quote, represented by a pair of consecutive
     double-quotes.

  5. A CSV string may be terminated by 0x0A (line feed) or by 0x0D,0x0A
     (carriage return, line feed).


AUTHOR
======

Alan Citterman `<alan@mfgrtl.com>'


SEE ALSO
========

perl(1)




File: pm.info, Node: Text/English, Next: Text/GenderFromName, Prev: Text/CSV, Up: Module List

Porter's stemming algorithm
***************************



NAME
====

Text::English - Porter's stemming algorithm


SYNOPSIS
========

     use Text::English;
     @stems = Text::English::stem( @words );


DESCRIPTION
===========

This routine applies the Porter Stemming Algorithm to its parameters,
returning the stemmed words.  It is derived from the C program
"stemmer.c" as found in freewais and elsewhere, which contains these
notes:

     Purpose:    Implementation of the Porter stemming algorithm documented 
                 in: Porter, M.F., "An Algorithm For Suffix Stripping," 
                 Program 14 (3), July 1980, pp. 130-137.
     Provenance: Written by B. Frakes and C. Cox, 1986.

I have re-interpreted areas that use Frakes and Cox's "WordSize"
function. My version may misbehave on short words starting with "y", but
I can't think of any examples.

The step numbers correspond to Frakes and Cox, and are probably in
Porter's article (which I've not seen).  Porter's algorithm still has
rough spots (e.g current/currency, -ings words), which I've not
attempted to cure, although I have added support for the British -ise
suffix.


NOTES
=====

This is version 0.1. I would welcome feedback, especially improvements
to the punctuation-stripping step.


AUTHOR
======

Ian Phillipps <ian@unipalm.pipex.com>


COPYRIGHT
=========

Copyright Public IP Exchange Ltd (PIPEX).  Available for use under the
same terms as perl.




File: pm.info, Node: Text/GenderFromName, Next: Text/German, Prev: Text/English, Up: Module List

Guess the gender of a "Christian" first name.
*********************************************



NAME
====

`Text::GenderFromName' - Guess the gender of a "Christian" first name.


SYNOPSIS
========

     use Text::GenderFromName;
 
     print gender("Jon");    # prints "m"

Text::GenderFromName is available at a CPAN site near you.


DESCRIPTION
===========

This module provides a lone function: `gender()', which returns one of
three values: "m" for male, "f" for female", or UNDEF if it doesn't
know.  For instance, gender("Chris") is UNDEF.

The original code assumed a default of male, and I am happy to
contribute to the destruction of the oppressive Patriarchy by returning
an UNDEF value if no rule triggers.  Ha ha!  Seriously, it'll be useful
to know when `gender()' has no clue.

For the curious, I ran Text::GenderFromName on The Perl Journal's
subscriber list.  The result?

     Male:    68%
     Female:  32%


BUGS
====

`gender()' can never be perfect.

I'm sure that many of these rules could return immediately upon firing.
However, it's possible that the original author arranged them in a very
deliberate order, with more specific rules at the end overruling earlier
rules.  Consequently, I can't turn all of these rules into the speedier
form `return "f" if /.../' without throwing away the meaning of the
ordering.  If you have the stamina to plod through the rules and
determine when the ordering doesn't matter, let me know!

The rules should probably be made case-insensitive, but I bet there's
some funky situation in which that'll lose.


AUTHOR
======

Jon Orwant

The Perl Journal and MIT Media Lab

orwant@tpj.com

This is an adaptation of an 8/91 awk script by Scott Pakin in the
December 91 issue of Computer Language Monthly.

Small contributions by Andrew Langmead and John Strickler.




File: pm.info, Node: Text/German, Next: Text/ParseWords, Prev: Text/GenderFromName, Up: Module List

German grundform reduction
**************************



NAME
====

Text::German - German grundform reduction


SYNOPSYS
========

`use Text::German;'

`$stem = Text::German::reduce($word)'


DESCRIPTION
===========

This is a rather incomplete implementaion of work done by Gudrun
Putze-Meier `<gudrun.pm@t-online.de>'. I have to confess that I never
read her original paper. So all credit belongs to her, all bugs are
mine. I tried to get some insight from an implementation of two students
of mine. They remain anonymous because their work was the wost piece of
code I ever saw. My code behaves mostly as their implementation did
except it is about 75 times faster.


AUTHOR
======

Ulrich Pfeifer `<pfeifer@ls6.informatik.uni-dortmund.de>'



File: pm.info, Node: Text/ParseWords, Next: Text/Refer, Prev: Text/German, Up: Module List

parse text into an array of tokens
**********************************



NAME
====

Text::ParseWords - parse text into an array of tokens


SYNOPSIS
========

     use Text::ParseWords;
     @words = &quotewords($delim, $keep, @lines);
     @words = &shellwords(@lines);
     @words = &old_shellwords(@lines);


DESCRIPTION
===========

&quotewords() accepts a delimiter (which can be a regular expression)
and a list of lines and then breaks those lines up into a list of words
ignoring delimiters that appear inside quotes.

The $keep argument is a boolean flag.  If true, the quotes are kept with
each word, otherwise quotes are stripped in the splitting process.
$keep also defines whether unprotected backslashes are retained.

A &shellwords() replacement is included to demonstrate the new package.
This version differs from the original in that it will _NOT_ default to
using $_ if no arguments are given.  I personally find the old behavior
to be a mis-feature.

&quotewords() works by simply jamming all of @lines into a single string
in $_ and then pulling off words a bit at a time until $_ is exhausted.


AUTHORS
=======

Hal Pomeranz (pomeranz@netcom.com), 23 March 1994

Basically an update and generalization of the old shellwords.pl.  Much
code shamelessly stolen from the old version (author unknown).




File: pm.info, Node: Text/Refer, Next: Text/Soundex, Prev: Text/ParseWords, Up: Module List

parse Unix "refer" files
************************



NAME
====

Text::Refer - parse Unix "refer" files

*This is Alpha code, and may be subject to changes in its public
interface.  It will stabilize by June 1997, at which point this notice
will be removed.  Until then, if you have any feedback, please let me
know!*


SYNOPSIS
========

Pull in the module:

     use Text::Refer;  

Parse a refer stream from a filehandle:

     while ($ref = input Text::Refer \*FH)  {
     	# ...do stuff with $ref...
     }
     defined($ref) or die "error parsing input";

Same, but using a parser object for more control:
    
    # Create a new parser:
    $parser = new Text::Refer::Parser LeadWhite=>'KEEP';
    
    # Parse:
    while ($ref = $parser->input(\*FH)) {
	# ...do stuff with $ref...
    }
    defined($ref) or die "error parsing input";

Manipulating reference objects, using high-level methods:

     # Get the title, author, etc.:
     $title      = $ref->title;
     @authors    = $ref->author;      # list context
     $lastAuthor = $ref->author;      # scalar context

     # Set the title and authors:
     $ref->title("Cyberiad");
     $ref->author(["S. Trurl", "C. Klapaucius"]);   # arrayref for >1 value!

     # Delete the abstract:
     $ref->abstract(undef);

Same, using low-level methods:

     # Get the title, author, etc.:
     $title      = $ref->get('T');
     @authors    = $ref->get('A');      # list context
     $lastAuthor = $ref->get('A');      # scalar context

     # Set the title and authors:
     $ref->set('T', "Cyberiad");
     $ref->set('A', "S. Trurl", "C. Klapaucius");

     # Delete the abstract:
     $ref->set('X');                    # sets to empty array of values

Output:

     print $ref->as_string;


DESCRIPTION
===========

*This module supercedes the old Text::Bib.*

This module provides routines for parsing in the contents of
"refer"-format bibliographic databases: these are simple text files
which contain one or more bibliography records.  They are usually found
lurking on Unix-like operating systems, with the extension `.bib'.

Each record in a "refer" file describes a single paper, book, or
article.  Users of nroff/troff often employ such databases when
typesetting papers.

Even if you don't use *roff, this simple, easily-parsed parameter-value
format is still useful for recording/exchanging bibliographic
information.  With this module, you can easily post-process "refer"
files: search them, convert them into LaTeX, whatever.


Example
-------

Here's a possible "refer" file with three entries:

     %T Cyberiad
     %A Stanislaw Lem
     %K robot fable 
     %I Harcourt/Brace/Jovanovich

     %T Invisible Cities
     %A Italo Calvino
     %K city fable philosophy
     %X In this surreal series of fables, Marco Polo tells an
        aged Kublai Khan of the many cities he has visited in 
        his lifetime.  

     %T Angels and Visitations
     %A Neil Gaiman 
     %D 1993

The lines separating the records must be *completely blank*; that is,
they cannot contain anything but a single newline.

See refer(1) or grefer(1) for more information on "refer" files.


Syntax
------

*From the GNU manpage, `grefer(1)':*

The bibliographic database is a text file consisting of records
separated by one or more blank lines.  Within each record fields start
with a % at the beginning of a line.  Each field has a one character
name that immediately follows the %.  It is best to use only upper and
lower case letters for the names of fields. The name of the field should
be followed by exactly one space, and then by the contents of the field.
Empty fields are ignored.  The conventional meaning of each field is as
follows:

A
     The name of an author. If the name contains a title such as Jr. at
     the end, it should be separated from the last name by a comma.
     There can be multiple occurrences of the A field.  The order is
     significant.  It is a good idea always to supply an A field or a Q
     field.

B
     For an article that is part of a book, the title of the book

C
     The place (city) of publication.

D
     The date of publication.  The year should be specified in full.  If
     the month is specified, the name rather than the number of the
     month should be used, but only the first three letters are
     required.  It is a good idea always to supply a D field; if the
     date is unknown, a value such as "in press" or "unknown" can be
     used.

E
     For an article that is part of a book, the name of an editor of the
     book.  Where the work has editors and no authors, the names of the
     editors should be given as A fields and , (ed) or , (eds) should be
     appended to the last author.

G
     US Government ordering number.

I
     The publisher (issuer).

J
     For an article in a journal, the name of the journal.

K
     Keywords to be used for searching.

L
     Label.

     *NOTE:* Uniquely identifies the entry.  For example, "Able94".

N
     Journal issue number.

O
     Other information.  This is usually printed at the end of the
     reference.

P
     Page number.  A range of pages can be specified as m-n.

Q
     The name of the author, if the author is not a person.  This will
     only be used if there are no A fields.  There can only be one Q
     field.

     *NOTE:* Thanks to Mike Zimmerman for clarifying this for me:
     it means a "corporate" author: when the "author" is listed as an
     organization such as the UN, or RAND Corporation, or whatever.

R
     Technical report number.

S
     Series name.

T
     Title.  For an article in a book or journal, this should be the
     title of the article.

V
     Volume number of the journal or book.

X
     Annotation.

     *NOTE:* Basically, a brief abstract or description.

For all fields except A and E, if there is more than one occurrence of a
particular field in a record, only the last such field will be used.

If accent strings are used, they should follow the character to be
accented.  This means that the AM macro must be used with the -ms
macros.  Accent strings should not be quoted: use one \ rather than two.


Parsing records from "refer" files
----------------------------------

You will nearly always use the `input()' constructor to create new
instances, and nearly always as shown in the `"SYNOPSIS"' in this node.

Internally, the records are parsed by a parser object; if you invoke the
class method `Text::Refer::input()', a special default parser is used,
and this will be good enough for most tasks.  However, for more complex
tasks, feel free to use `"class Text::Refer::Parser"' in this node to
build (and use) your own fine-tuned parser, and `input()' from that
instead.


CLASS Text::Refer
=================

Each instance of this class represents a single record in a "refer"
file.


Construction and input
----------------------

new
     *Class method, constructor.*
     Build an empty "refer" record.

input FILEHANDLE
     *Class method.*
     Input a new "refer" record from a filehandle.  The default parser
     is used:

          while ($ref = input Text::Refer \*STDIN) {
          	# ...do stuff with $ref...
          }

     Do *not* use this as an instance method; it will not re-init the
     object you give it.


Getting/setting attributes
--------------------------

attr ATTR, [VALUE]
     *Instance method.*
     Get/set the attribute by its one-character name, ATTR.  The VALUE
     is optional, and may be given in a number of ways:

        * *If the VALUE is given as undefined*, the attribute will be deleted:

               $ref->attr('X', undef);        # delete the abstract

        * *If a defined, non-reference scalar VALUE is given,* it is used to 
          replace the existing values for the attribute with that
          *single* value:

               $ref->attr('T', "The Police State Rears Its Ugly Head");
               $ref->attr('D', 1997);

        * *If an arrayref VALUE is given,* it is used to replace the existing values
          for the attribute with *all elements of that array:*

               $ref->attr('A', ["S. Trurl", "C. Klapaucius"]);

          We use an arrayref since an empty array would be impossible to
          distinguish from the next two cases, where the goal is to
          "get" instead of "set"...

     This method returns the current (or new) value of the given
     attribute, just as `get()' does:

        * *If invoked in a scalar context,* the method will return the
          last value (this is to mimic the behavior of *groff*).  Hence,
          given the above, the code:

               $author = $ref->attr('A');

          will set `$author' to `"C. Klapaucius"'.

        * *If invoked in an array context,* the method will return the list 
          of all values, in order.  Hence, given the above, the code:

               @authors = $ref->attr('A');

          will set `@authors' to `("S. Trurl", "C. Klapaucius")'.

     *Note:* this method is used as the basis of all "named" access 
     methods; hence, the following are equivalent in every way:

          $ref->attr(T => $title)    <=>   $ref->title($title);
          $ref->attr(A => \@authors) <=>   $ref->author(\@authors);
          $ref->attr(D => undef)     <=>   $ref->date(undef);
          $auth  = $ref->attr('A')   <=>   $auth  = $ref->author;
          @auths = $ref->attr('A')   <=>   @auths = $ref->author;

author, book, city, ... [VALUE]
     *Instance methods.*
     For every one of the standard fields in a "refer" record, this
     module has designated a high-level attribute name:

          A  author     G  govt_no      N  number        S  series   
          B  book       I  publisher    O  other_info    T  title     
          C  city       J  journal      P  page          V  volume    
          D  date       K  keywords     Q  corp_author   X  abstract  
          E  editor     L  label        R  report_no    

     Then, for each field *F* with high-level attribute name
     *FIELDNAME*, the method `FIELDNAME()' works as follows:

          $ref->attr('F', @args)     <=>   $ref->FIELDNAME(@args)

     Which means:

          $ref->attr(T => $title)    <=>   $ref->title($title);
          $ref->attr(A => \@authors) <=>   $ref->author(\@authors);
          $ref->attr(D => undef)     <=>   $ref->date(undef);
          $auth  = $ref->attr('A')   <=>   $auth  = $ref->author;
          @auths = $ref->attr('A')   <=>   @auths = $ref->author;

     See the documentation of attr() for the argument list.

get ATTR
     *Instance method.*
     Get an attribute, by its one-character name.  In an array context,
     it returns all values (empty if none):

          @authors = $ref->get('A');      # returns list of all authors

     In a scalar context, it returns the last value (undefined if none):

          $author = $ref->get('A');       # returns the last author

set ATTR, VALUES...
     *Instance method.*
     Set an attribute, by its one-character name.

          $ref->set('A', "S. Trurl", "C. Klapaucius");

     An empty array of VALUES deletes the attribute:

          $ref->set('A');       # deletes all authors

     No useful return value is currently defined.


Output
------

as_string [OPTSHASH]
     *Instance method.*
     Return the "refer" record as a string, usually for printing:

          print $ref->as_string;

     The options are:

     Quick
          If true, do it quickly, but unsafely.  
          *This does no fixup on the values at all:* they are output as-is.  
          That means if you used parser-options which destroyed any of
          the formatting whitespace (e.g., `Newline=TOSPACE' with
          `LeadWhite=KILLALL'), there is a risk that the output object
          will be an invalid "refer" record.

     The fields are output with %L first (if it exists), and then the
     remaining fields in alphabetical order.  The following "safety
     measures" are normally taken:

        * Lines longer than 76 characters are wrapped (if possible, at a
          non-word character a reasonable length in, but there is a
          chance that they will simply be "split" if no such character
          is available).

        * Any occurences of '%' immediately after a newline are preceded
          by a single space.

     These safety measures are slightly time-consuming, and are silly if
     you are merely outputting a "refer" object which you have read in
     verbatim (i.e., using the default parser-options) from a valid
     "refer" file.  In these cases, you may want to use the Quick
     option.
    
     =cut

     sub as_string {
         my ($self, %opts) = @_;
         my ($key, $val);

          # Figure out the keys to use, and put them in order:
          my @keys = sort grep {(length == 1) && ($_ ne 'L')} (keys %$self);
          defined($self->{'L'}) && unshift(@keys, 'L');

          # Output:
          my @lines;
          foreach $key (@keys) {
          	foreach $val (@{$self->{$key}}) {
          	    unless ($opts{Quick}) {
          		### print "UNWRAPPED = [$val]\n";
          		_wrap($val);             # make sure no line exceeds 80 chars
          		### print "WRAPPED   = [$val]\n";
          		$val =~ s/\n%/\n %/g;    # newlines must NOT be followed by %
          		$val =~ s/\n+\Z//;       # strip trailing newlines
          	    }
          	    push @lines, join('', '%', $key, ' ', $val, "\n");
          	}
          }
          join '', @lines;
          }


CLASS Text::Refer::Parser
=========================

Instances of this class do the actual parsing.


Parser options
--------------

The options you may give to new() are as follows:

ForgiveEOF
     Normally, the last record in a file must end with a blank line, or
     else this module will suspect it of being incomplete and return an
     error.  However, if you give this option as true, it will allow the
     last record to be terminated by an EOF.

GoodFields
     By default, the parser accepts any (one-character) field name that
     is a printable ASCII character (no whitespace).  Formally, this is:

          [\041-\176]

     However, when compiling parser options, you can supply your own
     regular expression for validating (one-character) field names.
     (*note:* you must supply the square brackets; they are there to
     remind you that you should give a well-formed single-character
     expression).  One standard expression is provided for you:

          $Text::Refer::GroffFields  = '[A-EGI-LN-TVX]';  # legal groff fields

     Illegal fields which are encounterd during parsing result in a
     syntax error.

     *NOTE:* You really shouldn't use this unless you absolutely need to.
     The added regular expression test slows down the parser.

LeadWhite
     In many "refer" files, continuation lines (the 2nd, 3rd, etc. lines
     of a field) are written with leading whitespace, like this:

          %T Incontrovertible Proof that Pi Equals Three
             (for Large Values of Three)
          %A S. Trurl
          %X The author shows how anyone can use various common household 
             objects to obtain successively less-accurate estimations of 
             pi, until finally arriving at a desired integer approximation,
             which nearly always is three.                 

     This leading whitespace serves two purposes: (1) it makes it
     impossible to mistake a continuation line for a field, since % can
     no longer be the first character, and (2) it makes the entries
     easier to read.  The LeadWhite option controls what is done with
     this whitespace:

          KEEP	- default; the whitespace is untouched
          KILLONE	- exactly one character of leading whitespace is removed
          KILLALL	- all leading whitespace is removed

     See the section below on "using the parser options" for hints and
     warnings.

Newline
     The Newline option controls what is done with the newlines that
     separate adjacent lines in the same field:

          KEEP	- default; the newlines are kept in the field value
          TOSPACE	- convert each newline to a single space
          KILL	- the newlines are removed

     See the section below on "using the parser options" for hints and
     warnings.

Default values will be used for any options which are left unspecified.


Notes on the parser options
---------------------------

The default values for Newline and LeadWhite will preserve the input
text exactly.

The `Newline=TOSPACE' option, when used in conjunction with the
`LeadWhite=KILLALL' option, effectively "word-wraps" the text of each
field into a single line.

*Be careful!* If you use the `Newline=KILL' option with
either the `LeadWhite=KILLONE' or the `LeadWhite=KILLALL' option, you
could end up eliminating all whitespace that separates the word at the
end of one line from the word at the beginning of the next line.


Public interface
----------------

new PARAMHASH
     *Class method, constructor.*
     Create and return a new parser.  See above for the `"parser
     options"' in this node which you may give in the PARAMHASH.

create [CLASS]
     *Instance method.*
     What class of objects to create.  The default is `Text::Refer'.

input FH
     *Instance method.*
     Create a new object from the next record in a "refer" stream.  The
     actual class of the object is given by the `class()' method.

     Returns the object on success, '0' on *expected* end-of-file, and
     undefined on error.

     Having two false values makes parsing very simple: just `input()'
     records until the result is false, then check to see if that last
     result was 0 (end of file) or undef (failure).


NOTES
=====


Under the hood
--------------

Each "refer" object has instance variables corresponding to the actual
field names (`'T'', `'A'', etc.).  Each of these is a reference to an
array of the actual values.

Notice that, for maximum flexibility and consistency (but at the cost of
some space and access-efficiency), the semantics of "refer" records do
not come into play at this time: since everything resides in an array,
you can have as many %K, %D, etc. records as you like, and given them
entirely different semantics.

For example, the Library Of Boring Stuff That Everyone Reads (LOBSTER)
uses the unused %Y as a "year" field.  The parser accomodates this case
by politely not choking on LOBSTER .bibs (although why you would want to
eat a lobster bib instead of the lobster is beyond me...).


Performance
-----------

Tolerable.  On my 90MHz/32 MB RAM/I586 box running Linux 1.2.13 and
Perl5.002, it parses a typical 500 KB "refer" file (of 1600 records) as
follows:

     8 seconds of user time for input and no output
         10 seconds of user time for input and "quick" output
         16 seconds of user time for input and "safe" output

So, figure the individual speeds are:

     input:            200 records ( 60 KB) per second.
     "quick" output:   800 records (240 KB) per second.
     "safe" output:    200 records ( 60 KB) per second.

By contrast, a C program which does the same work is about 8 times as
fast.  But of course, the C code is 8 times as large, and 8 times as
ugly...  `:-)'


Note to serious bib-file users
------------------------------

I actually do not use "refer" files for *roffing... I used them as a
quick-and-dirty database for WebLib, and that's where this code comes
from.  If you're a serious user of "refer" files, and this module
doesn't do what you need it to, please contact me: I'll add the
functionality in.


BUGS
====

Some combinations of parser-options are silly.


CHANGE LOG
==========

$Id: Refer.pm,v 1.106 1997/04/22 18:41:41 eryq Exp $

Version 1.101
     Initial release.  Adapted from Text::Bib.


AUTHOR
======

Copyright (C) 1997 by Eryq, `eryq@enteract.com',
`http://www.enteract.com/~eryq'.


NO WARRANTY
===========

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2 of the License, or (at your
option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

For a copy of the GNU General Public License, write to the Free Software
Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.




File: pm.info, Node: Text/Soundex, Next: Text/Striphigh, Prev: Text/Refer, Up: Module List

Implementation of the Soundex Algorithm as Described by Knuth
*************************************************************



NAME
====

Text::Soundex - Implementation of the Soundex Algorithm as Described by
Knuth


SYNOPSIS
========

     use Text::Soundex;

     $code = soundex $string;            # get soundex code for a string
     @codes = soundex @list;             # get list of codes for list of strings

     # set value to be returned for strings without soundex code

     $soundex_nocode = 'Z000';


DESCRIPTION
===========

This module implements the soundex algorithm as described by Donald
Knuth in Volume 3 of *The Art of Computer Programming*.  The algorithm
is intended to hash words (in particular surnames) into a small space
using a simple model which approximates the sound of the word when
spoken by an English speaker.  Each word is reduced to a four character
string, the first character being an upper case letter and the remaining
three being digits.

If there is no soundex code representation for a string then the value
of `$soundex_nocode' is returned.  This is initially set to undef, but
many people seem to prefer an *unlikely* value like `Z000' (how unlikely
this is depends on the data set being dealt with.)  Any value can be
assigned to `$soundex_nocode'.

In scalar context `soundex' returns the soundex code of its first
argument, and in array context a list is returned in which each element
is the soundex code for the corresponding argument passed to `soundex'
e.g.

     @codes = soundex qw(Mike Stok);

leaves `@codes' containing `('M200', 'S320')'.


EXAMPLES
========

Knuth's examples of various names and the soundex codes they map to are
listed below:

     Euler, Ellery -> E460
     Gauss, Ghosh -> G200
     Hilbert, Heilbronn -> H416
     Knuth, Kant -> K530
     Lloyd, Ladd -> L300
     Lukasiewicz, Lissajous -> L222

so:

     $code = soundex 'Knuth';              # $code contains 'K530'
     @list = soundex qw(Lloyd Gauss);	# @list contains 'L300', 'G200'


LIMITATIONS
===========

As the soundex algorithm was originally used a *long* time ago in the US
it considers only the English alphabet and pronunciation.

As it is mapping a large space (arbitrary length strings) onto a small
space (single letter plus 3 digits) no inference can be made about the
similarity of two strings which end up with the same soundex code.  For
example, both `Hilbert' and `Heilbronn' end up with a soundex code of
`H416'.


AUTHOR
======

This code was implemented by Mike Stok (`stok@cybercom.net') from the
description given by Knuth.  Ian Phillips (`ian@pipex.net') and Rich
Pinder (`rpinder@hsc.usc.edu') supplied ideas and spotted mistakes.



File: pm.info, Node: Text/Striphigh, Next: Text/Tabs, Prev: Text/Soundex, Up: Module List

Perl extension to strip the high bit off of ISO-8859-1 text.
************************************************************



NAME
====

Text::Striphigh - Perl extension to strip the high bit off of ISO-8859-1
text.


SYNOPSIS
========

     use Text::Striphigh 'striphigh'

     $SevenBitsText = striphigh($TextContainingEightBitCharacters);


DESCRIPTION
===========

The Text::Striphigh module exports a single function: `striphigh'. This
function takes one argument, a string possibly containing high ASCII
characters in the ISO-8859-1 character set, and transforms this into a
string containing only 7 bits ASCII characters, by substituting every
high bit character with a similar looking standard ASCII character, or
with a sequence of standard ASCII characters.

Because of precisely the deficiency this package tries to offer a
workaround for is present in some of the things that process pod, there
are no examples in this manpage. Look at the source or the test script
if you want examples.


MAINTENANCE
===========

If you ever want to change the striphigh function yourself, then don't
change the one containing the mile long `tr{}{}' statement that you see
at first, change the one behind the `__DATA__' that's a lot more
readable.

After you've done that, simply run the `Striphigh.pm' file through perl
to generate a new version of the first routine, and in fact of the
entire file, something like this:

     perl -w Striphigh.pm > Striphigh.pm.new
     mv Striphigh.pm.new Striphigh.pm


BUGS
====

Assumes the input text is ISO-8859-1, without even looking at the LOCALE
settings.

Some translations are probably less than optimal.

People will be offended if you run their names through this function,
and print the result on an envelope using an outdated printing
device. However, it's probably better than having that printer print a
name with a high ASCII character in it which happens to be the command
to set the printer on fire.


AUTHOR
======

Jan-Pieter Cornet <johnpc@xs4all.nl>



File: pm.info, Node: Text/Tabs, Next: Text/TeX, Prev: Text/Striphigh, Up: Module List

expand and unexpand tabs per the unix expand(1) and unexpand(1)
***************************************************************



NAME
====

Text::Tabs -- expand and unexpand tabs per the unix expand(1) and
unexpand(1)


SYNOPSIS
========

use Text::Tabs;

$tabstop = 4;
 @lines_without_tabs = expand(@lines_with_tabs);
 @lines_with_tabs = unexpand(@lines_without_tabs);


DESCRIPTION
===========

Text::Tabs does about what the unix utilities expand(1) and unexpand(1)
do.  Given a line with tabs in it, expand will replace the tabs with the
appropriate number of spaces.  Given a line with or without tabs in it,
unexpand will add tabs when it can save bytes by doing so.  Invisible
compression with plain ascii!


BUGS
====

expand doesn't handle newlines very quickly -- do not feed it an entire
document in one string.  Instead feed it an array of lines.


AUTHOR
======

David Muir Sharnoff <muir@idiom.com>



File: pm.info, Node: Text/TeX, Next: Text/Template, Prev: Text/Tabs, Up: Module List

Perl module for parsing of `TeX'.
*********************************



NAME
====

Text::TeX -- Perl module for parsing of `TeX'.


SYNOPSIS
========

     use Text::TeX;

     sub report {
       my($eaten,$txt) = (shift,shift);
       print "Comment: `", $eaten->[1], "'\n" if defined $eaten->[1];
       print "@{$txt->{waitfors}} ", ref $eaten, ": `", $eaten->[0], "'";
       if (defined $eaten->[3]) {
         my @arr = @{ $eaten->[3] };
         foreach (@arr) {
     	print " ", $_->print;
         }
       }
       print "\n";
     }

     my $file = new Text::TeX::OpenFile 'test.tex',
       'defaultact' => \&report;
     $file->process;


DESCRIPTION
===========

A new `TeX' parser is created by

     $file = new Text::TeX::OpenFile $filename, attr1 => $val1, ...;

$filename may be undef, in this case the text to parse may be specified
in the attribute string.

Recognized attributes are:

string
     contains the text to parse before parsing $filename.

`defaultact'
     denotes a procedure to submit `output tokens' to.

`tokens'
     gives a hash of `descriptors' for `input token'. A sane default is
     provided.

A call to the method `process' launches the parser.


Tokenizer
---------

When the parser is running, it processes input stream by splitting it
into `input tokens' using some *heuristics* similar to the actual rules
of TeX tokenizer. However, since it does not use *the exact rules*, the
resulting tokens may be wrong if some advanced TeX command are used,
say, the character classes are changed.

This should not be of any concern if the stream in question is a "user"
file, but is important for "packages".


Digester
--------

The processed `input tokens' are handled to the digester, which handles
them according to the provided `tokens' attribute.


`tokens' attribute
------------------

This is a hash reference which describes how the `input tokens' should
be handled. A key to this hash is a literal like `^' or `\fraction'. A
value should be another hash reference, with the following keys
recognized:

class
     Into which class to bless the token. Several predefined classes are
     provided. The default is `Text::TeX::Token'.

Type
     What kind of special processing to do with the input after the
     class methods are called. Recognized Types are:

     report_args
          When the token of this Type is encountered, it is converted
          into `Text::Tex::BegArgsToken'. Then the arguments are
          processed as usual, and an `output token' of type
          `Text::Tex::ArgToken' is inserted between them. Finally, after
          all the arguments are processed, an `output token'
          `Text::Tex::EndArgsToken' is inserted.

          The first element of these simulated `output tokens' is an
          array reference with the first element being the initial
          `output token' which generated this sequence. The second
          element of the internal array is the number of arguments
          required by the `input token'. The `Text::Tex::ArgToken' token
          has a third element, which is the ordinal of the argument
          which ends immediately before this token.

          If requested, a token `Text::Tex::LookAhead' may be returned
          instead of `Text::Tex::EndArgsToken'. The additional elements
          of `$token-'[0]> are: the reference to the corresponding
          `lookahead' attribute, the relevant key (text of following
          token) and the corresponding value.

          In such a case the input token which was looked-ahead would
          generate an output token of type
          `Text::Tex::BegArgsTokenLookedAhead' (if it usually generates
          `Text::Tex::BegArgsToken').

     local
          Means that these macro introduces a local change, which should
          be undone at the end of enclosing block. At the end of the
          block an output event `Text::TeX::EndLocal' is delivered, with
          `$token-'[0]> being the output token for the local event
          starting.

          Useful for font switching.

Some additional keys may be recognized by the code for the particular
class.

count
     number of arguments to the macro.

`waitfor'
     gives the matching token for a *starting delimiter* token.

`eatargs'
     number of tokens to swallow literally and put into the relevant
     slot of the `output token'. The surrounding braces are stripped.

`selfmatch'
     is used with `eatargs==1'. Denotes that the matching token is also
     `eatargs==1', and the swallowed tokens should coinside (like with
     `\begin{blah} ... \end{blah}').

`lookahead'
     is a hash with keys being texts of tokens which need to be treated
     specially after the end of arguments for the current token. If the
     corresponding text follows the token indeed, a token
     `Text::Tex::LookAhead' is returned instead of
     `Text::Tex::EndArgsToken'.


Symbol font table
-----------------

The hash %Text::TeX::xfont contains the translation table from TeX
tokens into the corresponding font elements. The values are array
references of the form `[fontname, char]', Currently the only font
supported is `symbol'.


AUTHOR
======

Ilya Zakharevich, ilya@math.ohio-state.edu


SEE ALSO
========

perl(1).




File: pm.info, Node: Text/Template, Next: Text/Vpp, Prev: Text/TeX, Up: Module List

Expand template text with embedded Perl
***************************************



NAME
====

Text::Template - Expand template text with embedded Perl


SYNOPSIS
========

     use Text::Template;

     $template = new Text::Template ('type' => FILE, 'source' => 'f.tmpl');
       # or
     $template = new Text::Template ('type' => ARRAY, 
     				 'source' => [ ... ] );
       # or
     $template = new Text::Template ('type' => FILEHANDLE, 
     					'source' => $fh );

     $recipient = 'King';
     $text = $template->fill_in();
     print $text;

     $T::recipient = 'Josh';
     $text = $template->fill_in('package' => T);
     print $text;

     $text = $template->fill_in('broken' => \&callback);

     use Text::Template fill_this_in;
     $text = fill_this_in( <<EOM, 'package' => T);
     Dear {$recipient},
     Pay me at once.
            Love, 
             G.V.
     EOM

     print Text::Template->Version;


OVERVIEW
========

This is a library for printing form letters!  This is a library for
playing Mad Libs!

A `template' is a piece of text that has little Perl programs embedded
in it here and there.  When you `fill in' a template, you evaluate the
little programs and replace them with their values.

This is a good way to generate many kinds of output, such as error
messages and HTML pages.  Here is one way I use it: I am a freelance
computer consultant; I write world-wide web applications.  Usually I
work with an HTML designer who designs the pages for me.

Often these pages change a lot over the life of the project: The
client's legal department takes several tries to get the disclaimer just
right; the client changes the background GIF a few times; the text moves
around, and soforth.  These are all changes that are easy to make.
Anyone proficient with the editor can go and make them.  But if the page
is embedded inside a Perl program, I don't want the designer to change
it because you never know what they might muck up.  I'd like to put the
page in an external file instead.

The trouble with that is that parts of the page really are generated by
the program; it needs to fill in certani values in some places, maybe
conditionally include some text somewhere else.  The page can't just be
a simple static file that the program reads in and prints out.

A template has blanks, and when you print one out, the blanks are filled
in automatically, so this is no trouble.  And because the blanks are
small and easy to recognize, it's easy to tell the page designer to stay
away from them.

Here's a sample template:

     Dear {$title} {$lastname},

     It has come to our attention that you are delinquent in your
     {$last_paid_month} payment.  Please remit ${$amount} immediately,
     or your patellae may be needlessly endangered.

     Love,

     Mark "Vizopteryx" Dominus

Pretty simple, isn't it?  Items in curly braces `{' `}' get filled in;
everything else stays the same.  Anyone can understand that.  You can
totally believe that the art director isn't going to screw this up while
editing it.

You can put any perl code you want into the braces, so instead of
`{$amount}', you might want to use `{sprintf("%.2f", $amount)}', to
print the amount rounded off to the nearest cent.

This is good for generating form letters, HTML pages, error messages,
and probably a lot of other things.

Detailed documentation follows:


Constructor: new
----------------

     new Text::Template ( attribute => value, ... );

This creates a new template object.  You specify the source of the
template with a set of attribute-value pairs in the arguments.

At present, there are only two attributes.  One is type; the other is
`source'.  type can be `FILEHANDLE', FILE, or `ARRAY'.  If type is FILE,
then the `source' is interpreted as the name of a file that contains the
template to fill out.  If type is `FILEHANDLE', then the `source' is
interpreted as the name of a filehandle, which, when read, will deliver
the template to fill out.  A type of `ARRAY' means that the `source' is
a reference to an array of strings; the template is the concatentation
of these strings.

Neither type nor `source' are optional yet.

Here are some examples of how to call new:

     $template = new Text::Template 
     	('type' => 'ARRAY', 
     	 'source' => [ "Dear {\$recipient}\n",
     			"Up your {\$nose}.\n",
     			"Love, {\$me}.\n" ]);

     $template = new Text::Template 
     	('type' => 'FILE', 
     	 'source' => '/home/mjd/src/game/youlose.tmpl');

new returns a template object on success, and undef on failure.  On an
error, it puts an error message in the variable
`$Text::Template::ERROR'.


`fill_in'
---------

Fills in a template.  Returns the resulting text.

Like new, `fill_in' accepts a set of attribute-value pairs.  At present,
the only attributes are package and `broken'.

Here's an example: Suppose that `$template' contains a template object
that we created with this template:

     Dear {$name},
     	You owe me ${sprintf("%.2f", $amount)}.
     	Pay or I will break your {$part}.
     			Love,
     			Uncle Dominus.  

Here's how you might fill it in:

     $name = 'Donald';
     	$amount = 141.61;
     	$part = 'hyoid bone';

     $text = $template->fill_in();

Here's another example:

     Your Royal Highness,

     Enclosed please find a list of things I have gotten
     for you since 1907:

     { $list = '';
       foreach $item (@things) {
         $list .= " o \u$item\n";
       }
       $list
     }

     Signed,
     Lord High Chamberlain

We want to pass in an array which will be assigned to the array
`@things'.  Here's how to do that:

     @the_things = ('ivory', 'apes', 'peacocks', );
     $template->fill_in();

This is not very safe.  The reason this isn't as safe is that if you had
any variables named `$list' or `$item' in scope in your program at the
point you called `fill_in', their values would be clobbered by the act
of filling out the template.

The next section will show how to make this safer.

package
     The value of the package attribute names a package which contains
     the variables that should be used to fill in the template.  If you
     omit the package attribute, `fill_in' uses the package that was
     active when it was called.

     Here's a safer version of the `Lord High Chamberlain' example from
     the previous section:

          @VARS::the_things = ('ivory', 'apes', 'peacocks', );
          $template->fill_in('package' => VARS);

     This call to `fill_in' clobbers `$VARS::list' and `$VARS::item'
     instead of clobbering `$list' and `$item'.  If your program didn't
     use anything in the `VARS' package, you don't have to worry that
     filling out the template is altering on your variables.

`broken'
     If you specify a value for the `broken' attribute, it should be a
     reference to a function that `fill_in' can call if one of the
     little programs fails to evaluate.

     `fill_in' will pass an associative array to the `broken' function.
     The associative array will have at least these two members:

          text => (The full text of the little program that failed)
          error => (The text of the error message (C<$@>) generated by eval)

     If the `broken' function returns a text string, `fill_in' will
     insert it into the template in place of the broken program, just as
     though the broken program had evaluated successfully and yielded
     that same string.  If the `broken' function returns undef,
     `fill_in' will stop filling in the template, and will immediately
     return undef itself.

     If you don't specify a `broken' function, you get a default one
     that inserts something like this:

          Warning

          This part of the template:
          	1/0

          Returned the following errors:
          	Illegal division by zero at (eval 7) line 2.


`fill_this_in'
--------------

Maybe it's not worth your trouble to put the template into a file; maybe
it's a small file, and you want to leave it inline in the code.  Maybe
you don't want to have to worry about managing template objects.  In
that case, use `fill_this_in'.  You give it the entire template as a
string argument, follow with variable substitutions just like in
`fill_in', and it gives you back the filled-in text.

An example:

     $Q::name = 'Donald';
     $Q::amount = 141.61;
     $Q::part = 'hyoid bone';

     $text = fill_this_in Text::Template ( <<EOM, 'package' => Q);
     Dear {\$name},
     You owe me {sprintf('%.2f', \$amount)}.  
     Pay or I will break your {\$part}.
     	Love,
     	Grand Vizopteryx of Irkutsk.
     EOM


Version   Version Text::Template ();
====================================

Returns the current version of the `Text::Template' package.  The
current version is `'Text::Template 0.1 beta $Revision: 1.4 $ $Date:
1996/01/25 19:31:12 $''.


Template Format
===============

Here's the deal with templates: Anything in braces is a little program,
which is evaluated, and replaced with its perl value.  A backslashed
character has no special meaning, so to include a literal `{' in your
template, use `\{', and to include a literal `\', use `\\'.

A little program starts at an open brace and ends at the matching close
brace.  This means that your little programs can include braces and you
don't need to worry about it.  See the example below for an example of
braces inside a little program.

If an expression at the beginning of the template has side effects, the
side effects carry over to the subsequent expressions.  For example:

     {$x = @things; ''} The Lord High Chamberlain has gotten {$x}
     things for me this year.  
     { $diff = $x - 17; 
       $more = 'more'
       if ($diff == 0) {
         $diff = 'no';
       } elsif ($diff < 0) {
         $more = 'fewer';
       } 
     } 
     That is {$diff} {$more} than he gave me last year.

Notice that after we set $x in the first little program, its value
carries over to the second little program, and that we can set `$diff'
and `$more' on one place and use their values again later.

All variables are evaluated in the package you specify as an argument to
`fill_in'.  This means that if your templates don't do anything
egregiously stupid, you don't have to worry that evaluation of the
little programs will creep out into the rest of your program and wreck
something.  On the other hand, there's really no way to protect against
a template that says

     { $Important::Secret::Security::Enable = 0; 
       # Disable security checks in this program 
     }

or even

     { system("rm -rf /") }

so *don't* go filling in templates unless you're sure you know what's in
them.  This package may eventually use Perl's Safe extension to fill in
templates in a safe compartment.


AUTHOR
======

Mark-Jason Dominus, Plover Systems

`mjd@pobox.com'


SUPPORT?
========

This software is version 0.1 beta.  It probably has bugs.  It is
inadequately tested.  Suggestions and bug reports are always welcome.


BUGS AND CAVEATS
================

This package is in beta testing and should not be used in critical
applications.

This package should fill in templates in a Safe compartment.

The callback function that `fill_in' calls when a template contains an
error should be eble to return an error message to the rest of the
program.

my variables in `fill_in' are still susceptible to being clobbered by
template evaluation.  Perhaps it will be safer to make them local
variables.

Maybe there should be a utility method for emptying out a package?

Maybe there should be a utility function for doing `#include'.  It would
be easy.  (John Cavanaugh, `sdd@hp.com')

Maybe there should be a control item for doing #if.  Perl's `if' is
sufficient, but a little cumbersome to handle the quoting.




