Info file: pm.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `bigpm.texi'
using `texinfmt.el' version 2.32 of 19 November 1993.





File: pm.info, Node: Tk/Ghostscript, Next: Tk/HTML/IO, Prev: Tk/Getopt, Up: Module List

Beginings of a lowlevel PostScript viewing widget
*************************************************



NAME
====

Ghostscript - Beginings of a lowlevel PostScript viewing widget


SYNOPSIS
========

     my $gs= $parent->Ghostscript(
                     'x_pixels_per_inch' => $scale,
                     'y_pixels_per_inch' => $scale,
                     'BoundingBox' => [ 0,0, $width, $height]
                     );
     $gs->Postscript("....");


DESCRIPTION
===========

Tested with gs3 via `pgs' and `Ghostview.pm'.

Aim is to have both GS and "Display Postscript" widgets which present
same interface to higher level document viewers.




File: pm.info, Node: Tk/HTML/IO, Next: Tk/IO, Prev: Tk/Ghostscript, Up: Module List

Tk I/O routines for the LWP library
***********************************



NAME
====

LWP::TkIO - Tk I/O routines for the LWP library


SYNOPSIS
========

     use Tk;
     require LWP::TkIO;
     require LWP::UserAgent;


DESCRIPTION
===========

This module provide replacement functions for the LWP::IO
functions. Require this module if you use Tk and want non exclusive IO
behaviour from LWP.

See also *Note LWP/IO: LWP/IO,.




File: pm.info, Node: Tk/IO, Next: Tk/Internals, Prev: Tk/HTML/IO, Up: Module List

high level interface to Tk's 'fileevent' mechanism
**************************************************



NAME
====

Tk::IO - high level interface to Tk's 'fileevent' mechanism


SYNOPSIS
========

     my $fh = Tk::IO->new(-linecommand => callback, -childcommand => callback);
     $fh->exec("command")
     $fh->wait
     $fh->kill


WARNING
=======

INTERFACES TO THIS MODULE MAY CHANGE AS PERL'S IO EVOLVES AND WITH PORT
OF TK4.1


DESCRIPTION
===========

Tk::IO is now layered on perl's IO::Handle class. Interfaces have
changed, and are still evolving.

In theory C methods which enable non-blocking IO as in earlier Tk-b*
release(s) are still there. I have not changed them to use perl's
additional Configure information, or tested them much.

Assumption is that exec is used to fork a child process and a callback
is called each time a complete line arrives up the implied pipe.

"line" should probably be defined in terms of perl's input record
separator but is not yet.

The -childcommand callback is called when end-of-file occurs.

$fh->wait can be used to wait for child process while processing other
Tk events.

$fh->kill can be used to send signal to child process.


BUGS
====

Still not finished.  Idea is to use "exec" to emulate "system" in a
non-blocking manner.




File: pm.info, Node: Tk/Internals, Next: Tk/LabFrame, Prev: Tk/IO, Up: Module List

what is Perl Tk interface doing when you call Tk functions.
***********************************************************



NAME
====

CallingTk - what is Perl Tk interface doing when you call Tk functions.

This information is worse than useless for `perlTk' users, but can of
some help for people interested in using modified Tk source with
`perlTk'.

*This document is under construction. The information is believed to
be pertinent to the version of* `portableTk' *available when it was
created. All the details are subject to change.*


DESCRIPTION
===========

PreCompiling
     Before the actual compilation stage a script scans the source and
     extracts the subcommands of different commands. This information
     resides in the file `pTk/Methods.def'.

Compilation
     During compilation the above file is included in the source of
     booting routine of dynamic (or static) library. More precisely, the
     booting code of module `Tk' calls the subroutine Boot_Glue() from
     the module `tkGlue.c', and this subroutine includes the file (with
     appropriate macro definitions).

Inside `use Tk;'
     The module bootstraps the C code, then loads the Perl
     libraries. The heart of the Perl code is contained in the
     `Tk::Widget' library, all the widgets inherit from this
     module. Code for toplevels is loaded from `Tk::MainWindow'.

     During bootstrap of the C glue code the `Xevent::?' codes and a
     handful of `Tk::Widget' and `Tk::Image' routines are defined. (Much
     more XSUBs are created from `Tk.xs' code.) The widget subcommands
     are glued to Perl basing on the list included from
     `pTk/Methods.def'. In fact all the subcommands are glued to XSUBs
     that are related to the same C subroutine XStoWidget(), but have
     different data parts.

     During the Perl code bootstrap the method `Tk::Widget::import' is
     called. This call requires all the code from particular widget
     packages.

     Code from the widget packages calls an obscure command like

          (bless \"Text")->WidgetClass;

     This command (actually Tk::Widget::WidgetClass()) creates three
     routines: Tk::Widget::Text(), Tk::Widget::isText(), and
     Tk::Text::isText(). The first one is basically new of `Tk::Text',
     the other two return constants. It also puts the class into
     depository.

Inside `$top = MainWindow->new;'
     This is quite intuitive. This call goes direct to
     `Tk::MainWindow::new', that calls XSUB
     `Tk::MainWindow::CreateMainWindow', that calls C subroutine
     Tk_CreateMainWindow(). It is a `Tk' subroutine, so here black magic
     ends (almost).

     The only remaining black magic is that the `Tk' initialization
     routine creates a lot of commands, but the subroutine for creation
     is usurped by *portableTk* and the commands are created in the
     package `Tk'. They are associated to XSUBs that are related to one
     of three C subroutines XStoSubCmd(), XStoBind(), or XStoTk(), but
     have different data parts.

     The result of the call is blessed into `Tk::MainWindow', as it
     should.

Inside `$top->title('Text demo');'
     The package `Tk::Toplevel' defines a lot of subroutines on the fly
     on some list. All the commands from the list are converted to the
     corresponding subcommands of `wm' method of the widget. Here
     subcommand is a command with some particular second argument (in
     this case `"title"'). Recall that the first argument is $self.

     Now `Tk::Toplevel' @ISA `Tk::Widget', that in turn @ISA `Tk'. So a
     call to `$top->wm('title','Text demo')' calls `Tk::wm', that is
     defined during call to Tk_CreateMainWindow(). As it is described
     above, the XSUB associated to XStoSubCmd() is called.

     This C routine is defined in `tkGlue.c'. It gets the data part of
     XSUB, creates a `SV' with the name of the command, and calls
     Call_Tk() with the XSUB data as the first argument, and with the
     name of XSUB stuffed into the Perl stack in the place there `tk'
     expects it. (In fact it can also reorder the arguments if it thinks
     it is what you want).

     The latter procedure extracts name of `tk' procedure and
     `clientData' from the first argument and makes a call, using Perl
     stack as `argv' for the procedure. A lot of black magic is
     performed afterwards to convert result of the procedure to a Perl
     array return.

Inside `$text = $top->Text(background => $txtBg);'
     Above we discussed how the command `Tk::Widget::Text' is
     created. The above command calls it via inheritance. It is
     translated to

          Tk::Text::new($top, background => $txtBg);

     The package `Tk::Text' has no method new, so the `Tk::Widget::new'
     is called. In turn it calls `Tk::Text->DoInit($top)', that is
     `Tk::Widget::DoInit(Tk::Text,$top)', that initializes the bindings
     if necessary. Then it creates the name for the widget of the form
     `.text0', and calls `Tk::text('.text0', background => $txtBg)'
     (note lowercase). The result of the call is blessed into
     `Tk::Text', and the method `bindtags' for this object is called.

     Now the only thing to discuss is who defines the methods text and
     `bindtags'. The answer is that they are defined in `tkWindow.c',
     and these commands are created in the package `Tk' in the same
     sweep that created the command `Tk::wm' discussed above.

     So the the same C code that corresponds to the processing of
     corresponding TCL commands is called here as well (this time via
     `XStoTk' interface).

Inside `$text->insert('insert','Hello, world!');'
     As we discussed above, the subcommands of widget procedures
     correspond to XSUB `XStoWidget'. This XSUB substitutes the first
     argument $text (that is a hash reference) to an appropriate value
     from this hash, adds the additional argument after the first one
     that contains the name of the subcommand extracted from the data
     part of XSUB, and calls the corresponding Tk C subroutine via
     `Call_Tk'.

Ilya Zakharevich <ilya@math.ohio-state.edu>




File: pm.info, Node: Tk/LabFrame, Next: Tk/Menu/Item, Prev: Tk/Internals, Up: Module List

labeled frame.
**************



NAME
====

Tk::LabFrame - labeled frame.


SYNOPSIS
========

     use Tk::LabFrame;
     $f = $top->LabFrame(-label => "Something",
     			-labelside => 'acrosstop');


DESCRIPTION
===========

*LabFrame* is exactly like Frame except that it takes two
additional options:

*-label* The text of the label to be placed with the Frame.
*-labelside* Can be one of *left*, right, top, *bottom* or *acrosstop*. The first four work as might be expected and place the label to the left, right, above or below the frame respectively. The last one creates a grooved frame around the central frame and puts the label near the northwest corner such that it appears to "overwrite" the groove. Run the following test program to see this in action:
          use Tk;
          require Tk::LabFrame;
          require Tk::LabEntry;

          my $test = 'Test this';
          $top = MainWindow->new;
          my $f = $top->LabFrame(-label => "This is a label",
          			   -labelside => "acrosstop");
          $f->LabEntry(-label => "Testing", -textvariable => \$test)->pack;
          $f->pack;
          MainLoop;

          =back

          =head1 BUGS

     Perhaps *LabFrame* should be subsumed within the generic pTk
     labeled widget mechanism.
    
     =head1 AUTHOR

     *Rajappa Iyer* rsi@earthling.net

     This code is derived from LabFrame.tcl and LabWidg.tcl in the
     Tix4.0 distribution by Ioi Lam. The code may be redistributed under
     the same terms as Perl.
    
     =cut



File: pm.info, Node: Tk/Menu/Item, Next: Tk/NoteBook, Prev: Tk/LabFrame, Up: Module List

Base class for Menu items
*************************



NAME
====

Tk::Menu::Item - Base class for Menu items


SYNOPSIS
========

     require Tk::Menu::Item;

     my $but = $menu->Button(...);
     $but->configure(...);
     my $what = $but->cget();

     package Whatever;
     require Tk::Menu::Item;
     @ISA = qw(Tk::Menu::Item);

     sub PreInit
     {
      my ($class,$menu,$info) = @_;
      $info->{'-xxxxx'} = ...
      my $y = delete $info->{'-yyyy'};
     }


DESCRIPTION
===========

Tk::Menu::Item is the base class from which Tk::Menu::Button,
Tk::Menu::Cascade, Tk::Menu::Radiobutton and Tk::Menu::Checkbutton are
derived.  There is also a Tk::Menu::Separator.

Constructors are declared so that $menu->Button(...) etc. do what you
would expect.

The `-label' option is pre-processed allowing ~ to be prefixed to the
character to derive a `-underline' value. Thus

     $menu->Button(-label => 'Goto ~Home',...)

     is equivalent to 

     $menu->Button(-label => 'Goto Home', -underline => 6, ...)

`Cascade' accepts `-menuitems' which is a list of items for the
sub-menu.  Within this list (which is also accepted by Menu and
Menubutton) the first two elements of each item should be the
"constructor" name and the label:

     -menuitems => [
                    [Button      => '~Quit', -command => [destroy => $mw]],
                    [Checkbutton => '~Oil',  -variable => \$oil], 
                   ] 

Also `-tearoff' is propagated to the submenu, and `-menuvar' (if
present) is set to the created sub-menu.

The returned object is currently a blessed reference to an array of two
items: the containing Menu and the 'label'.  Methods `configure' and
`cget' are mapped onto underlying `entryconfigure' and `entrycget'.

The main purpose of the OO interface is to allow derived item classes to
be defined which pre-set the options used to create a more basic item.


BUGS
====

This OO interface is very new. Using the label as the "key" is a problem
for separaror items which don't have one. The alternative would be to
use an index into the menu but that is a problem if items are deleted
(or inserted other than at the end).

There should probably be a PostInit entry point too, or a more widget
like defered 'configure'.




File: pm.info, Node: Tk/NoteBook, Next: Tk/OlWm, Prev: Tk/Menu/Item, Up: Module List

display several windows in limited space with notebook metaphor.
****************************************************************



NAME
====

Tk::NoteBook - display several windows in limited space with notebook
metaphor.


SYNOPSIS
========

     use Tk::NoteBook;
     ...
     $w = $frame->NoteBook();
     $page1 = $w->add("page1", options);
     $page2 = $w->add("page2", options);
     ...


DESCRIPTION
===========

The NoteBook widget provides a notebook metaphor to display several
windows in limited space. The notebook is divided into a stack of pages
of which only one is displayed at any time. The other pages can be
selected by means of choosing the visual "tabs" at the top of the
widget. Additionally, the <Tab> key may be used to traverse the pages.
If *-underline* is used, Alt- bindings will also work.

The widget takes all the options that a Frame does. In addition, it
supports the following options:

*-dynamicgeometry*
     If set to false (default and recommended), the size of the NoteBook
     will match the size of the largest page. Otherwise the size will
     match the size of the current page causing the NoteBook to change
     size when different pages of different sizes are selected.

*-ipadx*
     The amount of internal horizontal padding around the pages.

*-ipady*
     The amount of internal vertical padding around the pages.


METHODS
=======

The following methods may be used with a NoteBook object in addition to
standard methods.

add(page, *options**)*
     Adds a page with name page to the notebook. Returns an object of
     type Frame. The recognized *options* are:

     *-anchor*
          Specifies how the information in a tab is to be
          displayed. Must be one of n, ne, *e*, *se*, s, *sw*, w, *nw*
          or center.

     *-bitmap*
          Specifies a bitmap to display on the tab of this page. The
          bitmap is displayed only if none of the *-label* or *-image*
          options are specified.

     *-image*
          Specifies an image to display on the tab of this page. The
          image is displayed only if the *-label* option is not
          specified.

     *-label*
          Specifies the text string to display on the tab of this page.

     *-justify*
          When there are multiple lines of text displayed in a tab, this
          option determines the justification of the lines.

     *-createcmd*
          Specifies a Perl command to be called the first time the page
          is shown on the screen. This option can be used to delay the
          creation of the contents of a page until necessary. It can be
          useful in situations where there are a large number of pages
          in a NoteBook widget; with *-createcmd* you do not have to
          make the user wait until all pages are constructed before
          displaying the first page.

     *-raisecmd*
          Specifies a Perl command to be called whenever this page is
          raised by the user.

     *-state*
          Specifies whether this page can be raised by the user. Must be
          either *normal* or *disabled*.

     *-underline*
          Specifies the integer index of a character to underline in the
          tab. This option is used by the default bindings to implement
          keyboard traversal for menu buttons and menu entries. 0
          corresponds to the first character of text displayed on the
          widget, 1 to the next character and so on.

     *-wraplength*
          This option specifies the maximum line length of the label
          string on this tab. If the line length of the label string
          exceeds this length, then it is wrapped onto the next line so
          that no line is longer than the specified length. The value
          may be specified in any standard forms for screen
          distances. If this value is less than or equal to 0, then no
          wrapping is done: lines will break only at newline characters
          in the text.

delete(page*)*
     Deletes the page identified by page.

*pagecget(*page, option*)*
     Returns the current value of the configuration otion given by
     option in the page given by page. Option may have any of the values
     accepted in the add method.

*pageconfigure(*page, *options**)*
     Like configure for the page indicated by page. *Options* may be any
     of the options accepted by the add method.

*raise(*page*)*
     Raise the page identified by page.

raised()
     Returns the name of the currently raised page.


AUTHOR
======

*Rajappa Iyer* rsi@earthling.net

This code and documentation was derived from NoteBook.tcl in Tix4.0
written by Ioi Lam. It may be distributed under the same conditions as
Perl itself.




File: pm.info, Node: Tk/OlWm, Next: Tk/Parse, Prev: Tk/NoteBook, Up: Module List

Interface to OpenLook properties of toplevel windows.
*****************************************************



NAME
====

Tk::OlWm - Interface to OpenLook properties of toplevel windows.


SYNOPSIS
========

     use Tk::OlWm;

     $toplevel->OL_DECOR( 
                          CLOSE  => flag,
                          FOOTER => flag,
                          HEADER => flag, 
                          RESIZE => flag, 
                          PIN => flag, 
                          ICON_NAME => flag, 
                        );

     $toplevel->OL_WIN_BUSY( flag );

     $toplevel->OL_PIN_STATE( flag );


DESCRIPTION
===========

I simple perl-only module that adds a few methods to Tk::Wm class.
These methods manipulate properties of the `$toplevel' to communicate
with an OpenLook window manager, e.g. Sun's `olwm' or `olvwm'.

In the synopsis above `flag' is a "boolean" value - i.e. an integer with
0 meaning false and other values meaning true.

All the *name => flag* pairs are optional.


STATUS
======

Works for me, it is in 'Contrib' because I cannot support something
which has been developed just by dumping properties of Sun applications
and guessing.


AUTHOR
======

Nick Ing-Simmons <nik@tiuk.ti.com>




File: pm.info, Node: Tk/Parse, Next: Tk/ROText, Prev: Tk/OlWm, Up: Module List

Parse perl's pod files.
***********************



NAME
====

Pod::Parse - Parse perl's pod files.


SYNOPSIS
========

*THIS TK SNAPSHOT SHOULD BE REPLACED BY A CPAN MODULE*


DESCRIPTION
===========

A module designed to simplify the job of parsing and formatting
``pods'', the documentation format used by perl5. This consists of
several different functions to present and modify predigested pod files.


GUESSES
=======

This is a work in progress, so I may have some stuff wrong, perhaps
badly.  Some of my more reaching guesses:

   * An =index paragraph should be split into lines, and each line
     placed inside an `X' formatting command which is then preprended to
     the next paragraph, like this:

          =index foo
          foo2
          foo3
          foo2!subfoo

          Foo!
 
          Will become:

          X<foo>X<foo2>X<foo3>X<foo2!subfoo>Foo!

   * A related change: that an `X' command is to be used for indexing
     data. This implies that all formatters need to at least ignore the
     `X' command.

   * Inside an =command, no special significance is to be placed on the
     first line of the argument. Thus the following two lines should be
     parsed identically:

          =item 1. ABC

          =item 1.
          ABC

     Note that neither of these are identical to this:

          =item 1.

          ABC

     which puts the "ABC" in a separate paragraph.

   * I actually violate this rule twice: in parsing =index commands, and
     in passing through the =pragma commands. I hope this make sense.

   * I added the =comment command, which simply ignores the next
     paragraph

   * I also added =pragma, which also ignores the next paragraph, but
     this time it gives the formatter a chance at doing something
     sinister with it.


POD CONVENTIONS
===============

This module has two goals: first, to simplify the usage of the pod
format, and secondly the codification of the pod format. While perlpod
contains some information, it hardly gives the entire story. Here I
present "the rules", or at least the rules as far as I've managed to
work them out.

Paragraphs: The basic element
     The fundamental "atom" of a pod file is the paragraph, where a
     paragraph is defined as the text up to the next completely blank
     line ("\n\n"). Any pod parser will read in paragraphs sequentially,
     deciding what do to with each based solely on the current state and
     on the text at the _beginning_ of the paragraph.

Commands: The method of communication
     A paragraph that starts with the `=' symbol is assumed to be a
     special command.  All of the alphanumeric characters directly after
     the `=' are assumed to be part of the name of the command, up to
     the first whitespace. Anything past that whitespace is considered
     "the arugment", and the argument continues up till the end of the
     paragraph, regardless of newlines or other whitespace.

Text: Commands that aren't Commands
     A paragraph that doesn't start with `=' is treated as either of two
     types of text. If it starts with a space or tab, it is considered a
     *verbatim* paragraph, which will be printed out... verbatim. No
     formatting changes whatsover may be done. (Actually, this isn't
     quite true, but I'll get back to that at a later date.)

     A paragraph that doesn't start with whitespace or `=' is assumed to
     consist of formmated text that can be molded as the formatter sees
     fit. Reformatting to fit margins, whatever, it's fair game. These
     paragraphs also can contain a number of different formatting codes,
     which verbatim paragraphs can't. These formatting codes are covered
     later.

=cut: The uncommand
     There is one command that needs special mention: =cut. Anything
     after a paragraph starting with =cut is simply ignored by the
     formatter. In addition, any text *before* a valid command is
     equally ignored. Any valid `=' command will reenable
     formating. This fact is used to great benefit by Perl, which is
     glad to ignore anything between an `=' command and `=cut', so you
     can embed a pod document right inside a perl program, and neither
     will bother the other.

Reference to paragraph commands
     =cut
          Ignore anything till the next paragraph starting with `='.

     =head1
          A top-level heading. Anything after the command (either on the
          same line or on further lines) is included in the heading, up
          until the end of the paragraph.

     =head2
          Secondary heading. Same as =head1, but different. No, there
          isn't a head3, head4, etc.

     =over [N]
          Start a list. The N is the number of characters to indent
          by. Not all formatters will listen to this, though. A good
          number to use is 4.

          While =over sounds like it should just be indentation, it's more complex then
          that. It actually starts a nested environment, specifically for the use of
          =item's. As this command recurses properly, you can use more then one, you
          just have to make sure they are closed off properly by =back
          commands.

     =back
          Ends the last =over block. Resets the indentation to whatever
          it was previously. Closes off the list of =item's.

     =item
          The point behind =over and =back. This command should only be
          used between them. The argument supplied should be consistent
          (within a list) to one of three types: enumeration,
          itemization, or description. To exemplify:

          An itemized list

               =over 4

               =item *

               A bulleted item

               =item *

               Another bulleted item
 
               =back

               An enumerated list

               =over 4

               =item 1.

               First item.

               =item 2.

               Second item.

               =back

               A described list

               =over 4

               =item Item #1

               First item

               =item Item #2 (which isn't really like #1, but is the second).

               Second item

               =back  


               If you aren't consistent about the arguments to =item, Pod::Parse will
               complain.

     =comment
          Ignore this paragraph

     =pragma
          Ignore this paragraph, as well, unless you know what you are
          doing.

     =index
          Undecided at this time, but probably magic involving X<>.

Reference to formatting directives
     ...
          Format text inside the brackets as bold.

     ...
          Format text inside the brackets as italics.

     @asis{}
     
          Replace with a zero-width character. You'll probably figure
          out some uses for this.

     And yet more that I haven't described yet...

USAGE
=====


Parse
-----

This function takes a list of files as an argument. If no argument is
given, it defaults to the contents of @ARGV. Parse then reads through
each file and returns the data as a list. Each element of this list will
be a nested list containing data from a paragraph of the pod
file. Elements pertaining to "=over" paragraphs will themselves contain
the nested entries for all of the paragraphs within that list. Thus,
it's easier to parse the output of Parse using a recursive parses. (Um,
did that parse?)

It is *highly* recommended that you use the output of Simplify, not
Parse, as it's simpler.

The output will consist of a list, where each element in the list
matches one of these prototypes:

[0,0,0,0,$filename]
     This is produced at the beginning of each file parsed, where
     $filename is the name of that file.

[-1,0,0,0,$filename]
     End of same.

[1,$line,$pos,0,$verbatim]
     This is produced for each paragraph of verbatim text. $verbatim is
     the text, $line is the line offset of the paragraph within the
     file, and $pos is the byte offset. (In all of the following
     elements, $pos and $line have identical meanings, so I'll skip
     explaining them each time.)

[2,$line,$pos,$level,$heading]
     Producded by a =head1 or =head2 command. $level is either 1 or 2,
     and $heading is the argument.

[3,$line,$pos,0,$item]
     $item is the argument from an =item paragraph.

[4,$line,$pos,0,$index]
     $index is the argument from an =index paragraph.

[6,$line,$pos,0,$text]
     Normal formatted text paragraph. $text is the text.

[7,$line,$pos,0,$pragma]
     $pragma is the argument from a =pragma paragraph.

[8,$line,$pos,$indentation,$type,...]
     This item is produced for each matching =over/=back
     pair. $indentation is the argument to =over, $type is 1 if the
     embedded =item's are bulleted, 2 if they are enumerated, 3 if they
     are text, and 0 if there are no items.

     The "..." indicates an unlimited number of further elements which
     are themselves nested arrays in exactly the format being
     described. In other words, a list item includes all the paragraphs
     inside the list inside itself. (Clear? No? Nevermind.)

[9,$line,$pos,0,$cut]
     $cut contains the text from a =cut paragraph. You shouldn't need to
     use this, but I _suppose_ it might be necessary to do special
     breaks on a cut. I doubt it though. This one is "depreciated", as
     Larry put it. Or perhaps disappreciated.


Simplify
--------

This procedure takes as it's input the convoluted output from Parse(),
and outputs a much simpler array consisting of pairs of commands and
arguments, designed to be easy (easier?) to parse in your pod formatting
code.

It is used very simply by saying something like:

     @Pod = Simplify(Parse());

     while($cmd = shift @Pod) { $arg = shift @Pod;
     	#...
     }

Where #... is the code that responds to any of the commands from the
following list. Note that you are welcome to ignore any of the commands
that you want to. Many contain duplicate information, or at least
information that will go unused. A formatted based on this data can be
quite simple indeed. (See pod2text for entirely too simple an example.)


Reference to Simplify commands
------------------------------

"filename"
     The argument contains the name of the pod file that is being
     parsed. These will be present at the start of each file. You should
     open an output file, output headers, etc., based on this, and not
     when you start parsing.

"endfile"
     The end of the file. Each file will be ended before the next one
     begins, and after all files are done with. You can do end
     processing here. The argument is the same name as in "filename".

"setline"
     This gives you a chance to record the "current" input line,
     probably for debugging purposes. In this case, "current" means that
     the next command you see that was derived from an input paragraph
     will have start at the arguments line in the file.

"setloc"
     Same as setline, but the byte offset in the input, instead of the
     line offset.

"pragma"
     The argument contains the text of a pragma command.

"text"
     The argument contains a paragraph of formatted text.

"verbatim"
     The argument contains a paragraph of verbatim text.

"cut"
     A =cut command was hit. You shouldn't really need to listen for
     this one.

"index"
     The argument contains an =index paragraph. (Note: Current =index
     commands are not fed through, but turned into X<> commands.)

"head1"
"head2"
     The argument contains the argument from a header command.

"setindent"
     If you are tracking indentation, use the argument to set the
     indentation level.

"listbegin"
     Start a list environment. The argument is the type of list (1,2,3
     or 0).

"listend"
     Ends a list environment. Same argument as listbegin.

"listtype"
     The argument is the type of list. You can just record the argument
     when you see one of these, instead of paying attention to listbegin
     & listend.

"over"
     The argument is the indentation. It's probably better to listen to
     the "list..." commands.

"back"
     Ends an "over" list. The argument is the original indentation.

"item"
     The argument is the text of the =item command.

Note that all of these various commands you've seen are syncronized
properly so you don't have to pay attention to all at once, but they are
all output for your benefit. Consider the following example:

     listtype 2
     listbegin 2
     setindent 4
     over 4
     item 1.
     text Item #1
     item 2.
     text Item #2
     setindent 0
     listend 2
     back 0
     listtype 0

     =head2 Normalize

This command is normally invoked by Parse, so you shouldn't need to deal
with it. It just cleans up text a little, turning spare '<', '>', and
'&' characters into HTML escapes (<, etc.) as well as generating
warnings for some pod formatting mistakes.


Normalize2
----------

A little more aggresive formating based on heuristics. Not applied by
default, as it might confuse your own heuristics.


%Escapes
--------

This hash is exported from Pod::Parse, and contains default ASCII
translations for some common HTML escape sequences. You might like to
use this as a basis for an %HTML_Escapes array in your own formatter.




File: pm.info, Node: Tk/ROText, Next: Tk/Scrolled, Prev: Tk/Parse, Up: Module List

'readonly' perl/tk Text widget
******************************



NAME
====

Tk::ROText - 'readonly' perl/tk Text widget


SYNOPSIS
========

     use Tk::ROText;
     ...
     $ro = $mw->ROText(?options,...?);


DESCRIPTION
===========

This IS-A text widget with all bindings removed that would alter the
contents of the text widget.


KEYS
====

widget, text, readonly


SEE ALSO
========

Tk::Text(3)




File: pm.info, Node: Tk/Scrolled, Next: Tk/SelFile, Prev: Tk/ROText, Up: Module List

Create a widget with attached scrollbar(s)
******************************************



NAME
====

Tk::Scrolled - Create a widget with attached scrollbar(s)


SYNOPSIS
========

     $whatever = $parent->Scrolled('Whatever',
     				-scrollbars = 'nw',
     				... widget options of Whatever here...
     				);


DESCRIPTION
===========

To stop a flood of *ScrlWhatever* Perl/Tk introcuded the special constructor
*Scrolled*.  *Scrolled* creates a widget of the given Class 'Whatever' with
attached `scrollbar' in this node(s).


OPTIONS
=======

-scrollbars
     Expects as argument the position where the scrollbars should be
     created.  `'w'', `'e'' or `'n'', `'s'' or a combination of them.
     If the one or both positions are prefixed with `'o'' the scrollbar
     will only show up if there is a 'real' need to scroll.

all other option
     All options beside <-scrollbars> are passed to the 'Whatever'
     widget constructor.


BUGS
====

If a widget does not support `-{x,y}scrollcommand' options,
*Scrolled* does not complain if the specified widget class does
not support them. E.g.,

     $parent->Scrolled('Button', ...)

One does not get an error message or warning when one tries to configure
scrollbars after the widget construction:

     $ascrolled->scrollbars('e')
     $ascrolled->configure(-scrollbars => 'e');


SEE ALSO
========

Scrollbar, Tk::Widget.pm(sub Scrollbars), Tk::Frame.pm(sub
AddScrollbars)




File: pm.info, Node: Tk/SelFile, Next: Tk/Submethods, Prev: Tk/Scrolled, Up: Module List

a widget for choosing a file to read or write
*********************************************



NAME
====

     SelFile - a widget for choosing a file to read or write


SYNOPSIS
========

     use Tk;
     use Tk::SelFile;

     $mw = MainWindow->new;  # As an example.

     $start_dir = ".";       # As an example.
     $sfw = $mw->SelFile(
     		     -directory => $start_dir,
     		     -width     =>  30,
     		     -height    =>  20,
     		     -filelistlabel  => 'Files',
     		     -filter         => '*',
     		     -filelabel      => 'File',
     		     -dirlistlabel   => 'Directories',
     		     -dirlabel       => 'Filter',
     		     -readbutlabel   => 'Read',
     		     -writebutlabel  => 'Write',
     		     -cancelbutlabel => 'Cancel',
     		     );
     Please see the Populate subroutine as the configuration
     list may change.

     ($opcode, $filename) = $sfw->Show;

     $opcode will have the value -readbutlabel (e.g. 'READ'),
     -writebutlabel (e.g. 'WRITE') or -cancelbutlabel (e.g. 'CANCEL').
     An empty string for the text assigned to -readbutlabel or
     -writebutlabel will eliminate that particular button.
     $filename will be a file pathname, or in the case of CANCEL
     it will be a single space character.

     $SFref = $sfw->configure(option => value[, ...])


DESCRIPTION
===========

     This Module pops up a file selector box, with a directory entry
     with filter on top, a list of directories in the current directory,
     a list of files in the current directory, an entry for entering
     or modifying a file name, a read button, a write button, a
     cancel button, a HOME button, and a button to return to the
     starting directory (-directory).

     The button to return to the starting directory is motivated by
     the idea that an application may have a directory unrelated to
     the home directory, e.g. a library of data, that is set to be
     the starting directory.  If the user goes to the home directory,
     the user may not recall the starting directory that was set by
     the application.

     A call to SelFile few (or no options, such as shown below)
     will result in the default values shown in the example
     given in the SYNOPSIS section.  The most uptodate list of
     configuration variables and default values can be found in the
     subroutine Populate as arguments to the subroutine ConfigSpecs.

     $sfw = $mw->SelFile;

     A dialog box error message is generated if the user clicks the
     Read button for a file that does not exist.
     For Write, a dialog box that requests whether the user wishes
     to overwrite the file is generated for a file that already exists.
     Also for Write, a dialog box error message is generated is the
     file name is blank.

     This widget can be configured for requesting a file name to read,
     requesting a file name for writing, or for requesting either.
     For the initial call to SelFile that configures the widget,
     if -readbutlabel is not a member of the argument list, then
     the default value is used (i.e. Read).  If on the other hand
     it is present but specifies an empty string, as shown below
     -readbutlabel   => '',
     then the button is not created.  An analogous rule applies
     to the argument -writebutlabel.

     The file name output is a single space character rather than undef
     when CANCEL is selected so that the user can process the return values
     without checking the values, e.g. storing the result for later use.


AUTHORS
=======

Based on original FileSelect by Klaus Lichtenwalder,
Lichtenwalder@ACM.org, Datapat GmbH, Munich, April 22, 1995 adapted by
Frederick L. Wagner, derf@ti.com, Texas Instruments Incorporated,
Dallas, 21Jun95 further adapted by Alan Louis Scheinine,
scheinin@crs4.it, Centro di Ricerca, Sviluppo e Studi Superiori in
Sardegna (CRS4) Cagliari, 14 November 1995


HISTORY
=======

Alan Scheinine wants to thank David Greaves (davidg@oak.reading.sgi.com)
for pointing out errors and for suggesting improvements.  He also wants
to thank Nick Ing-Simmons (nik@tiuk.ti.com) for sending the soon-to-be
FileSelect for Tk-b9.  This SelFile program diverges from SelectFile
with regard to style but nonetheless has benefited from the ideas and
actual code of SelectFile.

Future history.  For Tk-b9, "show" and "subwidget" should become "Show"
and "Subwidget" Change $cw->subwidget('dialog')->show; Tk-b8 to
$cw->Subwidget('dialog')->Show; Tk-b9




File: pm.info, Node: Tk/Submethods, Next: Tk/Table, Prev: Tk/SelFile, Up: Module List

add aliases for tk sub-commands
*******************************



NAME
====

Tk::Submethods - add aliases for tk sub-commands


SYNOPSIS
========

     use Tk::Submethods ( 'command1' => [qw(sub1 sub2 sub3)],
                          'command2' => [qw(sub1 sub2 sub3)]);  


DESCRIPTION
===========

Creates `->commandSub(...)' as an alias for `->command('sub',...)'
e.g. `->grabRelease' for `->grab('release')'.

For each command/subcommand pair this creates a closure with command and
subcommand as bound lexical variables and assigns a reference to this to
a 'glob' in the callers package.

Someday the sub-commands may be created directly in the C code.




File: pm.info, Node: Tk/Table, Next: Tk/TextUndo, Prev: Tk/Submethods, Up: Module List

Scrollable 2 dimensional table of Tk widgets
********************************************



NAME
====

Tk::Table - Scrollable 2 dimensional table of Tk widgets


SYNOPSIS
========

     use Tk::Table;

     $table = $parent->Table(-rows => number,
                             -columns => number,
                             -scrollbars => anchor,
                             -fixedrows => number,
                             -fixedcolumns => number,
                             -takefocus => boolean);

     $widget = $table->Button(...);

     $old = $table->put($row,$col,$widget);
     $old = $table->put($row,$col,"Text");  # simple Label 
     $widget = $table->get($row,$col);

     $cols = $table->totalColumns;
     $rows = $table->totalRows;

     $table->see($widget);
     $table->see($row,$col);

     ($row,$col) = $table->Posn($widget);


DESCRIPTION
===========

Tk::Table is an all-perl widget/geometry manager which allows a two
dimensional table of arbitary perl/Tk widgets to be displayed.

Entries in the Table are simply ordinary perl/Tk widgets. They should be
created with the Table as their parent. Widgets are positioned in the
table using:

     $table->put($row,$col,$widget)

All the widgets in each column are set to the same width - the requested
width of the widest widget in the column.  Likewise, all the widgets in
each row are set to the same height - the requested height of the
tallest widget in the column.

A number of rows and/or columns can be marked as 'fixed' - and so can
serve as 'headings' for the remainder the rows which are scrollable.

The requested size of the table as a whole is such that the number of
rows specified by -rows (default 10), and number of columns specified by
-columns (default 10) can be displayed.

If the Table is told it can take the keyboard focus then cursor and
scroll keys scroll the displayed widgets.

The Table will create and manage its own scrollbars if requested via 
-scrollbars.

The Tk::Table widget is derived from a Tk::Frame, so inherits all its
configure options.


BUGS / Snags / Possible enhancements
====================================

   * Very large Tables consume a lot of X windows

   * No equivalent of pack's -anchor/-pad etc. options




File: pm.info, Node: Tk/TextUndo, Next: Tk/TiedListbox, Prev: Tk/Table, Up: Module List

perl/tk text widget with bindings to undo changes.
**************************************************



NAME
====

Tk::TextUndo - perl/tk text widget with bindings to undo changes.


SYNOPSIS
========

     use Tk::TextUndo;
     ...
     $testundo = $parent->TextUndo(?option => value, ...?);
     ...


DESCRIPTION
===========

This IS-A text widget with an unlimited 'undo' history but without a
re'undo' capability.


Bindings
--------

The `TextUndo' widget has the same bindings as the `Text' in this node
widget.  Additionally to the `Text' in this node widget there are the
following bindings:

Event <L4>
     undo the last change.  Pressing <L4> several times undo step by
     step the changes made to the text widget.


Methods
-------

The `TextUndo' widget has the same methods as Text widget.  Additional
method for the `TextUndo' widget are:

$text->Load($filename);
     Loads the contents of the $filename into the text widget. Load()
     delete the previous contents of the text widget as well as it's
     undo history of the previous file.

$text->Save(?$otherfilename?)
     Save contents of the text widget to a file. If the $otherfilename
     is not specified, the text widget contents writes the file of
     $filename used in the last Load() call.  If no file was previously
     Load()'ed an error message pops up.  The default filename of the
     last Load() call is not overwriten by $otherfilename.


KEYS
====

widget, text, undo


SEE ALSO
========

Tk::Text(3), Tk::ROText(3)




File: pm.info, Node: Tk/TiedListbox, Next: Tk/Tk/Cloth, Prev: Tk/TextUndo, Up: Module List

gang together Listboxes
***********************



NAME
====

Tk::TiedListbox - gang together Listboxes


SYNOPSIS
========

     use Tk::TiedListbox

     $l1 = $mw->Listbox(-exportselection => 0,...);
     $l2 = $mw->Listbox(-exportselection => 0,...);
     $l3 = $mw->Listbox(-exportselection => 0,...);
     $l1->tie([$l2,$l3]);


DESCRIPTION
===========

TiedListbox causes two or more Listboxes to be operated in tandem.  One
application is emulating multi-column listboxes. The scrolling,
selection, or both mechanisms may be tied together. The methods tie and
untie are provided, along with overridden versions of some of the
Listbox methods to provide tandem operation.

Scrollbars are fully supported. You can use either explicitly created
Scrollbars, the *ScrlListbox* widget, or the *Scrolled*
super-widget. Tricks to "attach" multiple tied listboxes to a single
scrollbar are unnecessary and will lead to multiple calls of the listbox
methods (a bad thing).

The configuration options, geometry, and items of the Listboxes are not
altered by tying them. The programmer will have to make sure that the
setup of the Listboxes make sense together. Here are some (unenforced)
guidelines:

For listboxes with tied selection:
  set *-exportselection* to 0 for all but possibly one Listbox
  use identical *-selectmode* for all Listboxes
  if items are added/deleted, they should be done all at once and
    at the same index, or the selection should be cleared
  Listboxes should have the same number of items For listboxes with tied
scrolling:
  use the same window height and font for all Listboxes
  Listboxes should have the same number of items


METHODS
=======

*$listbox*->tie?(?option?, [*listbox*,...])?
     Ties together *$listbox* and the list of Listboxes with the given
     option. Returns *$listbox*.

     If no arguments are given, returns a list containing two items: the
     tie option ("scroll", "selection", or "all") and the list of
     Listboxes that *$listbox* is tied to.

     option can be one of "scroll", "selection", or "all".  If omitted,
     "all" is assumed. "scroll" makes the tied Listboxes to scroll
     together, "selection" makes selections to occur simultaneously in
     all tied Listboxes, and "all" effects both actions.

     All the Listboxes are untied (if previously tied) before being tied
     to each other; hence a Listbox can only be in one "tie group" at a
     time. "Tiedness" is commutative.

     The tie method can be called with either Listbox or TiedListbox
     objects. All listbox objects specified are reblessed to TiedListbox
     objects.

     Code such as below can be used to tie ScrlListboxes:

          $slb1=ScrlListbox(...); # or Scrolled('Listbox',...
          $slb2=ScrlListbox(...); # or Scrolled('Listbox',...
          $slb1->tie([$slb2->Subwidget('scrolled')]);

*$listbox*->*untie()*
     This function unties the Listbox from its "tie group". The other
     items in the "tie group" (if more than one) remain tied to each
     other.

     Returns a list containing two items: the old tie option ("scroll",
     "selection", or "all") and the list of Listboxes that *$listbox*
     was tied to.


OVERRIDDEN METHODS
==================

You probably don't care about these. They are just details to tie
together the behaviors of the listboxes.

All overriden methods take identical arguments as the corresponding
Listbox methods (see the Listbox documentation for a full
description). All overridden methods that take an index interpret that
index in the context of the listbox object provided.

*$listbox*->*activate*(...) =item *$listbox*->*selection*(...)
     To allow tied selection, these functions are overridden for
     listboxes tied together with the "selection" or "all" option. When
     an item is selected or activated in one listbox, the items with the
     same index (if present) are selected or activated in all tied
     listboxes.

     The *selection*('includes',...) submethod returns only information
     about the given *$listbox*.

*$listbox*->*scan*(...) =item *$listbox*->*see*(...) =item *$listbox*->*yview*(...)
     To allow tied scrolling, these functions are overridden for
     listboxes tied together with the "scroll" or "all" option. When one
     listbox is scrolled, all the other tied listboxes are scrolled by
     the same number of items (if possible). An attempt is made to keep
     items of the same index at the top of each tied listbox, while not
     interfering with the normal scrolling operations.

     The *yview* method with no arguments returns only information about
     the given *$listbox*.

     Horizontal scrolling (via *xview*) is not tied.


BUGS
====

Reblessing the widgets to TiedListbox might be too weird. It will
disable any additional features for widgets in a class derived from
Listbox (none yet that I know of).

The bindtags for reblessed widgets aren't updated. This is probably
wouldn't be a good thing to do automatically anyway.


AUTHOR
======

*Andrew Allen* ada@fc.hp.com

This code may be distributed under the same conditions as Perl.




File: pm.info, Node: Tk/Tk/Cloth, Next: Tk/Tk/NumEntry, Prev: Tk/TiedListbox, Up: Module List

An OO Tk Canvas
***************



NAME
====

Tk::Cloth - An OO Tk Canvas


SYNOPSIS
========

     use Tk::Cloth;

     $cloth = $parent->Cloth;
     $cloth->pack(-fill => 'both', -expand => 1);

     $rect = $cloth->Rectangle(
     	-coords => [ 0,0,100,100],
     	-fill => 'red'
     );

     $tag = $cloth->tag;
     $tag->Line(
     	-coords => [10,10,100,100],
     	-foreground => 'black'
     );
     $tag->Line(
     	-coords => [50,50,100,100],
     	-foreground => 'black'
     );
     $tag->move(30,30);

     $tag->bind("<1>", [ &button1 ]);


DESCRIPTION
===========

`Tk::Cloth' provides an object-orientated approach to a canvas and
canvas items.


AUTHOR
======

Graham Barr <`gbarr@ti.com'>


COPYRIGHT
=========

Copyright (c) 1997 Graham Barr. All rights reserved.  This program is
free software; you can redistribute it and/or modify it under the same
terms as Perl itself.




File: pm.info, Node: Tk/Tk/NumEntry, Next: Tk/Tk/Pane, Prev: Tk/Tk/Cloth, Up: Module List

A numeric entry widget
**********************



NAME
====

Tk::NumEntry - A numeric entry widget


SYNOPSIS
========

     use Tk::NumEntry;


DESCRIPTION
===========

`Tk::NumEntry' defines a widget for entering integer numbers. The widget
also contains butons for increment and decrement.

`Tk::NumEntry' supports all the options and methods that a normal Entry
widget provides, plus the following options


STANDARD OPTIONS
================

*-repeatdelay -repeatinterval*


WIDGET-SPECIFIC OPTIONS
=======================

-minvalue
     Defines the minimum legal value that the widget can hold. If this
     value is undef then there is no minimum value (default = undef)

-maxvalue
     Defines the maximum legal value that the widget can hold. If this
     value is undef then there is no maximum value (default = undef)

-bell
     Specifies a boolean value. If true then a bell will ring if the
     user attempts to enter an illegal character into the entry widget,
     and when the user reaches the upper or lower limits when using the
     up/down buttons for keys.

-value
     Specifies the value to be inserted into the entry widget. Similar
     to the standard `-text' option, but will perform a range check on
     the value.


AUTHOR
======

Graham Barr <`gbarr@ti.com'>


ACKNOWLEDGEMENTS
================

I would to thank Achim Bohnet <`ach@mpe.mpg.de'> for all the feedback
and testing.


COPYRIGHT
=========

Copyright (c) 1997 Graham Barr. All rights reserved.  This program is
free software; you can redistribute it and/or modify it under the same
terms as Perl itself.




