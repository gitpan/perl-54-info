Info file: pm.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `bigpm.texi'
using `texinfmt.el' version 2.32 of 19 November 1993.





File: pm.info, Node: URI/Escape, Next: URI/URL, Prev: UNIVERSAL, Up: Module List

Escape unsafe characters
************************



NAME
====

uri_escape - Escape unsafe characters

uri_unescape - Unescape escaped characters


SYNOPSIS
========

     use URI::Escape;
     $safe = uri_escape("10% is enough\n");
     $verysafe = uri_escape("foo", "\0-\377");
     $str  = uri_unescape($safe);


DESCRIPTION
===========

This module provide functions to escape and unescape URI strings.  Some
characters are regarded as "unsafe" and must be escaped in accordance
with RFC 1738.  Escaped characters are represented by a triplet
consisting of the character "%" followed by two hexadecimal digits.

The uri_escape() function takes an optional second argument that
overrides the set of characters that are to be escaped.  The set is
specified as a string that can be used in a regular expression character
class (between [ ]).  E.g.:

     \x00-\x1f\x7f-\xff          # all control and hi-bit characters
     a-z                         # all lower case characters
     ^A-Za-z                     # everything not a letter

The default set of characters to be escaped is:

     \x00-\x20"#%;<>?{}|\\\\^~`\[\]\x7F-\xFF

The module can also export the %escapes hash which contains the mapping
from all characters to the corresponding escape code.


SEE ALSO
========

*Note URI/URL: URI/URL,




File: pm.info, Node: URI/URL, Next: Unicode/CharName, Prev: URI/Escape, Up: Module List

Uniform Resource Locators (absolute and relative)
*************************************************



NAME
====

URI::URL - Uniform Resource Locators (absolute and relative)


SYNOPSIS
========

     use URI::URL;

     # Constructors
     $url1 = new URI::URL 'http://www.perl.com/%7Euser/gisle.gif';
     $url2 = new URI::URL 'gisle.gif', 'http://www.com/%7Euser';
     $url3 = url 'http://www.sn.no/'; # handy constructor
     $url4 = $url2->abs;       # get absolute url using base
     $url5 = $url2->abs('http:/other/path');
     $url6 = newlocal URI::URL 'test';

     # Stringify URL
     $str1 = $url->as_string;  # complete escaped URL string
     $str2 = $url->full_path;  # escaped path+params+query
     $str3 = "$url";           # use operator overloading

     # Retrieving Generic-RL components:
     $scheme   = $url->scheme;
     $netloc   = $url->netloc; # see user,password,host,port below
     $path     = $url->path;
     $params   = $url->params;
     $query    = $url->query;
     $frag     = $url->frag;

     # Accessing elements in their escaped form
     $path     = $url->epath;
     $params   = $url->eparams;
     $query    = $url->equery;

     # Retrieving Network location (netloc) components:
     $user     = $url->user;
     $password = $url->password;
     $host     = $url->host;
     $port     = $url->port;   # returns default if not defined

     # Retrieve escaped path components as an array
     @path     = $url->path_components;

     # HTTP query-string access methods
     @keywords = $url->keywords;
     @form     = $url->query_form;

     # All methods above can set the field values, e.g:
     $url->scheme('http');
     $url->host('www.w3.org');
     $url->port($url->default_port);
     $url->base($url5);                      # use string or object
     $url->keywords(qw(dog bones));

     # File methods
     $url = new URI::URL "file:/foo/bar";
     open(F, $url->local_path) or die;

     # Compare URLs
     if ($url->eq("http://www.sn.no")) or die;


DESCRIPTION
===========

This module implements the URI::URL class representing Uniform Resource
Locators (URL). URLs provide a compact string representation for
resources available via the Internet. Both absolute (RFC 1738) and
relative (RFC 1808) URLs are supported.

URI::URL objects are created by calling new(), which takes as argument a
string representation of the URL or an existing URL object reference to
be cloned. Specific individual elements can then be accessed via the
scheme(), user(), password(), host(), port(), path(), params(), query()
and frag() methods.  In addition escaped versions of the path, params
and query can be accessed with the epath(), eparams() and equery()
methods.  Note that some URL schemes will support all these methods.

The object constructor new() must be able to determine the scheme for
the URL.  If a scheme is not specified in the URL itself, it will use
the scheme specified by the base URL. If no base URL scheme is defined
then new() will croak if URI::URL::strict(1) has been invoked, otherwise
*http* is silently assumed.  Once the scheme has been determined new()
then uses the implementor() function to determine which class implements
that scheme.  If no implementor class is defined for the scheme then
new() will croak if URI::URL::strict(1) has been invoked, otherwise the
internal generic URL class is assumed.

Internally defined schemes are implemented by the
URI::URL::*scheme_name* module.  The URI::URL::implementor() function
can be used to explicitly set the class used to implement a scheme if
you want to override this.


HOW AND WHEN TO ESCAPE
======================

This is an edited extract from a URI specification:
     The printability requirement has been met by specifying a safe set
     of characters, and a general escaping scheme for encoding "unsafe"
     characters. This "safe" set is suitable, for example, for use in
     electronic mail.  This is the canonical form of a URI.

     There is a conflict between the need to be able to represent many
     characters including spaces within a URI directly, and the need to
     be able to use a URI in environments which have limited character
     sets or in which certain characters are prone to corruption. This
     conflict has been resolved by use of an hexadecimal escaping method
     which may be applied to any characters forbidden in a given
     context. When URLs are moved between contexts, the set of
     characters escaped may be enlarged or reduced unambiguously.  The
     canonical form for URIs has all white spaces encoded.

Notes:
     A URL string *must*, by definition, consist of escaped
     components. Complete URLs are always escaped.

     The components of a URL string must be *individually* escaped.
     Each component of a URL may have a separate requirements regarding
     what must be escaped, and those requirements are also dependent on
     the URL scheme.

     Never escape an already escaped component string.

This implementation expects an escaped URL string to be passed to new()
and will return a fully escaped URL string from as_string() and
full_path().

Individual components can be manipulated in unescaped or escaped
form. The following methods return/accept unescaped strings:

     scheme                  path
     user                    params
     password                query
     host                    frag
     port

The following methods return/accept partial *escaped* strings:

     netloc                  eparams
     epath                   equery

*Partial escaped* means that only reserved characters
(i.e. ':', '@', '/', ';', '?', '=', '&' in addition to '%', '.' and '#')
needs to be escaped when they are to be treated as normal characters.
*Fully escaped* means that all unsafe characters are escaped. Unsafe
characters are all all control characters (%00-%1F and %7F), all 8-bit
characters (%80-%FF) as well as '{', '}', '|', '\', '^', '[', ']' '`',
'"', '<' and '>'.  Note that the character '~' is *not* considered
unsafe by this library as it is common practice to use it to reference
personal home pages, but it is still unsafe according to RFC 1738.


ADDING NEW URL SCHEMES
======================

New URL schemes or alternative implementations for existing schemes can
be added to your own code. To create a new scheme class use code like:

     package MYURL::foo;
     @ISA = (URI::URL::implementor());   # inherit from generic scheme

The 'URI::URL::implementor()' function call with no parameters returns
the name of the class which implements the generic URL scheme behaviour
(typically `URI::URL::_generic'). All hierarchical schemes should be
derived from this class.

Your class can then define overriding methods (e.g., new(), _parse() as
required).

To register your new class as the implementor for a specific scheme use
code like:

     URI::URL::implementor('x-foo', 'MYURL::foo');

Any new URL created for scheme 'x-foo' will be implemented by your
`MYURL::foo' class. Existing URLs will not be affected.


FUNCTIONS
=========

new URI::URL $url_string [, $base_url]
     This is the object constructor.  It will create a new URI::URL
     object, initialized from the URL string.  To trap bad or unknown
     URL schemes use:

          $obj = eval { new URI::URL "snews:comp.lang.perl.misc" };

     or set URI::URL::strict(0) if you do not care about bad or unknown
     schemes.

newlocal URI::URL $path;
     Returns an URL object that denotes a path within the local
     filesystem.  Paths not starting with '/' are interpreted relative
     to the current working directory.  This constructor always return
     an absolute 'file' URL.

url($url_string, [, $base_url])
     Alternative constructor function.  The url() function is exported
     by the URI::URL module and is easier both to type and read than
     calling URI::URL->new directly.  Useful for constructs like this:

          $h = url($str)->host;

     This function is just a wrapper for URI::URL->new.

URI::URL::strict($bool)
     If strict is true then we croak on errors.  The function returns
     the previous value.

URI::URL::implementor([$scheme, [$class]])
     Use this function to get or set implementor class for a scheme.
     Returns '' if specified scheme is not supported.  Returns generic
     URL class if no scheme specified.


METHODS
=======

This section describes the methods available for an URI::URL object.
Note that some URL schemes will disallow some of these methods and will
croak if they are used.  Some URL schemes add additional methods that
are described in the sections to follow.

Attribute access methods marked with (*) can take an optional argument
to set the value of the attribute, and they always return the old value.

$url->abs([$base, [$allow_scheme_in_relative_urls]])
     The abs() method attempts to return a new absolute URI::URL object
     for a given URL.  In order to convert a relative URL into an
     absolute one, a *base* URL is required. You can associate a default
     base with a URL either by passing a *base* to the new() constructor
     when a URI::URL is created or using the base() method on the object
     later.  Alternatively you can specify a one-off base as a parameter
     to the abs() method.

     Some older parsers used to allow the scheme name to be present in
     the relative URL if it was the same as the base URL scheme.
     RFC1808 says that this should be avoided, but you can enable this
     old behaviour by passing a TRUE value as the second argument to the
     abs() method.  The difference is demonstrated by the following
     examples:

          url("http:foo")->abs("http://host/a/b")     ==>  "http:foo"
          url("http:foo")->abs("http://host/a/b", 1)  ==>  "http:/host/a/foo"

     The rel() method will do the opposite transformation.

$url->as_string
     Returns a string representing the URL in its canonical form.  All
     unsafe characters will be escaped.  This method is overloaded as
     the perl "stringify" operator, which means that URLs can be used as
     strings in many contexts.

$url->base (*)
     Get/set the base URL associated with the current URI::URL object.
     The base URL matters when you call the abs() method.

$url->clone
     Returns a copy of the current URI::URL object.

$url->crack
     Return a 9 element array with the following content:

          0: $url->scheme *)
          1: $url->user
          2: $url->password
          3: $url->host
          4: $url->port
          5: $url->epath
          6: $url->eparams
          7: $url->equery
          8: $url->frag

     All elements except *scheme* will be undefined if the corresponding
     URL part is not available.

     *Note:* The scheme (first element) returned by crack will aways be
     defined.  This is different from what the $url->scheme returns,
     since it will return undef for relative URLs.

$url->default_port
     Returns the default port number for the URL scheme that the
     URI::URL belongs too.

$url->eparams (*)
     Get/set the URL parameters in escaped form.

$url->epath (*)
     Get/set the URL path in escaped form.

$url->eq($other_url)
     Compare two URLs to decide if they match or not.  The rules for how
     comparison is made varies for different parts of the URLs; scheme
     and netloc comparison is case-insensitive, and escaped chars match
     their %XX encoding unless they are "reserved" or "unsafe".

$url->equery (*)
     Get/set the URL query string in escaped form.

$url->full_path
     Returns the string "/path;params?query".  This is the string that
     is passed to a remote server in order to access the document.

$url->frag (*)
     Get/set the fragment (unescaped)

$url->host (*)
     Get/set the host (unescaped)

$url->netloc (*)
     Get/set the network location in escaped form.  Setting the network
     location will affect 'user', 'password', 'host' and 'port'.

$url->params (*)
     Get/set the URL parameters (unescaped)

$url->password (*)
     Get/set the password (unescaped)

$url->path (*)
     Get/set the path (unescaped).  This method will croak if any of the
     path components in the return value contain the "/" character.  You
     should use the epath() method to be safe.

$url->path_components (*)
     Get/set the path using a list of unescaped path components.  The
     return value will loose the distinction beween '.' and '%2E'.  When
     setting a value, a '.' is converted to be a literal '.' and is
     therefore encoded as '%2E'.

$url->port (*)
     Get/set the network port (unescaped)

$url->rel([$base])
     Return a relative URL if possible.  This is the opposite of what
     the abs() method does.  For instance:

          url("http://www.math.uio.no/doc/mail/top.html",
              "http://www.math.uio.no/doc/linux/")->rel

     will return a relative URL with path set to "../mail/top.html" and
     with the same base as the original URL.

     If the original URL already is relative or the scheme or netloc
     does not match the base, then a copy of the original URL is
     returned.

@asis{}
     
     Prints a verbose presentation of the contents of the URL object to
     the specified file handle (default STDOUT).  Mainly useful for
     debugging.

$url->scheme (*)
     Get/set the scheme for the URL.

$url->query (*)
     Get/set the query string (unescaped).  This method will croak if
     the string returned contains both '+' and '%2B' or '=' together
     with '%3D' or '%26'.  You should use the equery() method to be
     safe.

$url->user (*)
     Get/set the URL user name (unescaped)


HTTP METHODS
============

For *http* URLs you may also access the query string using the
keywords() and the query_form() methods.  Both will croak if the query
is not of the correct format.  The encodings look like this:

     word1+word2+word3..        # keywords
     key1=val1&key2=val2...     # query_form

Note: These functions does not return the old value when they are used
to set a value of the query string.

$url->keywords (*)
     The keywords() method returns a list of unescaped strings.  The
     method can also be used to set the query string by passing in the
     keywords as individual arguments to the method.

$url->query_form (*)
     The query_form() method return a list of unescaped key/value pairs.
     If you assign the return value to a hash you might loose some
     values if the key is repeated (which it is allowed to do).

     This method can also be used to set the query sting of the URL like
     this:

          $url->query_form(foo => 'bar', foo => 'baz', equal => '=');

     If the value part of a key/value pair is a reference to an array,
     then it will be converted to separate key/value pairs for each
     value.  This means that these two calls are equal:

          $url->query_form(foo => 'bar', foo => 'baz');
          $url->query_form(foo => ['bar', 'baz']);


FILE METHODS
============

The *file* URLs implement the local_path() method that returns a path
suitable for access to files within the current filesystem.  These
methods can *not* be used to set the path of the URL.

$url->local_path
     This method is really just an alias for one of the methods below
     depending on what system you run on.

$url->unix_path
     Returns a path suitable for use on a Unix system.  This method will
     croak if any of the path segments contains a "/" or a NULL
     character.

$url->dos_path
     Returns a path suitable for use on a MS-DOS or MS-Windows system.

$url->mac_path
     Returns a path suitable for use on a Macintosh system.

$url->vms_path
     Returns a path suitable for use on a VMS system.  VMS is a
     trademark of Digital.


GOPHER METHODS
==============

The methods access the parts that are specific for the gopher URLs.
These methods access different parts of the $url->path.

$url->gtype (*)
$url->selector (*)
$url->search (*)
$url->string (*)

NEWS METHODS
============

$url->group (*)
$url->article (*)

WAIS METHODS
============

The methods access the parts that are specific for the wais URLs.  These
methods access different parts of the $url->path.

$url->database (*)
$url->wtype (*)
$url->wpath (*)

MAILTO METHODS
==============

$url->address (*)
     The mail address can also be accessed with the netloc() method.


WHAT A URL IS NOT
=================

URL objects do not, and should not, know how to 'get' or 'put' the
resources they specify locations for, anymore than a postal address
'knows' anything about the postal system. The actual access/transfer
should be achieved by some form of transport agent class (see
*Note LWP/UserAgent: LWP/UserAgent,). The agent class can use the URL class, but should
not be a subclass of it.


COMPATIBILITY
=============

This is a listing incompatibilities with URI::URL version 3.x:

unsafe(), escape() and unescape()
     These methods not supported any more.

full_path() and as_string()
     These methods does no longer take a second argument which specify
     the set of characters to consider as unsafe.

'+' in the query-string
     The '+' character in the query part of the URL was earlier
     considered to be an encoding of a space. This was just bad
     influence from Mosaic.  Space is now encoded as '%20'.

path() and query()
     This methods will croak if they loose information.  Use epath() or
     equery() instead.  The path() method will for instance loose
     information if any path segment contain an (encoded) '/' character.

     The path() now consider a leading '/' to be part of the path.  If
     the path is empty it will default to '/'.  You can get the old
     behaviour by setting $URI::URL::COMPAT_VER_3 to TRUE before
     accessing the path() method.

netloc()
     The string passed to netloc is now assumed to be escaped.  The
     string returned will also be (partially) escaped.

sub-classing
     The path, params and query is now stored internally in unescaped
     form.  This might affect sub-classes of the URL scheme classes.


AUTHORS / ACKNOWLEDGMENTS
=========================

This module is (distantly) based on the `wwwurl.pl' code in the
libwww-perl distribution developed by Roy Fielding
<fielding@ics.uci.edu>, as part of the Arcadia project at the University
of California, Irvine, with contributions from Brooks Cutter.

Gisle Aas <aas@sn.no>, Tim Bunce <Tim.Bunce@ig.co.uk>, Roy Fielding
<fielding@ics.uci.edu> and Martijn Koster <m.koster@webcrawler.com> (in
English alphabetical order) have collaborated on the complete rewrite
for Perl 5, with input from other people on the libwww-perl mailing
list.

If you have any suggestions, bug reports, fixes, or enhancements, send
them to the libwww-perl mailing list at <libwww-perl@ics.uci.edu>.


COPYRIGHT
=========

Copyright 1995-1996 Gisle Aas.  Copyright 1995 Martijn Koster.

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.




File: pm.info, Node: Unicode/CharName, Next: Unicode/String, Prev: URI/URL, Up: Module List

Look up Unicode character names
*******************************



NAME
====

Unicode::CharName - Look up Unicode character names


SYNOPSIS
========

     use Unicode::CharName qw(uname ublock);
     print uname(ord('%')), "\n";
     print ublock(0x0300), "\n";


DESCRIPTION
===========

This module provide a two functions named uname() and ublock().  The
uname() function will return the Unicode character name for the given
code (a number between 0 and 0x10FFFF).  Unicode character names are
written in upper-case ASCII letters, and are strings like:

     LATIN CAPITAL LETTER A
     LATIN SMALL LETTER A WITH RING ABOVE
     CJK UNIFIED IDEOGRAPH 7C80
     HANGUL SYLLABLE PWILH

The ublock() will return the name of the Unicode character block that
the given character belongs to.


SEE ALSO
========

*Note Unicode/String: Unicode/String,


COPYRIGHT
=========

Copyright 1997 Gisle Aas.

This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

Name table extracted from the Unicode 2.0 Character Database. Copyright
(c) 1991-1996 Unicode, Inc. All Rights reserved.




File: pm.info, Node: Unicode/String, Next: User/grent, Prev: Unicode/CharName, Up: Module List

String of Unicode characters (UCS2/UTF16)
*****************************************



NAME
====

Unicode::String - String of Unicode characters (UCS2/UTF16)


SYNOPSIS
========

     use Unicode::String qw(utf8 latin1 utf16);
     $u = utf8("The Unicode Standard is a fixed-width, uniform ");
     $u .= utf8("encoding scheme for written characters and text");

     # convert to various external formats
     print $u->ucs4;      # 4 byte characters
     print $u->utf16;     # 2 byte characters + surrogates
     print $u->utf8;      # 1-4 byte characters
     print $u->utf7;      # 7-bit clean format
     print $u->latin1;    # lossy
     print $u->hex;       # a hexadecimal string

     # all these can be used to set string value or as constructor
     $u->latin1("Å være eller å ikke være");
     $u = utf16("\0Å\0 \0v\0æ\0r\0e");

     # string operations
     $u2 = $u->copy;
     $u->append($u2);
     $u->repeat(2);
     $u->chop;

     $u->length;
     $u->index($other);
     $u->index($other, $pos);

     $u->substr($offset);
     $u->substr($offset, $length);
     $u->substr($offset, $length, $substitute);

     # overloading
     $u .= "more";
     $u = $u x 100;
     print "$u\n";

     # string <--> array of numbers
     @array = $u->unpack;
     $u->pack(@array);

     # misc
     $u->ord;
     $u = uchr($num);


DESCRIPTION
===========

A *Unicode::String* object represents a sequence of Unicode characters.
The Unicode Standard is a fixed-width, uniform encoding scheme for
written charaters and text.  This encoding treats alphabetic characters,
ideographic characters, and symbols identically, which means that they
can be used in any mixture and with equal facility.  Unicode is modeled
on the ASCII character set, but uses a 16-bit encoding to support full
multilingual text.

Internally a *Unicode::String* object is a string of 2 byte values in
network byte order (big-endian).  The class provide various methods to
convert from and to various external formats (ucs4 / utf16 / utf8 / utf7
/ latin1 / hex).  All string manipulations are made on strings in this
the internal 16-bit format.


COPYRIGHT
=========

Copyright 1997 Gisle Aas.

This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.




File: pm.info, Node: User/grent, Next: User/pwent, Prev: Unicode/String, Up: Module List

by-name interface to Perl's built-in getgr*() functions
*******************************************************



NAME
====

User::grent - by-name interface to Perl's built-in getgr*() functions


SYNOPSIS
========

     use User::grent;
     $gr = getgrgid(0) or die "No group zero";
     if ( $gr->name eq 'wheel' && @{$gr->members} > 1 ) {
         print "gid zero name wheel, with other members";
     } 

     use User::grent qw(:FIELDS;
     getgrgid(0) or die "No group zero";
     if ( $gr_name eq 'wheel' && @gr_members > 1 ) {
         print "gid zero name wheel, with other members";
     } 

     $gr = getgr($whoever);


DESCRIPTION
===========

This module's default exports override the core getgrent(), getgruid(),
and getgrnam() functions, replacing them with versions that return
"User::grent" objects.  This object has methods that return the
similarly named structure field name from the C's passwd structure from
`grp.h'; namely name, passwd, gid, and members (not mem).  The first
three return scalars, the last an array reference.

You may also import all the structure fields directly into your
namespace as regular variables using the :FIELDS import tag.  (Note that
this still overrides your core functions.)  Access these fields as
variables named with a preceding `gr_'.  Thus, `$group_obj->gid()'
corresponds to $gr_gid if you import the fields.  Array references are
available as regular array variables, so `@{ $group_obj->members() }'
would be simply @gr_members.

The getpw() funtion is a simple front-end that forwards a numeric
argument to getpwuid() and the rest to getpwnam().

To access this functionality without the core overrides, pass the use an
empty import list, and then access function functions with their full
qualified names.  On the other hand, the built-ins are still available
via the `CORE::' pseudo-package.


NOTE
====

While this class is currently implemented using the Class::Struct module
to build a struct-like class, you shouldn't rely upon this.


AUTHOR
======

Tom Christiansen



File: pm.info, Node: User/pwent, Next: VMS/priv, Prev: User/grent, Up: Module List

by-name interface to Perl's built-in getpw*() functions
*******************************************************



NAME
====

User::pwent - by-name interface to Perl's built-in getpw*() functions


SYNOPSIS
========

     use User::pwent;
     $pw = getpwnam('daemon') or die "No daemon user";
     if ( $pw->uid == 1 && $pw->dir =~ m#^/(bin|tmp)?$# ) {
         print "gid 1 on root dir";
     } 

     use User::pwent qw(:FIELDS);
     getpwnam('daemon') or die "No daemon user";
     if ( $pw_uid == 1 && $pw_dir =~ m#^/(bin|tmp)?$# ) {
         print "gid 1 on root dir";
     } 

     $pw = getpw($whoever);


DESCRIPTION
===========

This module's default exports override the core getpwent(), getpwuid(),
and getpwnam() functions, replacing them with versions that return
"User::pwent" objects.  This object has methods that return the
similarly named structure field name from the C's passwd structure from
`pwd.h'; namely name, passwd, uid, gid, quota, comment, gecos, dir, and
shell.

You may also import all the structure fields directly into your
namespace as regular variables using the :FIELDS import tag.  (Note that
this still overrides your core functions.)  Access these fields as
variables named with a preceding `pw_' in front their method names.
Thus, `$passwd_obj->shell()' corresponds to $pw_shell if you import the
fields.

The getpw() funtion is a simple front-end that forwards a numeric
argument to getpwuid() and the rest to getpwnam().

To access this functionality without the core overrides, pass the use an
empty import list, and then access function functions with their full
qualified names.  On the other hand, the built-ins are still available
via the `CORE::' pseudo-package.


NOTE
====

While this class is currently implemented using the Class::Struct module
to build a struct-like class, you shouldn't rely upon this.


AUTHOR
======

Tom Christiansen



File: pm.info, Node: VMS/priv, Next: VMS/procinfo, Prev: User/pwent, Up: Module List

Get and set priviliges for VMS processes
****************************************



NAME
====

VMS::Priv - Get and set priviliges for VMS processes


SYNOPSIS
========

     use VMS::Priv;

Routines to return different sets of priviliges:

     @names = priv_names();
     $hashref = get_current_privs([pid]);
     $hashref = get_auth_privs([pid]);
     $hashref = get_process_privs([pid]);
     $hashref = get_image_privs([pid]);
     $hashref = get_default_privs([pid])
     $hashref = get_settable_privs([pid])

Routines to add or remove priviliges:

     $hashref = add_current_privs(\@priv_list[,permanent]);
     $hashref = remove_current_privs(\@priv_list[,permanent]);
     $hashref = set_current_privs(\@priv_list[,permanent]);

Tied Hash Interface:

     tie %privtie, VMS::Priv <, pid>;

     %privtie{privname} = <anything>; # Add a priv
     %privtie{privname} = undef; # take one away
     defined(%privtie{privname}) # true if you currently have the priv, else false
     %privtie{} = (); # Remove all privs

Object Interface:

     $foo = new VMS::Priv <pid>;
     $hashref = $foo->add(\@priv_list[,permanent]);
     $hashref = $foo->remove(\@priv_list[,permanent])
     $hashref = $foo->set(\@priv_list[,permanent])


DESCRIPTION
===========

Get and set privileges for VMS processes. The user running the script
must have sufficient privs to actually perform the act.


Tied hash interface
-------------------

You can tie a hash to a pid (or to the current process' pid, if you
don't specify a pid). Once you do that, you can check, add or remove
privs via that hash. To add a priv, set the hash entry corresponding to
the priv name to anything. To remove a priv, set the corresponding hash
entry to undef.  To check if you have the priv, see if the entry is
defined or not.


Object interface
----------------

You can use the new method to create an object for the current
process. The methods add, remove and set take a reference to a list of
privs and add, remove, or set the process' privs. They're currently not
enourmously useful, mainly used by the tied hash interface. But they're
there if you care to use them.


Function interface
------------------

The `priv_names()' function simply returns as a list of the canonical
names of all the privileges VMS::Priv knows about.  Note that some
privileges have common aliases as well (*e.g.* `SETPRI' and `ALTPRI').
The VMS::Priv functions which set privileges understand these aliases as
well.

All other routines return a reference to a hash whose keys are the
canonical names (only) of the privileges which are enabled. The get
routines return the set of privs you asked for, the add/remove/set
routines return the privs that you have after the call is complete.

The add/remove/set routines take as their first argument a reference to
a list of keywords designating the privileges you want to affect.  Case
is not significant.  `add_current_privs()' adds the list of privs to
your process, `remove_current_privs()' takes the list of privs away from
your process, and `set_current_privs()' gives just those privs to your
process.  The second argument is a Boolean value which if true specifies
that these changes should persist after Perl exits; it defaults to true.

`get_settable_privs()' returns a list of all the privs you can turn
on. It's a combination of the process's authorized privs and the
process's image privs.

`get_default_privs()' returns a list of the privs the user who's process
you're looking up gets by default. These may not be the default privs
that were in place when the process was created. You also may bot be
able to grant all the default privs to your process, since it is
entirely possible to have more privs turned on by default than you have
authorized. Default unauthorized privs, once dropped, are lost forever.


BUGS
====

You can't alter the privs for any process but yourself. This is a VMS
limitation, and isn't likely to change any time soon.

Under VMS 7.1, the DETACH priv has been renamed IMPERSONATE. DCL's
lexical F$GETJPI, which is used in the tests, still reports DETACH, so
we return DETACH instead of IMPERSONATE. (Which is more of a VMS bug,
since they got the ACNT/NOACNT switch in for 7.1) IMPERSONATE's still a
legitimate thing to pass, though, and VMS accepts either.

There's no test for get_default_privs, as getting them another way to
test is somewhat problematic, at least for me. If someone's got code to
parse out the default privs from AUTHORIZE (the use of which may be a
problem in and of itself at some sites), we can add a test.


AUTHOR
======

Dan Sugalski <sugalsd@lbcc.cc.or.us> Hacked up by Charles Bailey
<bailey@genetics.upenn.edu>


SEE ALSO
========

perl(1).




File: pm.info, Node: VMS/procinfo, Next: VRML, Prev: VMS/priv, Up: Module List

Perl extension to retrieve lots of process info for a process.
**************************************************************



NAME
====

VMS::ProcInfo - Perl extension to retrieve lots of process info for a
process.


SYNOPSIS
========

     use VMS::ProcInfo;

Routine to return a reference to a hash with all the process info for
the process loaded into it:

     $procinfo = VMS::ProcInfo::get_all_proc_info_items(pid);
     $diolimit = $procinfo->{DIOLM};

Fetch a single piece of info:

     $diolm = VMS::ProcInfo::get_one_proc_info_item(pid, "DIOLM");

Decode a bitmap into a hash filled with names, with their values set to
true or false based on the bitmap.

     $hashref = VMS::ProcInfo::decode_proc_info_bitmap("CREPRC_FLAGS", Bitmap);
     $hashref->{BATCH};

Get a list of valid info names:

     @InfoNames = VMS::ProcInfo::proc_info_names;

Tied hash interface:
  
  tie %procinfohash, VMS::ProcInfo<, pid>;
  $diolm = $procinfohash{DIOLM};

Object access:

     $procinfoobj = new VMS::ProcInfo <pid>;
     $diolm = $procinfoobj->one_info("DIOLM");
     $hashref = $procinfoobj->all_info();


DESCRIPTION
===========

Retrieve info for a process. Access is via function call, object and
method, or tied hash. Choose your favorite.

Note that this module does not completely duplicate the DCL F$GETJPI
lexical function.  Amongst other things, it doesn't return quota or
rightslist info. Quick rule of thumb is only single pieces of info are
returned.


BUGS
====

May leak memory. May not, though.


LIMITATIONS
===========

Quadword values are returned as string values rather than integers.

Privilege info's not returned. Use VMS::Priv for that.

List info (rightslist and exceptions vectors) are not returned.

The bitmap decoder doesn't grok the CURRENT_USERCAP_MASK, MSGMASK, or
PERMANENT_USERCAP_MASK fields, as I don't know where the bitmask defs
for them are in the header files. When I do, support will get added.


AUTHOR
======

Dan Sugalski <sugalsd@lbcc.cc.or.us>


SEE ALSO
========

perl(1), VMS::Quota.




File: pm.info, Node: VRML, Next: VRML/Basic, Prev: VMS/procinfo, Up: Module List

implements VRML Nodes independent of specification (1.x or 2.0)
***************************************************************



NAME
====

VRML - implements VRML Nodes independent of specification (1.x or 2.0)


SYNOPSIS
========

     use VRML;

     $vrml = new VRML;
     $vrml->browser('Netscape+Live3D');
     $vrml->at('-15 0 20');
     $vrml->cube('5 3 1','yellow');
     $vrml->back;
     $vrml->print;

     OR with the same result

     use VRML;

     VRML
     ->browser('Netscape+Live3D')
     ->at('-15 0 20')->cube('5 3 1','yellow')->back
     ->print;


DESCRIPTION
===========

   * $content_type; # for CGI scripts only

     content_type is `'x-world/x-vrml'' for VRML 1.0

     or `'model/vrml'' for VRML 2.0


SEE ALSO
========

VRML::VRML1

VRML::VRML1::Standard

VRML::VRML2

VRML::VRML2::Standard

VRML::Basic


AUTHOR
======

Hartmut Palm `<palm@gfz-potsdam.de>'




File: pm.info, Node: VRML/Basic, Next: VRML/Color, Prev: VRML, Up: Module List

implements basic methods
************************



NAME
====

VRML::Basic.pm - implements basic methods


SYNOPSIS
========

     use VRML::Basic;


DESCRIPTION
===========

Following methods are currently implemented.

new
     new

debug
     debug

VRML_init
     VRML_init

VRML_head
     VRML_head

VRML_add
     VRML_add

VRML_trim
     VRML_trim

VRML_swap
     VRML_swap

VRML_put
     VRML_put

VRML_row
     VRML_row

VRML_pos
     VRML_pos

VRML_comment
     VRML_comment

VRML_print
     VRML_print

VRML_format
     VRML_format

as_string
     as_string

print
     print

print_as_cgi
     print_as_cgi

save
     `save($filename)'


AUTHOR
======

Hartmut Palm `<palm@gfz-potsdam.de>'




File: pm.info, Node: VRML/Color, Next: VRML/VRML1, Prev: VRML/Basic, Up: Module List

implements color methods and names
**********************************



NAME
====

Color.pm - implements color methods and names


SYNOPSIS
========

     use VRML::Color;


DESCRIPTION
===========

*X11 colornames are:*

     aliceblue antiquewhite aqua aquamarine azure beige bisque black
     blanchedalmond blue blueviolet brown burlywood cadetblue chartreuse
     chocolate coral cornflowerblue cornsilk crimson cyan darkblue darkcyan
     darkgoldenrod darkgray darkgreen darkkhaki darkmagenta darkolivegreen
     darkorange darkorchid darkred darksalmon darkseagreen darkslateblue
     darkslategray darkturquoise darkviolet deeppink deepskyblue dimgray
     dodgerblue firebrick floralwhite forestgreen fuchsia gainsboro
     ghostwhite gold goldenrod gray green greenyellow honeydew hotpink
     indianred indigo ivory khaki lavender lavenderblush lawngreen
     lemonchiffon lightblue lightcoral lightcyan lightgoldenrodyellow
     lightgreen lightgrey lightpink lightsalmon lightseagreen lightskyblue
     lightslategray lightsteelblue lightyellow lime limegreen linen magenta
     maroon mediumaquamarine mediumblue mediumorchid mediumpurple
     mediumseagreen mediumslateblue mediumspringgreen mediumturquoise
     mediumvioletred midnightblue mintcream mistyrose moccasin navajowhite
     navy oldlace olive olivedrab orange orangered orchid palegoldenrod
     palegreen paleturquoise palevioletred papayawhip peachpuff peru pink
     plum powderblue purple red rosybrown royalblue saddlebrown salmon
     sandybrown seagreen seashell sienna silver skyblue slateblue slategray
     snow springgreen steelblue tan teal thistle tomato turquoise violet
     wheat white whitesmoke yellow yellowgreen

You can also use

     red-40 = '0.4 0 0'
     yellow%30 = '0.3 0.3 0'
     gray%30 = '0.7 0.7 0.7' !!!




File: pm.info, Node: VRML/VRML1, Next: VRML/VRML1/Standard, Prev: VRML/Color, Up: Module List

implements VRML methods with the VRML 1.x standard
**************************************************



NAME
====

VRML::VRML1.pm - implements VRML methods with the VRML 1.x standard


SYNOPSIS
========

     use VRML::VRML1;


DESCRIPTION
===========

Following methods are currently implemented. (Values in '...' must be
strings!)

   * begin('comment')

     ` . . . '

   * end('comment')
   * group_begin('comment')

     ` . . . '

   * group_end
   * at('type=value ; ...')

     parameter see `transform_begin'

   * back
   * transform_begin('type=value ; ...')

     *Where type can be:*

          t = translation r = rotation c = center o = scaleOrientation f =
          scaleFactor

   * transform_end
   * anchor_begin('URL','description','target=parameter')
   * anchor_end
   * collision_begin
   * collision_end
   * lod_begin('range','center')
   * lod_end
   * background('color','imageURL')
   * title('string')
   * info('string')
   * cameras_begin('whichCameraNumber')
   * camera('name','positionXYZ','orientationXYZ',heightAngle) // persp. camera
   * camera_set('positionXYZ','orientationXYZ',heightAngle) // persp. cameras
   * camera_auto_set
   * cameras_end
   * light('direction','intensity','color','ambientIntensity','on') 
   * box('width [height [depth]]','appearance')
   * cone('radius height','appearance')
   * cube('width','appearance')
   * cylinder('radius [height]','appearance')
   * line('fromXYZ','toXYZ',radius,'appearance','[x][y][z]')
   * sphere('radius_x [radius_y radius_z]','appearance')
   * text('string','appearance','size style family')
   * fixtext('string','appearance','size style family')
   * def('name',[code])
   * use('name')
   * appearance('type=value1,value2 ; ...')

     *Where type can be:*

          a = ambientColor d = diffuseColor e = emissiveColor s =
          specularColor sh = shininess tr = transparency tex = texture
          filename[,wrapS[,wrapT]]

     *and color values see*

     VRML::Color


SEE ALSO
========

VRML

VRML::VRML1::Standard

VRML::Basic


AUTHOR
======

Hartmut Palm `<palm@gfz-potsdam.de>'




File: pm.info, Node: VRML/VRML1/Standard, Next: VRML/VRML2, Prev: VRML/VRML1, Up: Module List

implements nodes the VRML 1.x standard
**************************************



NAME
====

VRML::VRML1::Standard.pm - implements nodes the VRML 1.x standard


SYNOPSIS
========

     use VRML::VRML1::Standard;


DESCRIPTION
===========

Following nodes are currently implemented.

[Group Nodes] [Geometry Nodes] [Property Nodes]

[Appearance Nodes] [Transform Nodes] [Common Nodes]


Group Nodes
-----------

*These nodes NEED* End !

Group
     `Group($comment)'

Separator
     `Separator($comment)'

Switch
     `Switch($whichChild, $comment)'

WWWAnchor
     `WWWAnchor($url, $description, $target)'

     $target works only with *some* browsers

LOD
     `LOD($range, $center)'

     $range is a string with comma separated values

     $center = SFVec3f

     example: `LOD('1, 2, 5', '0 0 0')'

SpinGroup
     `SpinGroup($rotation, $local)' is supported only by *some* browsers


Geometry Nodes
--------------

AsciiText
     `AsciiText($string, $width, $justification, $spacing)'

     $justification is a string ('LEFT','CENTER','RIGHT')

Cone
     `Cone($radius, $height, @parts)'

     @parts is a list of strings ('SIDES', 'BOTTOM', 'ALL')

Cube
     `Cube($width, $height, $depth)'

Cylinder
     `Cylinder($radius, $height, @parts)'

     @parts is a list of strings ('SIDES', 'TOP', 'BOTTOM', 'ALL')

IndexedFaceSet
     `IndexedFaceSet($coordIndex_ref, $materialIndex_ref,
     $normalIndex_ref, $textureCoordIndex_ref)'

     $coordIndex_ref is a reference of a list of point index strings
     like `'0 1 3 2', '2 3 5 4', ...'

     $materialIndex_ref is a reference of a list of materials

     $normalIndex_ref is a reference of a list of normals

     $textureCoordIndex_ref is a reference of a list of textures

IndexedLineSet
     `IndexedLineSet($coordIndex_ref, $materialIndex_ref,
     $normalIndex_ref, $textureCoordIndex_ref)'

     $coordIndex_ref is a reference of a list of point index strings
     like `'0 1 3 2', '2 3 5 4', ...'

     $materialIndex_ref is a reference of a list of materials

     $normalIndex_ref is a reference of a list of normals

     $textureCoordIndex_ref is a reference of a list of textures

PointSet
     `PointSet($numPoints, $startIndex)'

Sphere
     `Sphere($radius)'

     $radius have to be > 0


Property Nodes
--------------

Coordinate3
     `Coordinate3(@points)'

     @points is a list of points with strings like `'1.0 0.0 0.0', '-1 2 0''

Fontstyle
     `FontStyle($size, $style, $family)' defines the current font style
     for all subsequent AsciiText Nodes

     $style can be 'NONE','BOLD','ITALIC'

     $familiy can be 'SERIF','SANS','TYPEWRITER'


Appearance Nodes
----------------

Material
     `Material(%materials)'

MaterialBinding
     `MaterialBinding($value)'

     $value can be

          DEFAULT	Use default bindng
          OVERALL	Whole object has same material
          PER_PART	One material for each part of object
          PER_PART_INDEXED	One material for each part, indexed
          PER_FACE	One material for each face of object
          PER_FACE_INDEXED	One material for each face, indexed
          PER_VERTEX	One material for each vertex of object
          PER_VERTEX_INDEXED	One material for each vertex, indexed

Normal
     `Normal(@vector)'

     @vector is a list of vectors with strings like `'1.0 0.0 0.0', '-1 2 0''

NormalBinding
     `NormalBinding($value)'

     $value is the same as MaterialBinding

Texture2
     `Texture2($value)'


Transform Nodes
---------------

Transform
     `Transform($translation, $rotation, $scaleFactor,
     $scaleOrientation, $center)'

     $translation is a string like "0 1 -2"

     $rotation is a string like "0 0 1 1.57"

     $scaleFactor is a string like "1 1 1"

     $scaleOrientation is a string like "0 0 1 0"

     $center is a string like "0 0 0"

Rotation
     `Rotation($rotation)'

     $rotation is a string like "0 0 1 1.57"

     `This node is not supported under VRML 2.0. Use Transform'

Scale
     `Scale($scaleFactor)'

     $scaleFactor is a string like "1 1 1"

     `This node is not supported under VRML 2.0. Use Transform'

Translation
     `Translation($translation)'

     $translation is a string like "0 1 -2"

     `This node is not supported under VRML 2.0. Use Transform'


Common Nodes
------------

PerspectiveCamera
     `PerspectiveCamera($position, $orientation, $heightAngle,
     $focalDistance, $nearDistance, $farDistance)'

OrthographicCamera
     `OrthographicCamera($position, $orientation, $height,
     $focalDistance, $nearDistance, $farDistance)'

DirectionalLight
     `DirectionalLight($direction, $intensity, $ambientIntensity,
     $color, $on)'

PointLight
     `PointLight($location, $intensity, $color, $on)'

SpotLight
     `SpotLight($location, $direction, $intensity, $color, $on)'

DirectedSound
     `DirectedSound($name, $description, $location, $direction,
     $intensity, $maxFrontRange, $maxBackRange, $minFrontRange,
     $minBackRange, $loop, $pause)'


other
-----

WWWInline
     `WWWInline($name, $bboxSize, $bboxCenter)'

Info
     `Info($string, $comment)'

     $comment is optional

NavigationInfo
     `NavigationInfo($headlight, $type)'

     Works only with Live3D and WebFX

USE
     `USE($name)'

DEF
     `DEF($name)'


AUTHOR
======

Hartmut Palm `<palm@gfz-potsdam.de>'




File: pm.info, Node: VRML/VRML2, Next: VRML/VRML2/Standard, Prev: VRML/VRML1/Standard, Up: Module List

implements VRML methods with the VRML 2.0 standard
**************************************************



NAME
====

VRML::VRML2.pm - implements VRML methods with the VRML 2.0 standard


SYNOPSIS
========

     use VRML::VRML2;


DESCRIPTION
===========

Following methods are currently implemented. (Values in '...' must be
strings!)

   * begin(['comment'])

     ` . . . '

   * end(['comment'])
   * group_begin(['comment'])

     ` . . . '

   * group_end
   * at('type=value ; ...')

     parameter see `transform_begin'

   * back
   * transform_begin('type=value ; ...')

     *Where type can be:*

          t = translation r = rotation c = center o = scaleOrientation f =
          scaleFactor

   * transform_end
   * anchor_begin('Url','description','parameter')
   * anchor_end
   * collision_begin
   * collision_end
   * lod_begin('range','center')
   * lod_end
   * background('skycolor','backUrl','groundcolor','bottomURL','topURL', 'leftUrl','rightUrl','frontUrl')
   * title('string')
   * info('string')
   * cameras_begin('whichCameraNumber')
   * camera('positionXYZ','orientationXYZ',fieldOfView)  // persp. camera
   * camera_set('positionXYZ','orientationXYZ',fieldOfView) // persp. cameras
   * camera_auto_set
   * cameras_end(['comment'])
   * light('direction','intensity','color','ambientIntensity','on') 
   * box('width [height [depth]]','appearance')
   * cone('radius height','appearance')
   * cube('width','appearance')
   * cylinder('radius [height]','appearance')
   * line('fromXYZ','toXYZ',radius,'appearance','[x][y][z]')
   * sphere('radius_x [radius_y radius_z]','appearance')
   * text('string','appearance','size style family')
   * fixtext('string','appearance','size style family')
   * def('name',[code])
   * use('name')
   * route('from','to')
   * appearance('type=value1,value2 ; ...')

     *Where type can be:*

          a = ambientColor d = diffuseColor e = emissiveColor s =
          specularColor sh = shininess tr = transparency tex = texture
          filename[,wrapS[,wrapT]]

     *and color values see*

     VRML::Color


SEE ALSO
========

VRML

VRML::VRML2::Standard

VRML::Basic


AUTHOR
======

Hartmut Palm `<palm@gfz-potsdam.de>'




File: pm.info, Node: VRML/VRML2/Standard, Next: WWW/Robot, Prev: VRML/VRML2, Up: Module List

implements nodes the VRML 2.0 standard
**************************************



NAME
====

VRML::VRML2::Standard.pm - implements nodes the VRML 2.0 standard


SYNOPSIS
========

     use VRML::VRML2::Standard;


DESCRIPTION
===========

Following nodes are currently implemented.

[Grouping Nodes] [Special Groups] [Common Nodes]

[Geometry] [Geometric Properties] [Appearance]

[Sensors] [Bindable Nodes]


Grouping Nodes
--------------

*These nodes NEED* End !

Anchor
     `Anchor($url, $description, $parameter, $bboxSize, $bboxCenter)'

     Currently only the first *$parameter* is supported.

Billboard
     `Billboard($axisOfRotation)'

Collision
     `Collision($collide)'

Group
     `Group($comment)'

Transform
     `Transform($translation, $rotation, $scale, $scaleOrientation,
     $center)'

     $translation is a SFVec3f

     $rotation is a SFRotation

     $scale is a SFVec3f

     $scaleOrientation is a SFRotation

     $center is a SFVec3f


Special Groups
--------------

Inline
     `Inline($url, $bboxSize, $bboxCenter)'

LOD
     `LOD($range, $center)'

     $range is a string with comma separated values

     $center = SFVec3f

     example: `LOD('1, 2, 5', '0 0 0')'

Switch
     `Switch($whichChoice, $comment)'


Common Nodes
------------

DirectionalLight
     `DirectionalLight($direction, $intensity, $ambientIntensity,
     $color, $on)'

PointLight
     `PointLight($location, $intensity, $color, $on)'

SpotLight
     `SpotLight($location, $direction, $intensity, $color, $on)'

Sound
     `Sound($source, $location, $direction, $intensity, $maxFront,
     $maxBack, $minFront, $minBack, $priority, $spatialize)'

AudioClip
     `AudioClip($url, $description, $loop, $pitch, $startTime,
     $stopTime)'

WorldInfo
     `WorldInfo($title, $info)'

Shape
     `Shape($comment)'


Geometry
--------

Box
     `Box($width, $height, $depth)'

Cone
     `Cone($radius, $height, $side, $bottom)'

Cylinder
     `Cylinder($radius, $height, $top, $side, $bottom)'

IndexedFaceSet
     `IndexedFaceSet($coordIndex_ref, $colorIndex_ref, $normalIndex_ref,
     $texCoordIndex_ref)'

     $coordIndex_ref is a reference of a list of point index strings
     like `'0 1 3 2', '2 3 5 4', ...'

     $colorIndex_ref is a reference of a list of materials

     $normalIndex_ref is a reference of a list of normals

     $texCoordIndex_ref is a reference of a list of textures

IndexedLineSet
     `IndexedLineSet($coordIndex_ref, $colorIndex_ref, $normalIndex_ref,
     $texCoordIndex_ref)'

     $coordIndex_ref is a reference of a list of point index strings
     like `'0 1 3 2', '2 3 5 4', ...'

     $colorIndex_ref is a reference of a list of materials

     $normalIndex_ref is a reference of a list of normals

     $texCoordIndex_ref is a reference of a list of textures

PointSet
     `PointSet($numPoints, $startIndex)'

Sphere
     `Sphere($radius)'

     $radius have to be > 0

Text
     `Text($string, $fontStyle, $length, $maxExtent)'


Geometric Properties
--------------------

Coordinate
     `Coordinate(@point)'

     @point is a list of points with strings like `'1.0 0.0 0.0', '-1 2 0''

Color
     `Color(@color)'

     @color is a list of colors with strings like `'1.0 0.0 0.0', '-1 2 0''

Normal
     `Normal(@vector)'

     @vector is a list of vectors with strings like `'1.0 0.0 0.0', '-1 2 0''


Appearance
----------

Appearance
     Appearance

Fontstyle
     `FontStyle($size, $style, $family, $justify)' defines the current
     font style for all subsequent Text Nodes

     $style can be 'NONE','BOLD','ITALIC'

     $familiy can be 'SERIF','SANS','TYPEWRITER'

     $justify can be 'BEGIN', 'MIDDLE', 'END'

Material
     `Material(%materials)'

ImageTexture
     `ImageTexture($url)'

MovieTexture
     `MovieTexture($url)'


Sensors
-------

CylinderSensor
     `CylinderSensor($enabled, $maxAngle, $minAngle)'

PlaneSensor
     `PlaneSensor($enabled, $maxPosition, $minPosition, $offset,
     $autoOffset)'

SphereSensor
     `SphereSensor($enabled, $offset, $autoOffset)'

TimeSensor
     `TimeSensor($cycleInterval, $loop, $enabled)'

TouchSensor
     `TouchSensor($eneabled)'


Bindable Nodes
--------------

Background
     `Background($backUrl, $bottomUrl, $topUrl, $leftUrl, $rightUrl,
     $frontUrl, $groundColor, $skyColor, $groundAngle, $skyAngle)'

NavigationInfo
     `NavigationInfo($headlight, $type, $speed, $visibilityLimit,
     $avatarSize)'

Viewpoint
     `Viewpoint($description, $position, $orientation, $fieldOfView,
     $jump)'


other
-----

USE
     `USE($name)'

DEF
     `DEF($name)'

ROUTE
     `ROUTE($from, $to)'

End
     `End($comment)'

     $comment is optional


AUTHOR
======

Hartmut Palm `<palm@gfz-potsdam.de>'




