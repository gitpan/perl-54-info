Info file: pm.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `bigpm.texi'
using `texinfmt.el' version 2.32 of 19 November 1993.





File: pm.info, Node: WWW/Search/Infoseek, Next: WWW/Search/Infoseek/Email, Prev: WWW/Search/HotBot, Up: Module List

class for searching Infoseek.
*****************************



NAME
====

WWW::Search::Infoseek - class for searching Infoseek.


DESCRIPTION
===========

This class is an Infoseek specialization of WWW::Search.  It handles
making and interpreting AltaVista searches `http://www.infoseek.com'.

This is an abstract class: you cannot instance a variable of this type.

Descendant classes must override the native_retrieve_some method.

This class exports no public interface; all interaction should be done
through WWW::Search objects.


OPTIONS
=======

operator Ex. operator=>'AND' Values AND or OR (defaults to OR).
     If you want to use directly the native '+' and '-' operators than
     use the OR operator.


SEE ALSO
========

To make new back-ends, see *Note WWW/Search: WWW/Search,.


AUTHOR
======

Cesare Feroldi de Rosa, <C.Feroldi@IT.net> 1996.  (Derived from
AltaVista.pm.)


COPYRIGHT
=========

Copyright (c) 1996 University of Southern California.  All rights
reserved.

Redistribution and use in source and binary forms are permitted provided
that the above copyright notice and this paragraph are duplicated in all
such forms and that any documentation, advertising materials, and other
materials related to such distribution and use acknowledge that the
software was developed by the University of Southern California,
Information Sciences Institute.  The name of the University may not be
used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.




File: pm.info, Node: WWW/Search/Infoseek/Email, Next: WWW/Search/Infoseek/News, Prev: WWW/Search/Infoseek, Up: Module List

class for searching for e-mail at Infoseek
******************************************



NAME
====

WWW::Search::Infoseek::Email - class for searching for e-mail at
Infoseek


DESCRIPTION
===========

Back-end for Infoseek search engine .

This class exports no public interface; all interaction should be done
through WWW::Search objects.


OPTIONS
=======

operator Ex. operator=>'AND' Values AND or OR (defaults to OR).
     If you want to use directly the native '+' and '-' operators than
     use the OR operator.


SEE ALSO
========

To make new back-ends, see *Note WWW/Search: WWW/Search,.


AUTHOR
======

Cesare Feroldi de Rosa, <C.Feroldi@IT.net> 1996.  (Derived from
AltaVista.pm.)


COPYRIGHT
=========

Copyright (c) 1996 University of Southern California.  All rights
reserved.

Redistribution and use in source and binary forms are permitted provided
that the above copyright notice and this paragraph are duplicated in all
such forms and that any documentation, advertising materials, and other
materials related to such distribution and use acknowledge that the
software was developed by the University of Southern California,
Information Sciences Institute.  The name of the University may not be
used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.




File: pm.info, Node: WWW/Search/Infoseek/News, Next: WWW/Search/Infoseek/Web, Prev: WWW/Search/Infoseek/Email, Up: Module List

class for searching for News at Infoseek
****************************************



NAME
====

WWW::Search::Infoseek::News - class for searching for News at Infoseek


DESCRIPTION
===========

Back-end for Infoseek search engine (Usenet news).

This class exports no public interface; all interaction should be done
through WWW::Search objects.


OPTIONS
=======

operator Ex. operator=>'AND' Values AND or OR (defaults to OR).
     If you want to use directly the native '+' and '-' operators than
     use the OR operator.

groups Ex. groups=>'comp.foo.bar' Defaults to all groups.

SEE ALSO
========

To make new back-ends, see *Note WWW/Search: WWW/Search,.


AUTHOR
======

Cesare Feroldi de Rosa, <C.Feroldi@IT.net> 1996.  (Derived from
AltaVista.pm.)


COPYRIGHT
=========

Copyright (c) 1996 University of Southern California.  All rights
reserved.

Redistribution and use in source and binary forms are permitted provided
that the above copyright notice and this paragraph are duplicated in all
such forms and that any documentation, advertising materials, and other
materials related to such distribution and use acknowledge that the
software was developed by the University of Southern California,
Information Sciences Institute.  The name of the University may not be
used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.




File: pm.info, Node: WWW/Search/Infoseek/Web, Next: WWW/Search/Lycos, Prev: WWW/Search/Infoseek/News, Up: Module List

class for searching the web at Infoseek
***************************************



NAME
====

WWW::Search::Infoseek::Web - class for searching the web at Infoseek


DESCRIPTION
===========

Back-end for Infoseek search engine .

This class exports no public interface; all interaction should be done
through WWW::Search objects.


OPTIONS
=======

operator Ex. operator=>'AND' Values AND or OR (defaults to OR).
     If you want to use directly the native '+' and '-' operators than
     use the OR operator.


SEE ALSO
========

To make new back-ends, see *Note WWW/Search: WWW/Search,.


AUTHOR
======

Cesare Feroldi de Rosa, <C.Feroldi@IT.net> 1996.  (Derived from
AltaVista.pm.)


COPYRIGHT
=========

Copyright (c) 1996 University of Southern California.  All rights
reserved.

Redistribution and use in source and binary forms are permitted provided
that the above copyright notice and this paragraph are duplicated in all
such forms and that any documentation, advertising materials, and other
materials related to such distribution and use acknowledge that the
software was developed by the University of Southern California,
Information Sciences Institute.  The name of the University may not be
used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.




File: pm.info, Node: WWW/Search/Lycos, Next: WWW/Search/Yahoo, Prev: WWW/Search/Infoseek/Web, Up: Module List

class for searching Lycos
*************************



NAME
====

WWW::Search::Lycos - class for searching Lycos


DESCRIPTION
===========

This class is an Lycos specialization of WWW::Search.  It handles making
and interpreting Lycos searches `http://www.lycos.com'.

This class exports no public interface; all interaction should be done
through WWW::Search objects.


SEE ALSO
========

To make new back-ends, see *Note WWW/Search: WWW/Search,.


HOW DOES IT WORK?
=================

`native_setup_search' is called before we do anything.  It initializes
our private variables (which all begin with underscores) and sets up a
URL to the first results page in `{_next_url}'.

`native_retrieve_some' is called (from `WWW::Search::retrieve_some')
whenever more hits are needed.  It calls the LWP library to fetch the
page specified by `{_next_url}'.  It parses this page, appending any
search hits it finds to `{cache}'.  If it finds a ``next'' button in the
text, it sets `{_next_url}' to point to the page for the next set of
results, otherwise it sets it to undef to indicate we're done.


BUGS
====

This module should support options.


AUTHOR
======

`WWW::Search::Lycos' is written by Wm. L. Scheding based upon
`WWW::Search::AltaVista'.


COPYRIGHT
=========

Copyright (c) 1996 University of Southern California.  All rights
reserved.
                                                               
Redistribution and use in source and binary forms are permitted provided
that the above copyright notice and this paragraph are duplicated in all
such forms and that any documentation, advertising materials, and other
materials related to such distribution and use acknowledge that the
software was developed by the University of Southern California,
Information Sciences Institute.  The name of the University may not be
used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.




File: pm.info, Node: WWW/Search/Yahoo, Next: WWW/SearchResult, Prev: WWW/Search/Lycos, Up: Module List

class for searching Yahoo
*************************



NAME
====

WWW::Search::Yahoo - class for searching Yahoo


DESCRIPTION
===========

WARNING: This class has not been fully debugged yet.  Use at your own
risk.

This class is an Yahoo specialization of WWW::Search.  It handles making
and interpreting Yahoo searches `http://www.yahoo.com'.

This class exports no public interface; all interaction should be done
through WWW::Search objects.


SEE ALSO
========

To make new back-ends, see *Note WWW/Search: WWW/Search,.


HOW DOES IT WORK?
=================

`native_setup_search' is called before we do anything.  It initializes
our private variables (which all begin with underscores) and sets up a
URL to the first results page in `{_next_url}'.

`native_retrieve_some' is called (from `WWW::Search::retrieve_some')
whenever more hits are needed.  It calls the LWP library to fetch the
page specified by `{_next_url}'.  It parses this page, appending any
search hits it finds to `{cache}'.  If it finds a ``next'' button in the
text, it sets `{_next_url}' to point to the page for the next set of
results, otherwise it sets it to undef to indicate we're done.


BUGS
====

`WWW::Search::Yahoo' does not currently work reliably and is not being
actively maintained.  If you wish to hack on it, please go ahead.


AUTHOR
======

`WWW::Search::Yahoo' is written by Wm. L. Scheding based upon
`WWW::Search::AltaVista'.


COPYRIGHT
=========

Copyright (c) 1996 University of Southern California.  All rights
reserved.
                                                               
Redistribution and use in source and binary forms are permitted provided
that the above copyright notice and this paragraph are duplicated in all
such forms and that any documentation, advertising materials, and other
materials related to such distribution and use acknowledge that the
software was developed by the University of Southern California,
Information Sciences Institute.  The name of the University may not be
used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.




File: pm.info, Node: WWW/SearchResult, Next: X11/Auth, Prev: WWW/Search/Yahoo, Up: Module List

class for results returned from WWW::Search
*******************************************



NAME
====

WWW::SearchResult - class for results returned from WWW::Search


DESCRIPTION
===========

A framework for returning the results of `WWW::Search'.


SEE ALSO
========

*Note WWW/Search: WWW/Search,


METHODS AND FUNCTIONS
=====================


new
---

To create a new WWW::SearchResult, call
    $search = new WWW::SearchResult();


url
---

Return the primary URL.  Note that there may be a list of urls, see also
methods urls and add_url.  Nothing special is guaranteed about the
primary URL other than that it's the first one returned by the back end.

Every result is required to have at least one URL.


urls
----

Return a reference to an array of urls.  There is also a primary URL
(url).  See also add_url.


add_url
-------

Add a URL to the list.


related_urls, add_related_url, related_titles, add_related_title
----------------------------------------------------------------

Analgous to urls, these functions provide lists of related URLs and
their titles.  These point to things the search engine thinks you might
want (for example, see Infoseek).


title, description, score, change_date, index_date, size, raw
-------------------------------------------------------------

Set or get attributes of the result.

None of these attributes is guaranteed to be provided by a given
back-end.  If an attribute is not provided its method will return undef.

Typical contents of these attributes:

description A brief description of result. Often the first few sentences of the document.
score A back-end specific, numeric ``score'' of the search result. The exact range of scores is search-engine specific. Usually larger scores are better, but this is no longer required. See normalized_score for a back-end independent score.
normalized_score A back-end independent score of the search result. The range of this score is between 0 and 1000. Higher values indicate better quality results.
change_date When the result was last changed.
index_date When the search engine indexed the result.
size The size of the result, in bytes.
raw The raw HTML for the entire result.



File: pm.info, Node: X11/Auth, Next: X11/Keysyms, Prev: WWW/SearchResult, Up: Module List

Perl module to read X11 authority files
***************************************



NAME
====

X11::Auth - Perl module to read X11 authority files


SYNOPSIS
========

     require X11::Auth;
     $a = new X11::Auth;
     ($auth_type, $auth_data) = $a->get_by_host($host, $disp_num);


DESCRIPTION
===========

This module is an approximate perl replacement for the libXau C library
and the xauth(1) program. It reads and interprets the files (usually
'~/.Xauthority') that hold authorization data used in connecting to X
servers. Since it was written mainly for the use of X11::Protocol, its
functionality is currently restricted to reading, not writing, of these
files.


METHODS
=======


new
---

     $auth = X11::Auth->new;
     $auth = X11::Auth->open($filename);

Open an authority file, and create an object to handle it. The filename
will be taken from the XAUTHORITY environment variable, if present, or
'.Xauthority' in the user's home directory, or it may be overridden by
an argument. 'open' may be used as a synonym.


get_one
-------

     ($family, $host_addr, $display_num, $auth_name, $auth_data)
        = $auth->get_one;

Read one entry from the file. Returns a null list at end of file.
$family is usually 'Internet' or 'Local', and $display_num can be any
string.


get_all
-------

     @auth_data = $auth->get_all;

Read all of the entries in the file. Each member of the array returned
is an array ref similar to the list returned by get_one().


get_by_host
-----------

     ($auth_name, $auth_data)
        = $auth->get_by_host($host, $family, $display_num);

Get authentication data for a connection of type $family to display
$display_num on $host. If $family is 'Internet', the host will be
translated into an appropriate address by gethostbyname().


COMPATIBILITY
=============

The following table shows the (rough) correspondence between libXau
calls and X11::Auth methods:

     libXau                     X11::Auth
     ------                     ---------
     XauFileName                $ENV{XAUTHORITY}
                                || "$ENV{HOME}/.Xauthority"
     fopen(XauFileName(), "rb") $auth = new X11::Auth
     XauReadAuth                $auth->get_one
     XauWriteAuth
     XauGetAuthByAddr           $auth->get_by_host
     XauGetBestAuthByAddr 
     XauLockAuth
     XauUnlockAuth
     XauDisposeAuth


AUTHOR
======

Stephen McCamant <alias@mcs.com>


SEE ALSO
========

`perl(1)' in this node, *Note X11/Protocol: X11/Protocol,, `Xau(3)' in
this node, `xauth(1)' in this node, lib/Xau/README in the X11 source
distribution.




File: pm.info, Node: X11/Keysyms, Next: X11/Protocol, Prev: X11/Auth, Up: Module List

Perl module for names of X11 keysyms
************************************



NAME
====

X11::Keysyms - Perl module for names of X11 keysyms


SYNOPSIS
========

     use X11::Keysyms '%Keysyms', qw(MISCELLANY XKB_KEYS LATIN1);
     %Keysyms_name = reverse %Keysyms;
     $ks = $Keysyms{'BackSpace'};
     $name = $Keysysms_name{$ks};


DESCRIPTION
===========

This module exports a hash mapping the names of X11 keysyms, such as 'A'
or 'Linefeed' or 'Hangul_J_YeorinHieuh' onto the numbers that represent
them. The first argument to 'use' is the name of the variable the hash
should be exported into, and the rest are names of subsets of the
keysysms to export: one or more of

     'MISCELLANY', 'XKB_KEYS', '3270', 'LATIN1', 'LATIN2',
     'LATIN3', 'LATIN4', 'KATAKANA', 'ARABIC', 'CYRILLIC',
     'GREEK', 'TECHNICAL', 'SPECIAL', 'PUBLISHING', 'APL',
     'HEBREW', 'THAI', 'KOREAN'.

If this list is omitted, the list

     'MISCELLANY', 'XKB_KEYS', 'LATIN1', 'LATIN2', 'LATIN3',
     'LATIN4', 'GREEK'

is used.


AUTHOR
======

This module was generated semi-automatically by Stephen McCamant
(<alias@mcs.com>) from the header file 'X11/keysymdef.h', distributed by
the X Consortium.


SEE ALSO
========

`perl(1)' in this node,
*Note X11/Protocol: X11/Protocol,,
*X Window System Protocol (X Version 11)*.




File: pm.info, Node: X11/Protocol, Next: X11/Protocol/Connection, Prev: X11/Keysyms, Up: Module List

Perl module for the X Window System Protocol, version 11
********************************************************



NAME
====

X11::Protocol - Perl module for the X Window System Protocol, version 11


SYNOPSIS
========

     use X11::Protocol;
     $x = X11::Protocol->new();
     $win = $x->new_rsrc;
     $x->CreateWindow($win, $x->root, 'InputOutput',
     		   $x->root_depth, 'CopyFromParent',
     		   ($x_coord, $y_coord), $width,
     		   $height, $border_w);  
     ...


DESCRIPTION
===========

X11::Protocol is a client-side interface to the X11 Protocol (see X(1)
for information about X11), allowing perl programs to display windows
and graphics on X11 servers.

A full description of the protocol is beyond the scope of this documentation;
for complete information, see the *X Window System Protocol, X Version 11*,
available as Postscript or *roff source from `ftp://ftp.x.org', or
*Volume 0: X Protocol Reference Manual* of O'Reily & Associates's series of
books about X (ISBN 1-56592-083-X, `http://www.ora.com'), which contains
most of the same information.


DISCLAIMER
==========

``The protocol contains many management mechanisms that are not intended
for normal applications.  Not all mechanisms are needed to build a
particular user interface.  It is important to keep in mind that the
protocol is intended to provide mechanism, not policy.'' -- Robert
W. Scheifler


BASIC METHODS
=============


new
---

     $x = X11::Protocol->new();
     $x = X11::Protocol->new($display_name);
     $x = X11::Protocol->new($connection);
     $x = X11::Protocol->new($display_name, [$auth_type, $auth_data]);
     $x = X11::Protocol->new($connection, [$auth_type, $auth_data]);

Open a connection to a server. $display_name should be an X display
name, of the form 'host:display_num.screen_num'; if no arguments are
supplied, the contents of the DISPLAY environment variable are
used. Alternatively, a pre-opened connection, of one of the
X11::Protocol::Connection classes (see
*Note X11/Protocol/Connection: X11/Protocol/Connection,,
*Note X11/Protocol/Connection/FileHandle: X11/Protocol/Connection/FileHandle,,
*Note X11/Protocol/Connection/Socket: X11/Protocol/Connection/Socket,,
*Note X11/Protocol/Connection/UNIXFH: X11/Protocol/Connection/UNIXFH,,
*Note X11/Protocol/Connection/INETFH: X11/Protocol/Connection/INETFH,,
*Note X11/Protocol/Connection/UNIXSocket: X11/Protocol/Connection/UNIXSocket,,
*Note X11/Protocol/Connection/INETSocket: X11/Protocol/Connection/INETSocket,) can be given. The
authorization data is obtained using X11::Auth or the second
argument. If the display is specified by $display_name, rather than
$connection, a choose_screen() is also performed, defaulting to screen 0
if the '.screen_num' of the display name is not present.  Returns the
new protocol object.


new_rsrc
--------

     $x->new_rsrc;

Returns a new resource identifier. A unique resource ID is required for
every object that the server creates on behalf of the client: windows,
fonts, cursors, etc. (IDs are chosen by the client instead of the server
for efficiency -- the client doesn't have to wait for the server to
acknowledge the creation before starting to use the object).


handle_input
------------

     $x->handle_input;

Get one chunk of information from the server, and do something with it. If it's
an error, handle it using the protocol object's handler ('error_handler'
-- default is kill the program with an explanatory message). If it's an event,
pass it to the chosen event handler, or put it in a queue if the handler
is 'queue'. If it's a reply to a request, save using the object's
'replies' hash for further processing.


atom_name
---------

     $name = $x->atom_name($atom);

Return the string corresponding to the atom $atom. This is similar to
the GetAtomName request, but caches the result for efficiency.


atom
----

     $atom = $x->atom($name);

The inverse operation; Return the (numeric) atom correspoding to $name.
This is similar to the InternAtom request, but caches the result.


SYMBOLIC CONSTANTS
==================

Generally, symbolic constants used by the protocol, like
'CopyFromParent' or 'PieSlice' are passed to methods as strings, and
converted into numbers by the module.  Their names are the same as those
in the protocol specification, including capitalization, but with
hyphens ('-') changed to underscores ('_') to look more perl-ish. If you
want to do the conversion yourself for some reason, the following
methods are avaliable:


num
---

     $num = $x->num($type, $str)

Given a string representing a constant and a string specifying what type
of constant it is, return the corresponding number. $type should be a
name like 'VisualClass' or 'GCLineStyle'. If the name is not recognized,
it is returned intact.


interp
------

     $name = $x->interp($type, $num)

The inverse operation; given a number and string specifying its type,
return a string representing the constant.

Here is a list of available constant types:

     AccessMode, AllowEventsMode, AutoRepeatMode, BackingStore,
     BitGravity, Bool, ChangePropertyMode, CirculateDirection,
     CirculatePlace, Class, ClipRectangleOrdering, CloseDownMode,
     ColormapNotifyState, CoordinateMode, CrossingNotifyDetail,
     CrossingNotifyMode, DeviceEvent, DrawDirection, Error, EventMask,
     Events, FocusDetail, FocusMode, GCArcMode, GCCapStyle, GCFillStyle,
     GCFunction, GCJoinStyle, GCLineStyle, GCSubwindowMode, GrabStatus,
     HostChangeMode, HostFamily, ImageFormat, InputFocusRevertTo,
     KeyMask, LedMode, MapState, MappingChangeStatus,
     MappingNotifyRequest, PointerEvent, PolyShape, PropertyNotifyState,
     Request, ScreenSaver, ScreenSaverAction, Significance,
     SizeClass, StackMode, SyncMode, VisibilityState, VisualClass,
     WinGravity


choose_screen
-------------

     $x->choose_screen($screen_num);

Indicate that you prefer to use a particular screen of the
display. Per-screen information, such as 'root', 'width_in_pixels', and
'white_pixel' will be made avaliable as

     $x->{'root'}

instead of

     $x->{'screens'}[$screen_num]{'root'}


SERVER INFORMATION
==================

At connection time, the server sends a large amount of information about
itself to the client. This information is stored in the protocol object
for future reference. It can be read directly, like

     $x->{'release_number'}

or, for object oriented True Believers, using a method:

     $x->release_number

The method method also has a one argument form for setting variables,
but it isn't really useful for some of the more complex structures.

Here is an example of what the object's information might look like:

     'connection' => X11::Connection::UNIXSocket(0x814526fd),
     'byte_order' => 'l',
     'protocol_major_version' => 11,
     'protocol_minor_version' => 0,
     'authorization_protocol_name' => 'MIT-MAGIC-COOKIE-1',
     'release_number' => 3110,
     'resource_id_base' => 0x1c000002,
     'motion_buffer_size' => 0,
     'maximum_request_length' => 65535, # units of 4 bytes
     'image_byte_order' => 'LeastSiginificant',
     'bitmap_bit_order' => 'LeastSiginificant',
     'bitmap_scanline_unit' => 32,
     'bitmap_scanline_pad' => 32,
     'min_keycode' => 8,
     'max_keycode' => 134,
     'vendor' => 'The XFree86 Project, Inc',
     'pixmap_formats' => {1 => {'bits_per_pixel' => 1,
     			     'scanline_pad' => 32},
                          8 => {'bits_per_pixel' => 8,
     			     'scanline_pad' => 32}},
     'screens' => [{'root' => 43, 'width_in_pixels' => 800,
                    'height_in_pixels' => 600,
                    'width_in_millimeters' => 271,
                    'height_in_millmerters' => 203,
                    'root_depth' => 8,
                    'root_visual' => 34,
                    'default_colormap' => 33,
                    'white_pixel' => 0, 'black_pixel' => 1,
                    'min_installed_maps' => 1,
                    'max_installed_maps' => 1,
                    'backing_stores' => 'Always',
                    'save_unders' => 1,
                    'current_input_masks' => 0x58003d,
                    'allowed_depths' =>
                       [{'depth' => 1, 'visuals' => []},
                        {'depth' => 8, 'visuals' => [
                           {'visual_id' => 34, 'blue_mask' => 0,
                            'green_mask' => 0, 'red_mask' => 0, 
                            'class' => 'PseudoColor',
                            'bits_per_rgb_value' => 6,
                            'colormap_entries' => 256},
                           {'visual_id' => 35, 'blue_mask' => 0xc0,
                            'green_mask' => 0x38, 'red_mask' => 0x7, 
                            'class' => 'DirectColor',
                            'bits_per_rgb_value' => 6,
                            'colormap_entries' => 8}, ...]}]],
     'visuals' => {34 => {'depth' => 8, 'class' => 'PseudoColor',
                          'red_mask' => 0, 'green_mask' => 0,
                          'blue_mask'=> 0, 'bits_per_rgb_value' => 6,
                          'colormap_entries' => 256},
                   35 => {'depth' => 8, 'class' => 'DirectColor',
                          'red_mask' => 0x7, 'green_mask' => 0x38,
                          'blue_mask'=> 0xc0, 'bits_per_rgb_value' => 6,
                          'colormap_entries' => 8}, ...}
     'error_handler' => &\X11::Protocol::default_error_handler,
     'event_handler' => sub {}


REQUESTS
========


request
-------

     $x->request('CreateWindow', ...);
     $x->req('CreateWindow', ...);
     $x->CreateWindow(...);

Send a protocol request to the server, and get the reply. For names of
and information about individual requests, see below and/or the protocol
reference manual.


add_reply
---------

     $x->add_reply($sequence_num, \$var);

Add a stub for an expected reply to the object's 'replies' hash. When a
reply numbered $sequence_num comes, it will be stored in $var.


delete_reply
------------

     $x->delete_reply($sequence_num);

Delete the entry in 'replies' for the specified reply. (This should be
done after the reply is recieved).


send
----

     $x->send('CreateWindow', ...);

Send a request, but do not wait for a reply. You must handle the reply,
if any, yourself, using add_reply(), handle_input(), delete_reply(), and
unpack_reply(), generally in that order.


unpack_reply
------------

     $x->unpack_reply('GetWindowAttributes', $data);

Interpret the raw reply data $data, according to the reply format for
the named request. Returns data in the same format as
`request($request_name, ...)'.

This section includes only a short calling summary for each request; for
full descriptions, see the protocol standard. Argument order is usually
the same as listed in the spec, but you generally don't have to pass
lengths of strings or arrays, since perl keeps track. Symbolic constants
are generally passed as strings. Most replies are returned as lists, but
when there are many values, a hash is used. Lists usually come last;
when there is more than one, each is passed by reference. In lists of
multi-part structures, each element is a list ref. Parenthesis are
inserted in arg lists for clarity, but are optional. Requests are listed
in order by major opcode, so related requests are usually close
together. Replies follow the '=>'.

     $x->CreateWindow($wid, $parent, $class, $depth, $visual, ($x, $y),
     		   $width, $height, $border_width,
      		   'attribute' => $value, ...)

     $x->ChangeWindowAttributes($window, 'attribute' => $value, ...)

     $x->GetWindowAttributes($window)
     =>
     ('backing_store' => $backing_store, ...)

This is an example of a return value that is meant to be assigned to a
hash.

     $x->DestroyWindow($win)

     $x->DestroySubwindows($win)

     $x->ChangeSaveSet($window, $mode)

     $x->ReparentWindow($win, $parent, ($x, $y))

     $x->MapWindow($win)

     $x->MapSubwindows($win)

     $x->UnmapWindow($win)

     $x->UnmapSubwindows($win)

     $x->ConfigureWindow($win, 'attribute' => $value, ...)

     $x->CirculateWindow($win, $direction)

Note that this request actually circulates the subwindows of $win, not
the window itself.

     $x->GetGeometry($drawable)
     =>
     ('root' => $root, ...)

     $x->QueryTree($win)
     =>
     ($root, $parent, @kids)

     $x->InternAtom($name, $only_if_exists)
     =>
     $atom

     $x->GetAtomName($atom)
     =>
     $name

     $x->ChangeProperty($window, $property, $type, $format, $mode, $data)

     $x->DeleteProperty($win, $atom)

     $x->GetProperty($window, $property, $type, $offset, $length, $delete)
     =>
     ($value, $type, $format, $bytes_after)

Notice that the value comes first, so you can easily ignore the rest.

     $x->ListProperties($window)
     =>
     (@atoms)

     $x->SetSelectionOwner($selection, $owner, $time)

     $x->GetSelectionOwner($selection)
     =>
     $owner

     $x->ConvertSelection($selection, $target, $property, $requestor, $time)

     $x->SendEvent($destination, $propagate, $event_mask, $event)

The $event argument should be the result of a pack_event() (see
`"EVENTS"' in this node)

     $x->GrabPointer($grab_window, $owner_events, $event_mask,
     		  $pointer_mode, $keyboard_mode, $confine_to,
     		  $cursor, $time)
     =>
     $status

     $x->UngrabPointer($time)

     $x->GrabButton($modifiers, $button, $grab_window, $owner_events,
     		 $event_mask, $pointer_mode, $keyboard_mode,
     		 $confine_to, $cursor)

     $x->UngrabButton($modifiers, $button, $grab_window)

     $x->ChangeActivePointerGrab($event_mask, $cursor, $time)

     $x->GrabKeyboard($grab_window, $owner_events, $pointer_mode,
     		   $keyboard_mode, $time)
     =>
     $status

     $x->UngrabKeyboard($time)

     $x->GrabKey($key, $modifiers, $grab_window, $owner_events,
     	      $pointer_mode, $keyboard_mode)

     $x->UngrabKey($key, $modifiers, $grab_window)

     $x->AllowEvents($mode, $time)

     $x->GrabServer

     $x->UngrabServer

     $x->QueryPointer($window)
     =>
     ('root' => $root, ...)

     $x->GetMotionEvents($start, $stop, $window)
     =>
     ([$time, ($x, $y)], [$time, ($x, $y)], ...)

     $x->TranslateCoordinates($src_window, $dst_window, $src_x, $src_y)
     =>
     ($same_screen, $child, $dst_x, $dst_y)

     $x->WarpPointer($src_window, $dst_window, $src_x, $src_y, $src_width,
     		  $src_height, $dst_x, $dst_y)

     $x->SetInputFocus($focus, $revert_to, $time)

     $x->GetInputFocus
     =>
     ($focus, $revert_to)

     $x->QueryKeymap
     =>
     $keys

$keys is a bit vector, so you should use vec() to read it.

     $x->OpenFont($fid, $name)

     $x->CloseFont($font)

     $x->QueryFont($font)
     =>
     ('min_char_or_byte2' => $min_char_or_byte2,
      ..., 
      'min_bounds' =>
      [$left_side_bearing, $right_side_bearing, $character_width, $ascent,
       $descent, $attributes],
      ...,
      'char_infos' =>
      [[$left_side_bearing, $right_side_bearing, $character_width, $ascent,
        $descent, $attributes], 
       ...], 
      'properties' => {$prop => $value, ...}
      )

     $x->QueryTextExtents($font, $string)
     =>
     ('draw_direction' => $draw_direction, ...)

     $x->ListFonts($pattern, $max_names)
     =>
     @names

     $x->ListFontsWithInfo($pattern, $max_names)
     =>
     ({'name' => $name, ...}, {'name' => $name, ...}, ...)

The information in each hash is the same as the the information returned
by QueryFont, but without per-character size information. This request
is special in that it is the only request that can have more than one
reply.  This means you should probably only use request() with it, not
send(), as the reply counting is complicated. Luckily, you never need
this request anyway, as its function is completely duplicated by other
requests.

     $x->SetFontPath(@strings)

     $x->GetFontPath
     =>
     @strings

     $x->CreatePixmap($pixmap, $drawable, $depth, $width, $height)

     $x->FreePixmap($pixmap)

     $x->CreateGC($cid, $drawable, 'attribute' => $value, ...)

     $x->ChangeGC($gc, 'attribute' => $value, ...)

     $x->CopyGC($src, $dest, 'attribute', 'attribute', ...)

     $x->SetDashes($gc, $dash_offset, (@dashes))

     $x->SetClipRectangles($gc, ($clip_x_origin, $clip_y_origin),
     			$ordering, [$x, $y, $width, $height], ...)

     $x->ClearArea($window, ($x, $y), $width, $height, $exposures)

     $x->CopyArea($src_drawable, $dst_drawable, $gc, ($src_x, $src_y),
     	       $width, $height, ($dst_x, $dst_y))

     $x->CopyPlane($src_drawable, $dst_drawable, $gc, ($src_x, $src_y),
     		$width, $height, ($dst_x, $dst_y), $bit_plane)

     $x->PolyPoint($drawable, $gc, $coordinate_mode,
     		($x, $y), ($x, $y), ...)

     $x->PolyLine($drawable, $gc, $coordinate_mode,
     	       ($x, $y), ($x, $y), ...)

     $x->PolySegment($drawable, $gc, ($x, $y) => ($x, $y),
     		  ($x, $y) => ($x, $y), ...)

     $x->PolyRectangle($drawable, $gc,
     		    [($x, $y), $width, $height], ...)

     $x->PolyArc($drawable, $gc,
     	      [($x, $y), $width, $height, $angle1, $angle2], ...)

     $x->FillPoly($drawable, $gc, $shape, $coordinate_mode,
     	       ($x, $y), ...)

     $x->PolyFillRectangle($drawable, $gc,
     			[($x, $y), $width, $height], ...)

     $x->PolyFillArc($drawable, $gc,
     		  [($x, $y), $width, $height, $angle1, $angle2], ...)

     $x->PutImage($drawable, $gc, $depth, $width, $height,
     	       ($dst_x, $dst_y), $left_pad, $format, $data)

Currently, the module has no code to handle the various bitmap formats
that the server might specify. Therefore, this request will not work
portably without a lot of work.

     $x->GetImage($drawable, ($x, $y), $width, $height, $plane_mask,
     	       $format)

     $x->PolyText8($drawable, $gc, ($x, $y),
     		($font OR [$delta, $string]), ...)

     $x->PolyText16($drawable, $gc, ($x, $y),
     		 ($font OR [$delta, $string]), ...)

     $x->ImageText8($drawable, $gc, ($x, $y), $string)

     $x->ImageText16($drawable, $gc, ($x, $y), $string)

     $x->CreateColormap($mid, $visual, $window, $alloc)

     $x->FreeColormap($cmap)

     $x->CopyColormapAndFree($mid, $src_cmap)

     $x->InstallColormap($cmap)

     $x->UninstallColormap($cmap)

     $x->ListInstalledColormaps($window)
     =>
     @cmaps

     $x->AllocColor($cmap, ($red, $green, $blue))
     =>
     ($pixel, ($red, $green, $blue))

     $x->AllocNamedColor($cmap, $name)
     =>
     ($pixel, ($exact_red, $exact_green, $exact_blue),
      ($visual_red, $visual_green, $visual_blue))

     $x->AllocColorCells($cmap, $colors, $planes, $contiguous)
     =>
     ([@pixles], [@masks])

     $x->AllocColorPlanes($cmap, $colors, ($reds, $greens, $blues),
     		       $contiguous)
     =>
     (($red_mask, $green_mask, $blue_mask), @pixels)

     $x->FreeColors($cmap, $plane_mask, @pixels)

     $x->StoreColors($cmap, [$pixel, $red, $green, $blue, $do_mask], ...)

The 1, 2, and 4 bits in $mask are do-red, do-green, and do-blue. $mask
can be omitted, defaulting to 7, the usual case -- change the whole
color.

     $x->StoreNamedColor($cmap, $pixel, $name, $do_mask)

$do_mask has the same interpretation as above, but is mandatory.

     $x->QueryColors($cmap, @pixels)
     =>
     ([$red, $green, $blue], ...)

     $x->LookupColor($cmap, $name)
     =>
     (($exact_red, $exact_green, $exact_blue),
      ($visual_red, $visual_green, $visual_blue)) 

     $x->CreateCursor($cid, $source, $mask,
     		   ($fore_red, $fore_green, $fore_blue),
     		   ($back_red, $back_green, $back_blue),
     		   ($x, $y))

     $x->CreateGlyphCursor($cid, $source_font, $mask_font,
     			$source_char, $mask_char,
     			($fore_red, $fore_green, $fore_blue),
     			($back_red, $back_green, $back_blue))
			
     $x->FreeCursor($cursor)

     $x->RecolorCursor($cursor, ($fore_red, $fore_green, $fore_blue),
     		    ($back_red, $back_green, $back_blue))

     $x->QueryBestSize($class, $drawable, $width, $height)
     =>
     ($width, $height)

     $x->QueryExtension($name)
     =>
     ($major_opcode, $first_event, $first_error)

If the extension is not present, an empty list is returned.

     $x->ListExtensions
     =>
     (@names)

     $x->ChangeModifierMapping($first_keycode, $keysysms_per_keycode,
     			    @keysyms)

     $x->GetKeyboardMapping($first_keycode, $count)
     =>
     ($keysysms_per_keycode, [$keysym, ...], [$keysym, ...], ...)

     $x->ChangeKeyboardControl('attribute' => $value, ...)

     $x->GetKeyboardControl
     =>
     ('global_auto_repeat' => $global_auto_repeat, ...)

     $x->Bell($percent)

     $x->ChangePointerControl($do_acceleration, $do_threshold,
     			   $acceleration_numerator,
     			   $acceleration_denominator, $threshold)

     $x->GetPointerControl
     =>
     ($accerleration_numerator, $acceleration_denominator, $threshold)

     $x->SetScreenSaver($timeout, $interval, $prefer_blanking,
     		     $allow_exposures)

     $x->GetScreenSaver
     =>
     ($timeout, $interval, $prefer_blanking, $allow_exposures)

     $x->ChangeHosts($mode, $host_family, $host_address) 

     $x->ListHosts
     =>
     ($mode, [$family, $host], ...)

     $x->SetAccessControl($mode)

     $x->SetCloseDownMode($mode)

     $x->KillClient($resource)

     $x->RotateProperties($win, $delta, @props)

     $x->ForceScreenSaver($mode)

     $x->SetPointerMapping(@map)
     =>
     $status

     $x->GetPointerMapping
     =>
     @map  

     $x->SetModifierMapping(@keycodes)
     =>
     $status

     $x->GetModiferMapping
     =>
     @keycodes

     $x->NoOperation($length)

$length specifies the length of the entire useless request, in four byte
units, and is optional.


EVENTS
======

To receive events, first set the 'event_mask' attribute on a window to
indicate what types of events you desire (see `"pack_event_mask"' in
this node). Then, set the protocol object's 'event_handler' to a
subroutine reference that will handle the events. Alternatively, set
'event_handler' to 'queue', and retrieve events using
dequeue_event(). In both cases, events are returned as a hash. For
instance, a typical MotionNotify event might look like this:

     %event = ('name' => 'MotionNotify', 'sequence_number' => 12,
               'state' => 0, 'event' => 58720256, 'root' => 43,
               'child' => None, 'same_screen' => 1, 'time' => 966080746,
               'detail' => 'Normal', 'event_x' => 10, 'event_y' => 3,
               'code' => 6, 'root_x' => 319, 'root_y' => 235)


pack_event_mask
---------------

     $mask = $x->pack_event_mask('ButtonPress', 'KeyPress', 'Exposure');

Make an event mask (suitable as the 'event_mask' of a window) from a
list of strings specifying event types.


unpack_event_mask
-----------------

     @event_types = $x->unpack_event_mask($mask);

The inverse operation; convert an event mask obtained from the server
into a list of names of event categories.


dequeue_event
-------------

     %event = $x->dequeue_event;

If there is an event waiting in the queue, return it.


next_event
----------

     %event = $x->next_event;

Like Xlib's XNextEvent(), this function is equivalent to

     $x->handle_input until %event = dequeue_event;


pack_event
----------

     $data = $x->pack_event(%event);

Given an event in hash form, pack it into a string. This is only useful
as an argument to SendEvent().


unpack_event
------------

     %event = $x->unpack_event($data);

The inverse operation; given the raw data for an event (32 bytes),
unpack it into hash form. Normally, this is done automatically.


EXTENSIONS
==========

Protocol extensions add new requests, event types, and error types to
the protocol. Support for them is compartmentalized in modules in the
X11::Protocol::Ext:: hierarchy. For an example, see
`X11::Protocol::Ext:SHAPE' in this node. You can tell if the module has
loaded an extension by looking at

     $x->{'ext'}{$extension_name}

If the extension has been initialized, this value will be an array
reference, [$major_request_number, $first_event_number,
$first_error_number, $obj], where $obj is an object containing
information private to the extension.


init_extension
--------------

     $x->init_extension($name);

Initialize an extension: query the server to find the extension's
request number, then load the corresponding module. Returns 0 if the
server does not support the named extension, or if no module to
interface with it exists.


init_extensions
---------------

     $x->init_extensions;

Initialize protocol extensions. This does a ListExtensions request, then
calls init_extension() for each extension that the server supports.


WRITING EXTENSIONS
==================

Internally, the X11::Protocol module is table driven. All an extension
has to do is to add new add entries to the protocol object's tables. An
extension module should `use X11::Protocol', and should define an new()
method

     X11::Protocol::Ext::NAME
       ->new($x, $request_num, $event_num, $error_num)

where $x is the protocol object and $request_num, $event_num and
$error_num are the values returned by QueryExtension().

The new() method should add new types of constant like

     $x->{'ext_const'}{'ConstantType'} = ['Constant', 'Constant', ...]

and set up the corresponding name to number translation hashes like

     $x->{'ext_const_num'}{'ConstType'} =
       {make_num_hash($x->{'ext_const'}{'ConstType'})}

Event names go in

     $x->{'ext_const'}{'Events'}[$event_number]

while specifications for event contents go in

     $x->{'ext_event'}[$event_number]

each element of which is either `[\&unpack_sub, \&pack_sub]' or
`[$pack_format, $field, $field, ...]', where each $field is `'name'',
`['name', 'const_type']', or `['name', ['special_name_for_zero',
'special_name_for_one']]', where `'special_name_for_one'' is optional.

Finally,

     $x->{'ext_request'}{$major_request_number}

should be an array of arrays, with each array either `[$name, \&packit]'
or `[$name, \&packit, \&unpackit]', and

     $x->{'ext_request_num'}{$request_name}

should be initialized with `[$minor_num, $major_num]' for each request
the extension defines. For examples of code that does all of this, look
at X11::Protocol::Ext::SHAPE.

X11::Protocol exports several functions that might be useful in
extensions (note that these are *not* methods).


padding
-------

     $p = padding $x;

Given an integer, compute the number need to round it up to a multiple
of 4.  For instance, `padding(5)' is 3.


pad
---

     $p = pad $str;

Given a string, return the number of extra bytes needed to make a
multiple of 4. Equivalent to `padding(length($str))'.


padded
------

     $data = pack(padded($str), $str);

Return a format string, suitable for pack(), for a string padded to a
multiple of 4 bytes. For instance, `pack(padded('Hello'), 'Hello')'
gives `"Hello\0\0\0"'.


hexi
----

     $str = hexi $n;

Format a number in hexidecimal, and add a "0x" to the front.


make_num_hash
-------------

     %hash = make_num_hash(['A', 'B', 'C']);

Given a reference to a list of strings, return a hash mapping the
strings onto numbers representing their position in the list, as used by
`$x->{'ext_const_num'}'.


BUGS
====

This module is too big (~2500 lines), too slow (10 sec to load on a slow
machine), too inefficient (request args are copied several times), and
takes up too much memory (3000K for basicwin).

If you have more than 65535 replies outstanding at once, sequence
numbers can collide.

The protocol is too complex.


AUTHOR
======

Stephen McCamant <alias@mcs.com>.


SEE ALSO
========

`perl(1)' in this node,
`X(1)' in this node, 
*Note X11/Keysyms: X11/Keysyms,, 
*Note X11/Protocol/Ext/SHAPE: X11/Protocol/Ext/SHAPE,,
*Note X11/Protocol/Ext/BIG_REQUESTS: X11/Protocol/Ext/BIG_REQUESTS,,
*Note X11/Auth: X11/Auth,,
*X Window System Protocol (X Version 11)*,
*Inter-Client Communications Conventions Manual*,
*X Logical Font Description Conventions*.




File: pm.info, Node: X11/Protocol/Connection, Next: X11/Protocol/Connection/FileHandle, Prev: X11/Protocol, Up: Module List

Perl module abstract base class for X11 client to server connections
********************************************************************



NAME
====

X11::Protocol::Connection - Perl module abstract base class for X11
client to server connections


SYNOPSIS
========

     # In connection object module
     package X11::Protocol::Connection::CarrierPigeon;
     use X11::Protocol::Connection;
     @ISA = ('X11::Protocol::Connection');
     sub open { ... }
     sub give { ... }
     sub get { ... }
     sub fh { ... }
     ...

     # In program
     $connection = X11::Protocol::Connection::CarrierPigeon
       ->open($host, $display_number);
     $x = X11::Protocol->new($connection);

     $connection->give($data);

     $reply = unpack("I", $connection->get(4));

     use IO::Select;
     $sel = IO::select->new($connection->fh);
     if ($sel->can_read == $connection->fh) ...


DESCRIPTION
===========

This module is an abstract base class for the various
X11::Protocol::Connection::* modules that provide connections to X
servers for the X11::Protocol module. It provides stubs for the
following methods:


open
----

     $conn = X11::Protocol::Connection::Foo->open($host, $display_num)

Open a connection to the specified display (numbered from 0) on the
specified $host.


give
----

     $conn->give($data)

Send the given data to the server. Normally, this method is used only by
the protocol module itself.


get
---

     $data = $conn->get($n)

Read $n bytes of data from the server. Normally, this method is used
only by the protocol module itself.


fh
--

     $filehandle = $conn->fh

Return an object suitable for use as a filehandle. This is mainly useful
for doing select() and other such system calls.


AUTHOR
======

Stephen McCamant <alias@mcs.com>.


SEE ALSO
========

`perl(1)' in this node,
*Note X11/Protocol: X11/Protocol,,
*Note X11/Protocol/Connection/Socket: X11/Protocol/Connection/Socket,,
*Note X11/Protocol/Connection/FileHandle: X11/Protocol/Connection/FileHandle,,
*Note X11/Protocol/Connection/INETSocket: X11/Protocol/Connection/INETSocket,,
*Note X11/Protocol/Connection/UNIXSocket: X11/Protocol/Connection/UNIXSocket,,
*Note X11/Protocol/Connection/INETFH: X11/Protocol/Connection/INETFH,,
*Note X11/Protocol/Connection/UNIXFH: X11/Protocol/Connection/UNIXFH,.




File: pm.info, Node: X11/Protocol/Connection/FileHandle, Next: X11/Protocol/Connection/INETFH, Prev: X11/Protocol/Connection, Up: Module List

Perl module base class for FileHandle-based X11 connections
***********************************************************



NAME
====

X11::Protocol::Connection::FileHandle - Perl module base class for
FileHandle-based X11 connections


SYNOPSIS
========

     package X11::Protocol::Connection::WeirdFH;
     use X11::Protocol::Connection::FileHandle;
     @ISA = ('X11::Protocol::Connection::FileHandle')


DESCRIPTION
===========

This module defines get(), give() and fh() methods common to
X11::Protocol::Connection types that are based on the FileHandle
package. They expect the object they are called with to be a reference
to a FileHandle.


AUTHOR
======

Stephen McCamant <alias@mcs.com>.


SEE ALSO
========

`perl(1)' in this node,
*Note X11/Protocol: X11/Protocol,,
*Note X11/Protocol/Connection/INETFH: X11/Protocol/Connection/INETFH,,
*Note X11/Protocol/Connection/UNIXFH: X11/Protocol/Connection/UNIXFH,,
*Note FileHandle: FileHandle,.




File: pm.info, Node: X11/Protocol/Connection/INETFH, Next: X11/Protocol/Connection/INETSocket, Prev: X11/Protocol/Connection/FileHandle, Up: Module List

Perl module for FileHandle-based TCP/IP X11 connections
*******************************************************



NAME
====

X11::Connection::INETFH - Perl module for FileHandle-based TCP/IP X11
connections


SYNOPSIS
========

     use X11::Protocol;
     use X11::Connection::INETFH;
     $conn = X11::Connection::INETFH->open($host, $display_number);
     $x = X11::Protocol->new($conn); 


DESCRIPTION
===========

This module is used by X11::Protocol to establish a connection and
communicate with a server over an internet-type TCP/IP socket
connection, using the FileHandle module.


AUTHOR
======

Stephen McCamant <alias@mcs.com>.


SEE ALSO
========

`perl(1)' in this node,
*Note X11/Protocol: X11/Protocol,,
`X11::Connection::UNIXFH' in this node,
`X11::Connection::FileHandle' in this node, 
*Note FileHandle: FileHandle,.




