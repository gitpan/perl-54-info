Info file: pm.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `bigpm.texi'
using `texinfmt.el' version 2.32 of 19 November 1993.





File: pm.info, Node: CPAN, Next: CPAN/FirstTime, Prev: CGI_Lite, Up: Module List

query, download and build perl modules from CPAN sites
******************************************************



NAME
====

CPAN - query, download and build perl modules from CPAN sites


SYNOPSIS
========

Interactive mode:

     perl -MCPAN -e shell;

Batch mode:

     use CPAN;

     autobundle, clean, install, make, recompile, test


DESCRIPTION
===========

The CPAN module is designed to automate the make and install of perl
modules and extensions. It includes some searching capabilities and
knows how to use Net::FTP or LWP (or lynx or an external ftp client) to
fetch the raw data from the net.

Modules are fetched from one or more of the mirrored CPAN (Comprehensive
Perl Archive Network) sites and unpacked in a dedicated directory.

The CPAN module also supports the concept of named and versioned
'bundles' of modules. Bundles simplify the handling of sets of related
modules. See BUNDLES below.

The package contains a session manager and a cache manager. There is no
status retained between sessions. The session manager keeps track of
what has been fetched, built and installed in the current session. The
cache manager keeps track of the disk space occupied by the make
processes and deletes excess space according to a simple FIFO mechanism.

All methods provided are accessible in a programmer style and in an
interactive shell style.


Interactive Mode
----------------

The interactive mode is entered by running

     perl -MCPAN -e shell

which puts you into a readline interface. You will have most fun if you
install Term::ReadKey and Term::ReadLine to enjoy both history and
completion.

Once you are on the command line, type 'h' and the rest should be
self-explanatory.

The most common uses of the interactive modes are

Searching for authors, bundles, distribution files and modules
     There are corresponding one-letter commands a, b, d, and m for each
     of the four categories and another, i for any of the mentioned
     four. Each of the four entities is implemented as a class with
     slightly differing methods for displaying an object.

     Arguments you pass to these commands are either strings matching
     exact the identification string of an object or regular expressions
     that are then matched case-insensitively against various attributes
     of the objects. The parser recognizes a regualar expression only if
     you enclose it between two slashes.

     The principle is that the number of found objects influences how an
     item is displayed. If the search finds one item, we display the
     result of object->as_string, but if we find more than one, we
     display each as object->as_glimpse. E.g.

          cpan> a ANDK
          Author id = ANDK
          	EMAIL        a.koenig@franz.ww.TU-Berlin.DE
          	FULLNAME     Andreas König

          cpan> a /andk/
          Author id = ANDK
          	EMAIL        a.koenig@franz.ww.TU-Berlin.DE
          	FULLNAME     Andreas König

          cpan> a /and.*rt/
          Author          ANDYD (Andy Dougherty)
          Author          MERLYN (Randal L. Schwartz)

make, test, install, clean  modules or distributions
     These commands do indeed exist just as written above. Each of them
     takes any number of arguments and investigates for each what it
     might be. Is it a distribution file (recognized by embedded
     slashes), this file is being processed. Is it a module, CPAN
     determines the distribution file where this module is included and
     processes that.

     Any make, test, and `readme' are run unconditionally. A

          install <distribution_file>

     also is run unconditionally.  But for

          install <module>

     CPAN checks if an install is actually needed for it and prints
     *Foo up to date* in case the module doesnE<39>t need to be updated.

     CPAN also keeps track of what it has done within the current
     session and doesnE<39>t try to build a package a second time
     regardless if it succeeded or not. The `force ' command takes as
     first argument the method to invoke (currently: make, test, or
     install) and executes the command from scratch.

     Example:

          cpan> install OpenGL
          OpenGL is up to date.
          cpan> force install OpenGL
          Running make
          OpenGL-0.4/
          OpenGL-0.4/COPYRIGHT
          [...]

readme, look module or distribution
     These two commands take only one argument, be it a module or a
     distribution file. `readme' displays the README of the associated
     distribution file. `Look' gets and untars (if not yet done) the
     distribution file, changes to the appropriate directory and opens a
     subshell process in that directory.


CPAN::Shell
-----------

The commands that are available in the shell interface are methods in
the package CPAN::Shell. If you enter the shell command, all your input
is split by the Text::ParseWords::shellwords() routine which acts like
most shells do. The first word is being interpreted as the method to be
called and the rest of the words are treated as arguments to this
method.


autobundle
----------

autobundle writes a bundle file into the
`$CPAN::Config->{cpan_home}/Bundle' directory. The file contains a list
of all modules that are both available from CPAN and currently installed
within @INC. The name of the bundle file is based on the current date
and a counter.


recompile
---------

recompile() is a very special command in that it takes no argument and
runs the make/test/install cycle with brute force over all installed
dynamically loadable extensions (aka XS modules) with 'force' in
effect. Primary purpose of this command is to finish a network
installation. Imagine, you have a common source tree for two different
architectures. You decide to do a completely independent fresh
installation. You start on one architecture with the help of a Bundle
file produced earlier. CPAN installs the whole Bundle for you, but when
you try to repeat the job on the second architecture, CPAN responds with
a `"Foo up to date"' message for all modules. So you will be glad to run
recompile in the second architecture and youE<39>re done.

Another popular use for recompile is to act as a rescue in case your
perl breaks binary compatibility. If one of the modules that CPAN uses
is in turn depending on binary compatibility (so you cannot run CPAN
commands), then you should try the CPAN::Nox module for recovery.


The 4 `CPAN::*' Classes: Author, Bundle, Module, Distribution
-------------------------------------------------------------

Although it may be considered internal, the class hierarchie does matter
for both users and programmer. CPAN.pm deals with above mentioned four
classes, and all those classes share a set of methods. It is a classical
single polymorphism that is in effect.  A metaclass object registers all
objects of all kinds and indexes them with a string. The strings
referencing objects have a separated namespace (well, not completely
separated):

     Namespace                         Class

     words containing a "/" (slash)      Distribution
      words starting with Bundle::          Bundle
            everything else            Module or Author

Modules know their associated Distribution objects. They always refer to
the most recent official release. Developers may mark their releases as
unstable development versions (by inserting an underbar into the visible
version number), so not always is the default distribution for a given
module the really hottest and newest. If a module Foo circulates on CPAN
in both version 1.23 and 1.23_90, CPAN.pm offers a convenient way to
install version 1.23 by saying

     install Foo

This would install the complete distribution file (say
BAR/Foo-1.23.tar.gz) with all accompanying material in there. But if you
would like to install version 1.23_90, you need to know where the
distribution file resides on CPAN relative to the authors/id/
directory. If the author is BAR, this might be BAR/Foo-1.23_90.tar.gz,
so he would have to say

     install BAR/Foo-1.23_90.tar.gz

The first example will be driven by an object of the class CPAN::Module,
the second by an object of class Distribution.


ProgrammerE<39>s interface
--------------------------

If you do not enter the shell, the available shell commands are both
available as methods (`CPAN::Shell->install(...)') and as functions in
the calling package (`install(...)').

There's currently only one class that has a stable interface,
CPAN::Shell. All commands that are available in the CPAN shell are
methods of the class CPAN::Shell. Each of the commands that produce
listings of modules (r, autobundle, `u') returns a list of the IDs of
all modules within the list.

expand($type,@things)
     The IDs of all objects available within a program are strings that
     can be expanded to the corresponding real objects with the
     `CPAN::Shell->expand("Module",@things)' method. Expand returns a
     list of CPAN::Module objects according to the `@things' arguments
     given. In scalar context it only returns the first element of the
     list.

Programming Examples
     This enables the programmer to do operations that combine
     functionalities that are available in the shell.

          # install everything that is outdated on my disk:
          perl -MCPAN -e 'CPAN::Shell->install(CPAN::Shell->r)'

          # install my favorite programs if necessary:
          for $mod (qw(Net::FTP MD5 Data::Dumper)){
              my $obj = CPAN::Shell->expand('Module',$mod);
              $obj->install;
          }

          # list all modules on my disk that have no VERSION number
          for $mod (CPAN::Shell->expand("Module","/./")){
          	next unless $mod->inst_file;
              # MakeMaker convention for undefined $VERSION:
          	next unless $mod->inst_version eq "undef";
          	print "No VERSION in ", $mod->id, "\n";
          }


Methods in the four
-------------------


Cache Manager
-------------

Currently the cache manager only keeps track of the build directory
($CPAN::Config->{build_dir}). It is a simple FIFO mechanism that deletes
complete directories below `build_dir' as soon as the size of all
directories there gets bigger than $CPAN::Config->{build_cache} (in
MB). The contents of this cache may be used for later re-installations
that you intend to do manually, but will never be trusted by CPAN
itself. This is due to the fact that the user might use these
directories for building modules on different architectures.

There is another directory ($CPAN::Config->{keep_source_where}) where
the original distribution files are kept. This directory is not covered
by the cache manager and must be controlled by the user. If you choose
to have the same directory as build_dir and as keep_source_where
directory, then your sources will be deleted with the same fifo
mechanism.


Bundles
-------

A bundle is just a perl module in the namespace Bundle:: that does not
define any functions or methods. It usually only contains documentation.

It starts like a perl module with a package declaration and a $VERSION
variable. After that the pod section looks like any other pod with the
only difference, that *one special pod section* exists starting with
(verbatim):

     =head1 CONTENTS

In this pod section each line obeys the format

     Module_Name [Version_String] [- optional text]

The only required part is the first field, the name of a module
(eg. Foo::Bar, ie. *not* the name of the distribution file). The rest of
the line is optional. The comment part is delimited by a dash just as in
the man page header.

The distribution of a bundle should follow the same convention as other
distributions.

Bundles are treated specially in the CPAN package. If you say 'install
Bundle::Tkkit' (assuming such a bundle exists), CPAN will install all
the modules in the CONTENTS section of the pod.  You can install your
own Bundles locally by placing a conformant Bundle file somewhere into
your @INC path. The autobundle() command which is available in the shell
interface does that for you by including all currently installed modules
in a snapshot bundle file.

There is a meaningless Bundle::Demo available on CPAN. Try to install
it, it usually does no harm, just demonstrates what the Bundle interface
looks like.


Prerequisites
-------------

If you have a local mirror of CPAN and can access all files with "file:"
URLs, then you only need a perl better than perl5.003 to run this
module. Otherwise Net::FTP is strongly recommended. LWP may be required
for non-UNIX systems or if your nearest CPAN site is associated with an
URL that is not `ftp:'.

If you have neither Net::FTP nor LWP, there is a fallback mechanism
implemented for an external ftp command or for an external lynx command.

This module presumes that all packages on CPAN

   * declare their $VERSION variable in an easy to parse manner. This
     prerequisite can hardly be relaxed because it consumes by far too
     much memory to load all packages into the running program just to
     determine the $VERSION variable . Currently all programs that are
     dealing with version use something like this

          perl -MExtUtils::MakeMaker -le \
              'print MM->parse_version($ARGV[0])' filename

     If you are author of a package and wonder if your $VERSION can be
     parsed, please try the above method.

   * come as compressed or gzipped tarfiles or as zip files and contain
     a Makefile.PL (well we try to handle a bit more, but without much
     enthusiasm).


Debugging
---------

The debugging of this module is pretty difficult, because we have
interferences of the software producing the indices on CPAN, of the
mirroring process on CPAN, of packaging, of configuration, of
synchronicity, and of bugs within CPAN.pm.

In interactive mode you can try "o debug" which will list options for
debugging the various parts of the package. The output may not be very
useful for you as it's just a byproduct of my own testing, but if you
have an idea which part of the package may have a bug, it's sometimes
worth to give it a try and send me more specific output. You should know
that "o debug" has built-in completion support.


Floppy, Zip, and all that Jazz
------------------------------

CPAN.pm works nicely without network too. If you maintain machines that
are not networked at all, you should consider working with file:
URLs. Of course, you have to collect your modules somewhere first. So
you might use CPAN.pm to put together all you need on a networked
machine. Then copy the $CPAN::Config->{keep_source_where} (but not
$CPAN::Config->{build_dir}) directory on a floppy. This floppy is kind
of a personal CPAN. CPAN.pm on the non-networked machines works nicely
with this floppy.


CONFIGURATION
=============

When the CPAN module is installed a site wide configuration file is
created as CPAN/Config.pm. The default values defined there can be
overridden in another configuration file: CPAN/MyConfig.pm. You can
store this file in $HOME/.cpan/CPAN/MyConfig.pm if you want, because
$HOME/.cpan is added to the search path of the CPAN module before the
use() or require() statements.

Currently the following keys in the hash reference $CPAN::Config are
defined:

     build_cache        size of cache for directories to build modules
     build_dir          locally accessible directory to build modules
     index_expire       after how many days refetch index files
     cpan_home          local directory reserved for this package
     gzip		     location of external program gzip
     inactivity_timeout breaks interactive Makefile.PLs after that
                        many seconds inactivity. Set to 0 to never break.
     inhibit_startup_message
                        if true, does not print the startup message
     keep_source        keep the source in a local directory?
     keep_source_where  where keep the source (if we do)
     make               location of external program make
     make_arg	     arguments that should always be passed to 'make'
     make_install_arg   same as make_arg for 'make install'
     makepl_arg	     arguments passed to 'perl Makefile.PL'
     pager              location of external program more (or any pager)
     tar                location of external program tar
     unzip              location of external program unzip
     urllist	     arrayref to nearby CPAN sites (or equivalent locations)

You can set and query each of these options interactively in the cpan
shell with the command set defined within the `o conf' command:

o conf <scalar option>
     prints the current value of the *scalar option*

o conf <scalar option> <value>
     Sets the value of the *scalar option* to value

o conf <list option>
     prints the current value of the *list option* in MakeMaker's
     neatvalue format.

o conf <list option> [shift|pop]
     shifts or pops the array in the *list option* variable

o conf <list option> [unshift|push|splice] <list>
     works like the corresponding perl commands.


SECURITY
========

There's no strong security layer in CPAN.pm. CPAN.pm helps you to
install foreign, unmasked, unsigned code on your machine. We compare to
a checksum that comes from the net just as the distribution file
itself. If somebody has managed to tamper with the distribution file,
they may have as well tampered with the CHECKSUMS file. Future
development will go towards strong authentification.


EXPORT
======

Most functions in package CPAN are exported per default. The reason for
this is that the primary use is intended for the cpan shell or for
oneliners.


BUGS
====

we should give coverage for _all_ of the CPAN and not just the __PAUSE__
part, right? In this discussion CPAN and PAUSE have become equal -- but
they are not. PAUSE is authors/ and modules/. CPAN is PAUSE plus the
clpa/, doc/, misc/, ports/, src/, scripts/.

Future development should be directed towards a better intergration of
the other parts.


AUTHOR
======

Andreas König <a.koenig@mind.de>


SEE ALSO
========

perl(1), CPAN::Nox(3)




File: pm.info, Node: CPAN/FirstTime, Next: CPAN/Nox, Prev: CPAN, Up: Module List

Utility for CPAN::Config file Initialization
********************************************



NAME
====

CPAN::FirstTime - Utility for CPAN::Config file Initialization


SYNOPSIS
========

CPAN::FirstTime::init()


DESCRIPTION
===========

The init routine asks a few questions and writes a CPAN::Config
file. Nothing special.




File: pm.info, Node: CPAN/Nox, Next: CPAN/WAIT, Prev: CPAN/FirstTime, Up: Module List

Wrapper around CPAN.pm without using any XS module
**************************************************



NAME
====

CPAN::Nox - Wrapper around CPAN.pm without using any XS module


SYNOPSIS
========

Interactive mode:

     perl -MCPAN::Nox -e shell;


DESCRIPTION
===========

This package has the same functionality as CPAN.pm, but tries to prevent
the usage of compiled extensions during it's own execution. It's primary
purpose is a rescue in case you upgraded perl and broke binary
compatibility somehow.


SEE ALSO
========

CPAN(3)




File: pm.info, Node: CPAN/WAIT, Next: Carp, Prev: CPAN/Nox, Up: Module List

adds commands to search a WAIT4CPAN server to the CPAN `shell()'
****************************************************************



NAME
====

CPAN::WAIT - adds commands to search a WAIT4CPAN server to the CPAN
`shell()'


SYNOPSIS
========

     perl -MCPAN -e shell
     > wq au=wall
     > wr 3
     > wd 3
     > wl 20
     > wh
     > wh wq


DESCRIPTION
===========

*CPAN::WAIT* adds some comands to the CPAN `shell()' to perform
searches on a WAIT server. It connects to a WAIT server using a simple
protocoll resembling NNTP as described in RFC977. It uses the
*WAIT::Client* module to handle this connection. This in turn
inherits from *Net::NNTP* from the `libnet' package. So you need
*Net::NNTP* to use this module.

If no direct connection to the WAIT server is possible, the modules
tries to connect via your HTTP proxy (as given by the CPAN
configuration). Be warned though that the emulation of the stateful
protocol via HTTP is slow.

The variable `CPAN::WAIT::TIMEOUT' specifies the number of seconds to
wait for an answer from the server. The default is 20. You may want to
set it to some larger value if you have a slow connection.

The commands available are:

wh [command]
     Displays a short help message if called without arguments. If you
     provide the name of another command you will get more information
     on this command if available. Currently only wq will be explained.

wl count
     Limit the number of hits returned in a search to count. The limit
     usually is set ot 10 of you don't set it.

wq query
     Send a query to the server.

     Here are some query examples:

          information retrieval               free text query 
          information or retrieval            same as above 
          des=information retrieval           `information' must be in the description 
          des=(information retrieval)         one of them in description 
          des=(information or retrieval)      same as above 
          des=(information and retrieval)     both of them in description 
          des=(information not retrieval)     `information' in description and
                                              `retrieval' not in description 
          des=(information system*)           wild-card search
          au=ilia                             author names may be misspelled

     You can build arbitary boolean combination of the above examples.
     Field names may be abbreviated. For further information see
     `http://ls6-www.informatik.uni-dortmund.de/CPAN'

     The result should look like this:

          wq au=wall

          1 8.039 a2p - Awk to Perl translator 
          2 8.039 s2p - Sed to Perl translator 
          3 8.039 perlipc - Perl interprocess communication (signals, fifos, pipes, safe subprocesses, sockets, and semaphores) 
          4 8.039 ExtUtils::DynaGlue - Methods for generating Perl extension files 
          5 8.039 h2xs - convert .h C header files to Perl extensions 
          6 8.039 Sys::Syslog, openlog, closelog, setlogmask, syslog - Perl interface to the UNIX syslog(3) calls 
          7 8.039 h2ph - convert .h C header files to .ph Perl header files 
          8 8.039 Shell - run shell commands transparently within perl 
          9 8.039 pl2pm - Rough tool to translate Perl4 .pl files to Perl5 .pm modules. 
            10 8.039 perlpod - plain old documentation 

wr *hit-number*
     Display the Record of hit number *hit-number*:

          wr 1

          source          authors/id/CHIPS/perl5.003_24.tar.gz
          headline        a2p - Awk to Perl translator 
          size            5643
          docid           data/perl/x2p/a2p.pod

wd *hit-number*
     Fetches the full text from the server and runs *perlpod* on it. Make
     sure that you have *perlpod* in your path. Also check if your
     *perlpod* version can handle absolute pathes. Some older versions
     ironically do not find a document if the full patch is given on the
     command line.


AUTHOR
======

Ulrich Pfeifer <`pfeifer@ls6.informatik.uni-dortmund.de'>




File: pm.info, Node: Carp, Next: Chart, Prev: CPAN/WAIT, Up: Module List

warn of errors (from perspective of caller)
*******************************************



NAME
====

carp - warn of errors (from perspective of caller)

cluck - warn of errors with stack backtrace
          (not exported by default)

croak - die of errors (from perspective of caller)

confess - die of errors with stack backtrace


SYNOPSIS
========

     use Carp;
     croak "We're outta here!";

     use Carp qw(cluck);
     cluck "This is how we got here!";


DESCRIPTION
===========

The Carp routines are useful in your own modules because they act like
die() or warn(), but report where the error was in the code they were
called from.  Thus if you have a routine Foo() that has a carp() in it,
then the carp() will report the error as occurring where Foo() was
called, not where carp() was called.


Forcing a Stack Trace
---------------------

As a debugging aid, you can force Carp to treat a croak as a confess and
a carp as a cluck across all modules. In other words, force a detailed
stack trace to be given.  This can be very helpful when trying to
understand why, or from where, a warning or error is being generated.

This feature is enabled by 'importing' the non-existant symbol
'verbose'. You would typically enable it by saying

     perl -MCarp=verbose script.pl

or by including the string `MCarp=verbose' in the `PERL5OPT' in this
node environment variable.




File: pm.info, Node: Chart, Next: Class/Eroot, Prev: Carp, Up: Module List

a series of charting modules
****************************



NAME
====

Chart::* - a series of charting modules


SYNOPSIS
========

     use Chart::type;

     $obj = Chart::type->new;
     $obj = Chart::type->new ( $gif_width, $gif_height );
   
     $obj->set ( $key_1, $val_1, ... ,$key_n, $val_n );
     $obj->set ( $key_1 => $val_1,
     	        ...
     	        $key_n => $val_n );
     $obj->set ( %hash );

     # GIFgraph.pm-style API
     @data = ( \@x_tick_labels, \@dataset1, ... , \@dataset_n );
     $obj->gif ( "filename", \@data );
     $obj->cgi_gif ( \@data );

     # Graph.pm-style API
     $obj->add_pt ($label, $val_1, ... , $val_n);
     $obj->add_dataset ($val_1, ... , $val_n);
     $obj->gif ( "filename" );
     $obj->cgi_gif ();


DESCRIPTION
===========

This module is an attempt to build a general purpose graphing module
that is easily modified and expanded.  I borrowed most of the API from
Martien Verbruggen's GIFgraph module.  I liked most of GIFgraph, but I
thought it was to difficult to modify, and it was missing a few things
that I needed, most notably legends.  So I decided to write a new module
from scratch, and I've designed it from the bottom up to be easy to
modify.  Like GIFgraph, Chart::* uses Lincoln Stein's GD module for all
of its graphics primitives calls.


use-ing Chart
-------------

Okay, so you caught me.  There's really no Chart::type module.  All of
the different chart types (Points, Lines, Bars, LinesPoints,
StackedBars, Pie, and Pareto so far) are classes by themselves, each
inheriting a bunch of methods from the Chart::Base class.  Simply
replace the word type with the type of chart you want and you're on your
way.  For example,
  
  use Chart::Lines;

would invoke the lines module.


Getting an object
-----------------

The new method can either be called without arguments, in which case it
returns an object with the default image size (400x300 pixels), or you
can specify the width and height of the image.  Just remember to replace
type with the type of graph you want.  For example,

     $obj = Chart::Bars (600,400);

would return a Chart::Bars object containing a 600x400 pixel image.  New
also initializes most of the default variables, which you can
subsequently change with the set method.


Setting different options
-------------------------

This is where the fun begins.  Set looks for a hash of keys and values.
You can pass it a hash that you've already constructed, like

     %hash = ('title' => 'Foo Bar');
     $obj->set (%hash);

     or you can try just constructing the hash inside the set call, like

     $obj->set ('title', 'Foo Bar');

or

     $obj->set ('title' => 'Foo Bar');

The following are all of the currently supported options:

'gif_border'
     Sets the number of pixels used as a border between the graph and
     the edges of the gif.  Defaults to 10.

'graph_border'
     Sets the number of pixels used as a border between the title/labels
     and the actual graph within the gif.  Defaults to 10.

'text_space'
     Sets the amount of space left on the sides of text, to make it more
     readable.  Defaults to 2.

'title'
     Tells GD graph what to use for the title of the graph.  If empty,
     no title is drawn.  Default is empty.

'sub_title'
     The second line for the title, if needed.  Default is empty.

'x_label'
     Tells Chart::* what to use for the x-axis label.  If empty, no
     label is drawn.  Default is empty.

'y_label'
     Tells Chart::* what to use for the y-axis label.  If empty, no
     label is drawn.  Default is empty.

'legend'
     Draws a legend in the upper-right corner of the gif when set to
     'true'.  Default is 'true'.

'legend_labels'
     Sets the values for the labels for the different datasets.  Should
     be assigned a reference to an array of labels.  For example,
  
       @labels = ('foo', 'bar');
       $obj->set ('legend_labels' => \@labels);

     Default is empty, in which case 'Dataset 1', 'Dataset 2', etc. are
     used as the labels.

     For a pareto graph, the first value should be the name of the set,
     and the second should be the name of the running sum of the values.

     For a pie graph, this option is ignored, as the values for the
     legend are taken from the array of data point labels.

'tick_len'
     Sets the length of the x- and y-ticks in pixels.  Default is 4.

'stagger_x_labels'
     Staggers the x-tick labels vertically to make them readable if set
     to 'true'.  Default is 'true'.

'y_ticks'
     Sets the number of y_ticks to draw.  Default is 5.

'max_val'
     Sets the maximum y-value on the graph, cancelling the auto-scaling.
     Default is undef.

'pt_size'
     Sets the size of the points for points, linespoints, and pareto
     graphs.  Points are drawn as squares with sides of length
     'pt_size'.  Default is 4.

'dashed_lines'
     Uses dashed lines, instead of solid lines, for the graph.  If this
     is set to any other value than '' or undef, it will draw dashed
     lines.  (I use this when the chart is going to be printed with a
     B&W printer.  Unfortunately, it's hard to differentiate the lines
     after 4 datasets.  There just weren't enough different ways to make
     dotted lines.)  Default is undef.

'skip_x_ticks'
     Sets the number of x-ticks and x-tick labels to skip.  (ie.  if
     'skip_x_ticks' was set to 4, Chart::* would draw every 4th x-tick
     and x-tick label).  Default is undef.

'custom_x_ticks'
     Used in points, lines, linespoints, and bars charts, this option
     allows you to specify exatly which x-ticks and x-tick labels should
     be drawn.  It should be assigned a reference to an array of desired
     ticks.  Just remember that I'm counting from the 0th element of the
     array.  (ie., if 'custom_x_ticks' is assigned [0,3,4], then the
     0th, 3rd, and 4th x-ticks will be displayed)

'sort'
     Tells Chart::* to sort the data before plotting it.  Can be
     assigned an order ('asc' or 'desc' for ascending and descending,
     respectively), in which case it sorts numerically.  Or it can also
     be assigned an array reference.  The array reference should contain
     3 elements: the order in which to search (as above), which dataset
     to use (remember that 0 is the x-tick labels), and the type of sort
     to do ('alpha' or 'num' for alphabetical or numerical sorts,
     respectively).  For example,

          $obj->set ('sort' => ['asc', 2, 'num']);

     would sort the data numerically in ascending order, sorting by the
     third dataset (second if you don't count the x-tick labels).  Note
     that

          $obj->set ('sort' => ['asc', 0, 'alpha']);

     will sort the data in ascending alphabetical order by the x-tick
     labels.  Defualts to undef, normally, and 'desc' for pareto.

'nosort'
     Turns off the default sort for pareto graphs.  Default is undef.

'cutoff'
     Only used for pareto graphs, this option determines where the
     cut-off point is.  It then lumps everything after the highest
     'cutoff' data points into an 'Other' entry on the graph.  Default
     is 5.

'nocutoff'
     Turns off the default 'cutoff' feature of pareto graphs.  Defaut is
     undef.


GIFgraph.pm-style API
---------------------

Sending the image to a file
     Invoking the gif method causes the graph to be plotted and saved to
     a file.  It takes the name of the output file and a reference to
     the data as arguments.  For example,

          $obj->gif ("foo.gif", \@data);

     would plot the data in @data, and the save the image to foo.gif.
     Of course, this then beggars the question "What should @data look
     like?".  Well, just like GIFgraph, @data should contain references
     to arrays of data, with the first array reference pointing to an
     array of x-tick labels.  For example,

          @data = ( [ 'foo', 'bar', 'junk' ],
          	    [ 30.2,  23.5,  92.1   ] );

     would set up a graph with one dataset, and three data points in
     that set.  In general, the @data array should look something like

          @data = ( \@x_tick_labels, \@dataset1, ... , \@dataset_n );

     And no worries, I make my own internal copy of the data, so that it
     doesn't touch yours.

CGI and Chart::*
     Okay, so you're probably thinking, "Do I always have to save these
     images to disk?  What if I want to use Chart::* to create dynamic
     images for my web site?"  Well, here's the answer to that.

          $obj->cgi_gif ( \@data );

     The cgi_gif method will print the chart, along with the appropriate
     http header, to stdout, allowing you to call chart-generating
     scripts directly from your html pages (ie. with a <img
     src=image.pl> HTML tag).  The @data array should be set up the same
     way as for the normal gif method.


Graph.pm-style API
------------------

You might ask, "But what if I just want to add a few points to the
graph, and then display it, without all those references to
references?".  Well, friend, the solution is simple.  Borrowing the
add_pt idea from Matt Kruse's Graph.pm, you simply make a few calls to
the add_pt method, like so:

     $obj->add_pt ('foo', 30, 25);
     $obj->add_pt ('bar', 16, 32);

Or, if you want to be able to add entire datasets, simply use the
add_dataset method:

     $obj->add_dataset ('foo', 'bar');
     $obj->add_dataset (30, 16);
     $obj->add_dataset (25, 32);

These methods check to make sure that the points and datasets you are
adding are the same size as the ones already there.  So, if you have two
datasets currently stored, and try to add a data point with three
different values, it will carp (from Carp.pm) an error message and
return undef.  Similarly, if you try to add a dataset with 4 data
points, and all the other datasets have 3 data points, it will carp an
error message and return undef.

Don't forget, when using this API, that I treat the first dataset as a
series of x-tick labels.  So, in the above examples, the graph would
have two x-ticks, labeled 'foo' and 'bar', each with two data points.

Clearing the data
     A simple call to the clear_data method empties any values that may
     have been entered.

          $obj->clear_data ();

Getting a copy of the data
     If you want a copy of the data that has been added so far, make a
     call to the get_data method like so:

          $dataref = $obj->get_data;

     It returns (you guessed it!) a reference to an array of references
     to datasets.  So the x-tick labels would be stored as

          @x_labels = @{$dataref->[0]};

Sending the image to a file
     Invoking the gif method causes the graph to be plotted and saved to
     a file.  It takes the name of the output file as an argument.  For
     example,

          $obj->gif ("foo.gif");

     would plot the data , and the save the image to foo.gif.

CGI and Chart::*
     Okay, so you're probably thinking (again), "Do I always have to
     save these images to disk?  What if I want to use Chart::* to
     create dynamic images for my web site?"  Well, here's the answer to
     that.

          $obj->cgi_gif ();

     The cgi_gif method will print the chart, along with the appropriate
     http header, to stdout, allowing you to call chart-generating
     scripts directly from your html pages (ie. with a <img
     src=image.pl> HTML tag).


TO DO
=====

A bunch of things.  The most pressing being

   * Add in support for negative values.  (I consider this a bug)

   * Add more customization, such as fonts, colors, etc. for each
     element of the chart.

   * Add some 3-D graphs.


BUGS
====

This module can't graph negative values yet.  There are probably lots
more, since I consider this an alpha release.  Mail me with any bugs,
comments, suggestions, flames, death threats, etc.


AUTHOR
======

David Bonner (dbonner@cs.bu.edu)


COPYRIGHT
=========

Copyright(c) 1997 by David Bonner.  All rights reserved.  This program
is free software; you can redistribute it and/or modify it under the
same terms as Perl itself.



File: pm.info, Node: Class/Eroot, Next: Class/MethodMaker, Prev: Chart, Up: Module List

an eternal root to handle persistent objects
********************************************



NAME
====

Eroot - an eternal root to handle persistent objects


ABSTRACT
========

The Eternal Root (eroot) is given references to the root objects of any
object hierarchies which must persist between separate invocations of
the application.  When the eroot's destructor is called, the eroot will
find all objects referenced in the object hierarchies and will store
them.  All objects will be restored (if possible) when and if the
*Continue* message is sent to the eroot.


SYNOPSIS
========

     require Class::Eroot;
     my $some_obj;
     my $eroot = new EROOT ( 'Name' => "persist.file",
     			  'Key'  => "myAppObjects" );

     if( $eroot->Continue ){
     	# No existing objects.  Start from scratch.
     	$some_obj = new SomeObj;
     	$eroot->Keep( "Some_obj" => $some_obj );
     }
     else{
     	$some_obj = $eroot->Root("some_obj");
     }

     $eroot->List;
     $eroot->Keep( "MyObj" => $myobj );
     $eroot->Lose( "Old_Obj" );
     $eroot->Lose( $this_obj );


DESCRIPTION
===========

When the eroot saves a group of object hierarchies, it stores its key
with them.  The key of any objects being restored must match the key of
the eroot which is trying to restore them.  The *Continue* method will
call die if the keys do not match.  Continue will return 0 if the
objects were loaded and non-zero if they were not.

The eroot will attempt to send a *suspend* message to the object prior
to storing the object's state.  The object's class is not required to
have a suspend method defined.

When the eroot restores an object it will bless the object reference in
the object's class (package) and will attempt to send a *resume* message
to the object.  The object's class is not required to have a resume
method defined.

An object should not propagate *suspend* and *resume* messages.  The
eroot will send suspend messages to the objects in the order in which
they were stored in the eroot (breadth-first, root-to-leaves).  The
eroot will send resume messages by starting with the classes of the
objects at the leaves of the object hierarchy and moving toward the root
of the object hierarchy.

Note that Perl will call the *destructors* of the persistent objects.
The programmer should be prepared to deal with this.

It is necessary to *Keep* an object only once.  The object will remain
persistent until the eroot is told to *Lose* it.


INSTANCE VARIABLES
==================

References will be properly hooked up if they are type SCALAR, ARRAY, REF,
or HASH.  The eroot assumes that keys and values (if the value is not a
reference) for the objects' *instance variables* can be represented as text
within single quotes.  If this is not true for your objects then the object's
*suspend* method can be used to "wrap" the object for storage, and the
*resume* method can be used to "unwrap" the object.

Embedded single quotes in the value will be preserved.  This is
currently the only place where single quotes are handled.


THINGS TO AVOID
===============

     o Storing the eroot.
     o Storing references to tie()'d variables and objects.
     o Storing references to CODE objects.
     o Storing the same object in two different eroots.
       Unless you think you know what you're doing, of course.
     o Using two eroots to store each other :)
     o Storing named arrays and hashes.  These will be restored as
       anonymous arrays and hashes.
     o Storing an object while it has an open stream.
     o Storing an object which has an %OVERLOAD somewhere in
       it's class hierarchy.

Know your object hierarchy.  Be sure that everything in the hierarchy
can handle persistence.


NOTES
=====

This is not an OODBMS.


FILES
=====

     Class::Eroot.pm	- Eternal Root class.
     persist.file	- User-defined file where objects are stored.
     Class::Template.pm	- Struct/member template builder.




File: pm.info, Node: Class/MethodMaker, Next: Class/Struct, Prev: Class/Eroot, Up: Module List

a module for creating generic methods
*************************************



NAME
====

*Class::MethodMaker* - a module for creating generic methods


SYNOPSIS
========

use Class::MethodMaker
  new_with_init => 'new',
  get_set => [ qw /foo bar baz / ];


DESCRIPTION
===========

This module solves the problem of having to write a bazillion get/set
methods that are all the same. The argument to 'use' is a hash whose
keys are the names of types of generic methods generated by MethodMaker
and whose values tell method maker what methods to make. (More
precisely, the keys are the names of MethodMaker methods (methods that
write methods) and the values are the arguments to those methods.


SUPPORTED METHOD TYPES
======================


new
---

Creates a basic constructor.

Takes a single string or a reference to an array of strings as its
argument. For each string creates a method of the form:

     sub <string> {
       my ($class, @args) = @_;
       my $self = {};
       bless $self, $class;
     }


new_with_init
-------------

Creates a basic constructor which calls a method named init after
instatiating the object. The init() method should be defined in the
class using MethodMaker.

Takes a single string or a reference to an array of strings as its
argument. For each string creates a method of the form listed below.

     sub <string> {
       my ($class, @args) = @_;
       my $self = {};
       bless $self, $class;
       $self->init(@args);
       $self;
     }


new_hash_init
-------------

Creates a basic constructor which accepts a hash of slot-name/value
pairs with which to initialize the object. The slot-names are
interpreted as the names of methods that can be called on the object
after it is created and the values are the arguments to be passed to
those methods.

Takes a single string or a reference to an array of strings as its
argument. For each string creates a method of the form listed
below. Note that this method can be called on an existing objec, which
allows it to be combined with new_with_init (see above) to provide some
default values. (Basically, declare a new_with_init method, say 'new'
and a new_hash_init method, for example, 'hash_init' and then in the
init method, you can call modify or add to the %args hash and then call
hash_init.)

     sub <string> {
       my ($class, %args) = @_;
       my $self = {};
       bless $self, $class;
       foreach (keys %args) {
     	$self->$_($args{$_});
       }
       $self;
     }


get_set
-------

Takes a single string or a reference to an array of strings as its
argument. For each string, x creates two methods:

     sub x {
       my ($self, $new) = @_;
       defined $new and $self->{$name} = $new;
       $self->{$name};
     }

     sub clear_x
       my ($self) = @_;
       $self->{$name} = undef;
     }

This is your basic get/set method, and can be used for slots containing
any scalar value, including references to non-scalar data. Note,
however, that MethodMaker has meta-methods that define more useful sets
of methods for slots containing references to lists, hashes, and
objects.


get_concat
----------

Like get_set except sets don't clear out the original value, but instead
concatenate the new value to the existing one. Thus these slots are only
good for plain scalars. Also, like get_set, defines clear_foo method.


fields
------

Creates get/set methods like get_set but also defines a method which
returns a list of the slots in the group.

     fields => {
     	     group => 'group_name',
     	     slots => [ qw / slot1 slot2 / ]
     	    }

Takes a single hash-ref or a reference to an array of hash-refs as its
argument. Each hash-ref should have have the keys group and slots. The
group value is the name of the method which returns the list of slots
and the slots value should be an acceptable argument for get_set.


object
------

Creates methods for accessing a slot that contains an object of a given
class as well as methods to automatically pass method calls onto the
object stored in that slot.

     object => [
     	       'Foo' => 'phooey',
     	       'Bar' => [ qw / bar1 bar2 bar3 / ],
     	       'Baz' => {
                          slot => 'foo',
                          comp_mthds => [ qw / bar baz / ]
                         },
               ];

This is a hairy one. The main argument should be a reference to an
array. The array should contain pairs of class => sub-argument
pairs. The sub-argument's are further parsed thusly:

If the sub-argument is a simple string or a reference to an array of
strings (as is the case for Foo and Bar above), for each string a
get/set method is created that can store an object of that class. (The
get/set method, if called with a reference to an object of the given
class as the first argument, stores it in the slot. If the slot isn't
filled yet it creates an object by calling the given class's new
method. Any arguments passed to the get/set method are passed on to
new. In all cases the object now stored in the slot is returned.

If the sub-argument is a ref to a hash (as with Baz, above) then the
hash should have two keys: slot and comp_mthds. The value indexed by
'slot' will be interpreted as the is in (a). The value or values (ref to
an array if plural) indexed by 'comp_mthds' are the names of methods
which should be "inherited" from the object stored in the slot. That is,
using the example above, a method, foo, is created in the class that
calls MethodMaker, which can get and set the value of a slot containing
an object of class Baz. Class Baz in turn defines two methods, 'bar',
and 'baz'. Two more methods are created in the class using MethodMaker,
named 'bar' and 'baz' which result in a call to the 'bar' and 'baz'
methods, through the Baz object stored in slot foo.


boolean
-------

     boolean => [ qw / foo bar baz / ]

Creates methods for setting, checking and clearing flags. All flags
created with this meta-method are stored in a single vector for space
efficiency. The argument to boolean should be a string or a reference to
an array of strings. For each string x it defines several methods: x,
set_x, and clear x. x returns the value of the x-flag. If called with an
argument, it first sets the x-flag to the truth-value of the
argument. set_x is equivalent to x(1) and clear_x is equivalent to x(0).

Additionally, boolean defines three class method: *bits*, which returns
the vector containing all of the bit fields (remember however that a
vector containing all 0 bits is still true), *boolean_fields*, which
returns a list of all the flags by name, and *bit_dump*, which returns a
hash of the flag-name/flag-value pairs.


listed_attrib
-------------

     listed_attrib => [ qw / foo bar baz / ]

Like boolean, listed_attrib creates x, set_x, and clear_x
methods. However, it also defines a class method x_objects which returns
a list of the objects which presently have the x-flag set to
true. N.B. listed_attrib does not use the same space efficient
implementation as boolean, so boolean should be prefered unless the
x_objects method is actually needed.


key_attrib
----------

     key_attrib => [ qw / foo bar baz / ]

Creates get/set methods like get/set but also maintains a hash in which
each object is stored under the value of the field when the slot is
set. If an object has a slot set to a value which another object is
already set to the object currently set to that value has that slot set
to undef and the new object will be put into the hash under that
value. (I.e. only one object can have a given key. The method find_x is
defined which if called with any arguments returns a list of the objects
stored under those values in the hash. Called with no arguments, it
returns a reference to the hash.


key_with_create
---------------

     key_with_create => [ qw / foo bar baz / ]

Just like key_attrib except the find_x method is defined to call the new
method to create an object if there is no object already stored under
any of the keys you give as arguments.


list
----

Creates several methods for dealing with slots containing list
data. Takes a string or a reference to an array of strings as its
argument and for each string, x, creates the methods: x, push_x, and
pop_x. The method x returns the list of values stored in the slot. In an
array context it returns them as an array and in a scalar context as a
reference to the array. If called with arguments, x will push them onto
the list. push_x and pop_x do about what you would expect.


hash
----

Creates a group of methods for dealing with hash data stored in a
slot. Takes a string or a reference to an array of strings and for each
string, x, creates: x, x_keys, x_values, and x_tally. Called with no
arguments x returns the hash stored in the slot, as a hash in an array
context or as a refernce in a scalar context. Called with one argument
it treats the argument as a key and returns the value stored under that
key, or as a list of keys (if it is a reference to a list) and returns
the list of values stored under those keys. Called with more than one
argument, treats them as a series of key/value pairs and adds them to
the hash. x_keys returns the keys of the hash, and x_values returns the
list of values. x_tally takes a list of arguments and for each scalar in
the list increments the value stored in the hash and returns a list of
the current (after the increment) values.


code
----

     code => [ qw / foo bar baz / ]

Creates a slot that holds a code reference. Takes a string or a
reference to a list of string and for each string, x, creates a method x
which if called with one argument which is a CODE reference, it installs
that code in the slot. Otherwise it runs the code stored in the slot
with whatever arguments (including none) were passed in.


method
------

     method => [ qw / foo bar baz / ]

Just like code, except the code is called like a method, with $self as
it's first argument. Basically, you're creating a method which can be
different for each object. Which is sort of weird. But perhaps useful.


interface
---------

     interface => [ qw / foo bar baz / ]


ADDDING NEW METHOD TYPES
========================

MethodMaker is a class that can be inherited. A subclass can define new
method types by writing a method that returns a hash of
method_name/code-reference pairs.

For example a simple sub-class that defines a method type
upper_case_get_set might look like this:

     package Class::MethodMakerSubclass;

     use strict;
     use Class::MethodMaker;

     @Class::MethodMakerSubclass::ISA = qw ( Class::MethodMaker );

     sub upper_case_get_set {
       shift; # we don't need the class name
       my ($name) = @_;
       my %results;
       $results{$name} =
         sub {
     	my ($self, $new) = @_;
     	defined $new and $self->{$name} = uc $new;
     	$self->{$name};
         };
       %results;
     }

     1;


VERSION
=======

Class::MethodMaker v0.9




